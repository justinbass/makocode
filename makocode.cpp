/*
    makocode.cpp
    ------------
    Monolithic CLI for the MakoCode archival-to-image pipeline. This single
    translation unit packages file trees into printable/scannable PPM pages and
    performs the full reverse decode, including optional encryption and forward
    error correction, without relying on external libraries.

    Supported commands:
        * `encode` bundles files/directories into an MKARCH01 archive, applies
          maximum-ratio LZMA compression, optional ChaCha20-Poly1305 encryption, optional
          Reed-Solomon ECC, and maps the bitstream onto fiducial-marked PPM pages
          with configurable color channels and footer text.
        * `decode` ingests PPM pages (files or stdin), reconstructs payload
          bitstreams, repairs ECC, decrypts when required, and unpacks the archive
          into the requested output directory.
        * `overlay` blends a mask/overlay page onto an encoded base page.
        * `minify` strips comments/whitespace to emit `makocode_minified.cpp`.

    Core subsystems:
        * MKARCH01 archive builder that normalizes paths and captures directory
          trees for the encoder.
        * Shared buffers, bitstream helpers, fiducial/page layout math, and
          portable PPM I/O for grayscale and color modes with footer layout logic.
        * ChaCha20-Poly1305 implementation, Reed-Solomon GF(2^8) tables, and ECC
          metadata repair helpers used by both encode/decode paths.
        * Synthetic scan/distortion pipelines that simulate rotation, ripple,
          skew, and debris to validate robustness of the decoder.

    Data shuffling:
        * Deterministic Fisher-Yates permutation operates per byte to evenly scatter LZMA/ECC output across pages.
        * Protects long-term archives because edge pages in a stored stack take the most wear; dispersal keeps full-page loss recoverable.
    Test artifact naming:
        * 1*** files stem from focused unit/function scenarios that isolate codec
          behaviors.
        * 2*** files come from broader integration-style payload suites that mix
          scaling, color channels, and distortions.
        * 3*** files are end-to-end CLI regressions; e.g., 3001 covers encode/decode
          round-trip artifacts
        * `output_dir` mostly tests the `--output-dir` case.

    Data grid layout specification:
        * Header section contains fiducials, calibration bars, and QR-like metadata blocks.
        * Data section tiles LZMA/ECC payload stripes with parity gutters and alignment rails.
        * Footer section repeats checksums, color bars, and page/total counters.

    License: GNU AGPLv3 (intent inherited from the project notes).
*/

#include <dirent.h>
#include <errno.h>
#include <stddef.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>

#ifndef SIZE_MAX
#define SIZE_MAX ((size_t)~(size_t)0)
#endif

#ifndef O_RDONLY
#define O_RDONLY 0
#endif
#ifndef O_WRONLY
#define O_WRONLY 1
#endif
#ifndef O_CREAT
#define O_CREAT 0x0200
#endif
#ifndef O_TRUNC
#define O_TRUNC 0x0400
#endif

typedef unsigned char       u8;
typedef unsigned short      u16;
typedef unsigned int        u32;
typedef unsigned long       usize;
typedef unsigned long long  u64;
typedef long long           i64;

static const usize USIZE_MAX_VALUE = (usize)~(usize)0;
static const u64 U64_MAX_VALUE = (u64)~(u64)0;

extern "C" void* malloc(unsigned long size);
extern "C" void  free(void* ptr);
extern "C" int   write(int fd, const void* buf, unsigned long count);
extern "C" int   read(int fd, void* buf, unsigned long count);
extern "C" void  exit(int code);
extern "C" int   close(int fd);
extern "C" int   creat(const char* path, unsigned int mode);
extern "C" int   unlink(const char* path);
extern "C" int   open(const char* path, int flags, ...);
extern "C" void* realloc(void* ptr, unsigned long size);
extern "C" double sqrt(double value);
extern "C" double floor(double value);
extern "C" double ceil(double value);
extern "C" double fabs(double value);
extern "C" double sin(double value);
extern "C" double cos(double value);
extern "C" double asin(double value);
extern "C" double atan2(double y, double x);
extern "C" double log(double value);
extern "C" long double logl(long double value);
extern "C" long double ceill(long double value);
struct tm;
extern "C" long  time(long* tloc);
extern "C" struct tm* gmtime(const long* timep);
extern "C" unsigned long strftime(char* s, unsigned long max, const char* format, const struct tm* tm);
extern "C" char* realpath(const char* path, char* resolved_path);
extern "C" char* getcwd(char* buf, unsigned long size);
extern "C" int   chdir(const char* path);
extern "C" int   snprintf(char* buf, unsigned long size, const char* format, ...);
extern "C" char* getenv(const char* name);

static u16 read_le_u16(const u8* ptr);
static u32 read_le_u32(const u8* ptr);
static u64 read_le_u64(const u8* ptr);
static void write_le_u16(u8* ptr, u16 value);
static void write_le_u32(u8* ptr, u32 value);
static void write_le_u64(u8* ptr, u64 value);

static u16 read_le_u16(const u8* ptr) {
    return (u16)ptr[0] | ((u16)ptr[1] << 8);
}

static u32 read_le_u32(const u8* ptr) {
    return (u32)ptr[0] | ((u32)ptr[1] << 8) | ((u32)ptr[2] << 16) | ((u32)ptr[3] << 24);
}

static u64 read_le_u64(const u8* ptr) {
    u64 low = (u64)read_le_u32(ptr);
    u64 high = (u64)read_le_u32(ptr + 4u);
    return low | (high << 32u);
}

static void write_le_u16(u8* ptr, u16 value) {
    ptr[0] = (u8)(value & 0xFFu);
    ptr[1] = (u8)((value >> 8u) & 0xFFu);
}

static void write_le_u32(u8* ptr, u32 value) {
    ptr[0] = (u8)(value & 0xFFu);
    ptr[1] = (u8)((value >> 8u) & 0xFFu);
    ptr[2] = (u8)((value >> 16u) & 0xFFu);
    ptr[3] = (u8)((value >> 24u) & 0xFFu);
}

static void write_le_u64(u8* ptr, u64 value) {
    write_le_u32(ptr, (u32)(value & 0xFFFFFFFFull));
    write_le_u32(ptr + 4u, (u32)((value >> 32u) & 0xFFFFFFFFull));
}

static usize ascii_length(const char* text) {
    if (!text) {
        return 0;
    }
    const char* cursor = text;
    while (*cursor) {
        ++cursor;
    }
    return (usize)(cursor - text);
}

static int ascii_compare(const char* a, const char* b) {
    if (a == b) {
        return 0;
    }
    if (!a) {
        return -1;
    }
    if (!b) {
        return 1;
    }
    while (*a && (*a == *b)) {
        ++a;
        ++b;
    }
    return ((unsigned char)(*a) < (unsigned char)(*b)) ? -1 :
           ((unsigned char)(*a) > (unsigned char)(*b)) ?  1 : 0;
}

static bool ascii_starts_with(const char* text, const char* prefix) {
    if (!text || !prefix) {
        return false;
    }
    while (*prefix) {
        if (*text != *prefix) {
            return false;
        }
        ++text;
        ++prefix;
    }
    return true;
}

static bool ascii_equals_token(const char* text, usize length, const char* keyword) {
    if (!text || !keyword) {
        return false;
    }
    usize index = 0u;
    while (keyword[index]) {
        if (index >= length || text[index] != keyword[index]) {
            return false;
        }
        ++index;
    }
    return (index == length);
}

static char ascii_lower_char(char c) {
    if (c >= 'A' && c <= 'Z') {
        return (char)(c + 32);
    }
    return c;
}

static bool ascii_hex_value(char c, u8& value) {
    if (c >= '0' && c <= '9') {
        value = (u8)(c - '0');
        return true;
    }
    if (c >= 'A' && c <= 'F') {
        value = (u8)(10 + (c - 'A'));
        return true;
    }
    if (c >= 'a' && c <= 'f') {
        value = (u8)(10 + (c - 'a'));
        return true;
    }
    return false;
}

static bool is_power_of_two_u32(u32 value) {
    return (value > 0u) && ((value & (value - 1u)) == 0u);
}

static u32 log2_u32(u32 value) {
    u32 result = 0u;
    while (value > 1u) {
        value >>= 1u;
        ++result;
    }
    return result;
}

static bool ascii_equals_token_ignore_case(const char* text,
                                           usize length,
                                           const char* keyword) {
    if (!text || !keyword) {
        return false;
    }
    usize index = 0u;
    while (keyword[index]) {
        if (index >= length) {
            return false;
        }
        char lhs = ascii_lower_char(text[index]);
        char rhs = ascii_lower_char(keyword[index]);
        if (lhs != rhs) {
            return false;
        }
        ++index;
    }
    return (index == length);
}

static bool ascii_to_u64(const char* text, usize length, u64* out_value) {
    if (!text || !out_value || length == 0u) {
        return false;
    }
    u64 value = 0u;
    for (usize i = 0u; i < length; ++i) {
        char c = text[i];
        if (c < '0' || c > '9') {
            return false;
        }
        u64 digit = (u64)(c - '0');
        u64 next = value * 10u + digit;
        if (next < value) {
            return false;
        }
        value = next;
    }
    *out_value = value;
    return true;
}

static bool ascii_to_double(const char* text, usize length, double* out_value) {
    if (!text || !out_value || length == 0u) {
        return false;
    }
    u64 integer_part = 0u;
    u64 fraction_part = 0u;
    u64 fraction_scale = 1u;
    bool seen_decimal = false;
    for (usize i = 0u; i < length; ++i) {
        char c = text[i];
        if (c == '.') {
            if (seen_decimal) {
                return false;
            }
            seen_decimal = true;
            continue;
        }
        if (c < '0' || c > '9') {
            return false;
        }
        u64 digit = (u64)(c - '0');
        if (!seen_decimal) {
            integer_part = integer_part * 10u + digit;
        } else {
            if (fraction_scale > 1000000000u) {
                continue;
            }
            fraction_part = fraction_part * 10u + digit;
            fraction_scale *= 10u;
        }
    }
    double value = (double)integer_part;
    if (seen_decimal && fraction_scale > 1u) {
        value += ((double)fraction_part) / (double)fraction_scale;
    }
    *out_value = value;
    return true;
}

static u64 gcd_u64(u64 a, u64 b);

static bool ascii_to_fraction(const char* text,
                              usize length,
                              u64& numerator,
                              u64& denominator) {
    numerator = 0u;
    denominator = 1u;
    if (!text || length == 0u) {
        return false;
    }
    bool seen_digit = false;
    bool seen_decimal = false;
    u64 integer_part = 0u;
    u64 fraction_part = 0u;
    u64 fraction_scale = 1u;
    for (usize i = 0u; i < length; ++i) {
        char c = text[i];
        if (c == '.') {
            if (seen_decimal) {
                return false;
            }
            seen_decimal = true;
            continue;
        }
        if (c < '0' || c > '9') {
            return false;
        }
        seen_digit = true;
        u64 digit = (u64)(c - '0');
        if (!seen_decimal) {
            if (integer_part > (0xFFFFFFFFFFFFFFFFull - digit) / 10u) {
                return false;
            }
            integer_part = integer_part * 10u + digit;
        } else {
            if (fraction_scale <= 1000000000u) {
                fraction_part = fraction_part * 10u + digit;
                fraction_scale *= 10u;
            }
        }
    }
    if (!seen_digit) {
        return false;
    }
    if (!seen_decimal) {
        numerator = integer_part;
        denominator = 1u;
        return true;
    }
    if (fraction_scale == 0u) {
        return false;
    }
    if (integer_part != 0u) {
        if (integer_part > (0xFFFFFFFFFFFFFFFFull - fraction_part) / fraction_scale) {
            return false;
        }
    }
    u64 scaled_integer = integer_part * fraction_scale;
    u64 combined = scaled_integer + fraction_part;
    u64 divisor = gcd_u64(combined, fraction_scale);
    if (divisor == 0u) {
        numerator = combined;
        denominator = fraction_scale;
    } else {
        numerator = combined / divisor;
        denominator = fraction_scale / divisor;
    }
    if (denominator == 0u) {
        return false;
    }
    return true;
}

static void console_write(int fd, const char* text) {
    if (!text) {
        return;
    }
    usize len = ascii_length(text);
    if (len) {
        write(fd, text, len);
    }
}

static void console_line(int fd, const char* text) {
    console_write(fd, text);
    write(fd, "\n", 1u);
}

static bool g_debug_enabled = false;

static bool argument_is_debug_flag(const char* arg) {
    if (!arg) {
        return false;
    }
    usize length = ascii_length(arg);
    return ascii_equals_token(arg, length, "--debug");
}

static bool consume_debug_flag(const char* arg) {
    if (argument_is_debug_flag(arg)) {
        g_debug_enabled = true;
        return true;
    }
    return false;
}

static bool debug_logging_enabled() {
    return g_debug_enabled;
}

static double clamp_double(double value, double lo, double hi) {
    if (value < lo) return lo;
    if (value > hi) return hi;
    return value;
}

static void u64_to_ascii(u64 value, char* buffer, usize capacity) {
    if (!buffer || capacity == 0) {
        return;
    }
    char temp[32];
    usize index = 0;
    if (value == 0) {
        temp[index++] = '0';
    } else {
        while (value && index < (usize)sizeof(temp)) {
            u64 digit = value % 10u;
            temp[index++] = (char)('0' + digit);
            value /= 10u;
        }
    }
    usize count = (index < (capacity - 1u)) ? index : (capacity - 1u);
    for (usize i = 0; i < count; ++i) {
        buffer[i] = temp[count - 1u - i];
    }
    buffer[count] = '\0';
}

static void u32_to_hex(u32 value, char* buffer, usize capacity) {
    if (!buffer || capacity < 3u) {
        return;
    }
    static const char* kHex = "0123456789abcdef";
    char temp[8];
    for (u32 i = 0u; i < 8u; ++i) {
        u32 shift = (7u - i) * 4u;
        temp[i] = kHex[(value >> shift) & 0xFu];
    }
    // Trim leading zeros but keep at least one digit.
    u32 start = 0u;
    while (start + 1u < 8u && temp[start] == '0') {
        ++start;
    }
    u32 out_len = 8u - start;
    if (out_len + 1u > capacity) {
        out_len = (u32)capacity - 1u;
    }
    for (u32 i = 0u; i < out_len; ++i) {
        buffer[i] = temp[start + i];
    }
    buffer[out_len] = '\0';
}

static void format_fixed_3(double value, char* buffer, usize capacity) {
    if (!buffer || capacity < 6u) {
        return;
    }
    if (value < 0.0) {
        buffer[0] = '-';
        format_fixed_3(-value, buffer + 1, capacity - 1);
        return;
    }
    u64 scaled = (u64)(value * 1000.0 + 0.5);
    u64 whole = scaled / 1000u;
    u64 frac = scaled % 1000u;
    char whole_buf[32];
    u64_to_ascii(whole, whole_buf, sizeof(whole_buf));
    usize whole_len = ascii_length(whole_buf);
    if (whole_len + 4u >= capacity) {
        whole_len = capacity > 5u ? capacity - 5u : 0u;
    }
    for (usize i = 0; i < whole_len; ++i) {
        buffer[i] = whole_buf[i];
    }
    buffer[whole_len] = '.';
    buffer[whole_len + 1u] = (char)('0' + (frac / 100u) % 10u);
    buffer[whole_len + 2u] = (char)('0' + (frac / 10u) % 10u);
    buffer[whole_len + 3u] = (char)('0' + frac % 10u);
    buffer[whole_len + 4u] = '\0';
}

static bool utc_timestamp_string(char* buffer, usize capacity) {
    if (!buffer || capacity == 0u) {
        return false;
    }
    long seconds = time((long*)0);
    if (seconds < 0L) {
        return false;
    }
    struct tm* utc = gmtime(&seconds);
    if (!utc) {
        return false;
    }
    static const char format[] = "%Y%m%dT%H%M%SZ";
    unsigned long written = strftime(buffer, (unsigned long)capacity, format, utc);
    if (!written || written >= capacity) {
        return false;
    }
    buffer[written] = '\0';
    return true;
}

// Footer stripes were removed from the format; keep a single switch to hard-disable
// any legacy probing while the code remains compiled for now.
static constexpr bool kFooterStripeEnabled = false;

namespace makocode {

namespace image {

enum LoadStatus {
    LoadSuccess = 0,
    LoadFileOpenFailed,
    LoadDecodeError,
    LoadUnsupportedFormat,
    LoadOutOfMemory
};

struct ImageBuffer {
    unsigned width;
    unsigned height;
    unsigned char* pixels;
};

struct Histogram {
    unsigned long long bins[256];
    unsigned char average;
};

struct CutLevels {
    unsigned char global_cut;
    unsigned char fill_cut;
};

struct LoadDiagnostics {
    char message[128];
};

static const int kMaxIterations = 32;

static void set_diag_message(LoadDiagnostics* diag, const char* text)
{
    if (!diag) return;
    if (!text) {
        diag->message[0] = '\0';
        return;
    }
    usize length = ::ascii_length(text);
    if (length >= (usize)sizeof(diag->message)) {
        length = (usize)sizeof(diag->message) - 1u;
    }
    for (usize i = 0; i < length; ++i) {
        diag->message[i] = text[i];
    }
    diag->message[length] = '\0';
}

void release(ImageBuffer& image)
{
    if (image.pixels) {
        free(image.pixels);
        image.pixels = 0;
    }
    image.width = 0;
    image.height = 0;
}

static bool read_entire_file(const char* path,
                             unsigned char** out_data,
                             usize* out_size,
                             LoadDiagnostics* diag)
{
    *out_data = 0;
    *out_size = 0;

    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        set_diag_message(diag, "failed to open file");
        return false;
    }

    usize capacity = 4096u;
    unsigned char* data = (unsigned char*)malloc(capacity);
    if (!data) {
        close(fd);
        set_diag_message(diag, "allocation failed");
        return false;
    }

    usize total = 0;
    while (1) {
        if (total >= capacity) {
            usize new_capacity = capacity ? capacity << 1u : 4096u;
            if (new_capacity <= capacity) {
                new_capacity = capacity + 4096u;
            }
            unsigned char* resized = (unsigned char*)realloc(data, new_capacity);
            if (!resized) {
                free(data);
                close(fd);
                set_diag_message(diag, "allocation failed");
                return false;
            }
            data = resized;
            capacity = new_capacity;
        }
        unsigned long request = (unsigned long)(capacity - total);
        if (request > 65536ul) request = 65536ul;
        int read_result = read(fd, data + total, request);
        if (read_result < 0) {
            free(data);
            close(fd);
            set_diag_message(diag, "read failure");
            return false;
        }
        if (read_result == 0) {
            break;
        }
        total += (usize)read_result;
    }
    close(fd);

    if (!total) {
        free(data);
        set_diag_message(diag, "empty file");
        return false;
    }

    *out_data = data;
    *out_size = total;
    return true;
}

LoadStatus load_ppm_grayscale(const char* path,
                              ImageBuffer& out,
                              LoadDiagnostics* diag)
{
    release(out);
    if (!path) {
        set_diag_message(diag, "null path");
        return LoadDecodeError;
    }

    unsigned char* data = 0;
    usize size = 0;
    if (!read_entire_file(path, &data, &size, diag)) {
        return LoadDecodeError;
    }

    const unsigned char* cursor = data;
    const unsigned char* end = data + size;

    if (cursor >= end) {
        free(data);
        set_diag_message(diag, "truncated header");
        return LoadDecodeError;
    }

    if (*cursor != 'P') {
        free(data);
        set_diag_message(diag, "not a PPM/PGM file");
        return LoadUnsupportedFormat;
    }
    cursor++;
    if (cursor >= end) {
        free(data);
        set_diag_message(diag, "truncated header");
        return LoadDecodeError;
    }
    unsigned char format = *cursor++;
    bool is_p6 = (format == '6');
    bool is_p5 = (format == '5');
    if (!(is_p6 || is_p5)) {
        free(data);
        set_diag_message(diag, "unsupported PPM format");
        return LoadUnsupportedFormat;
    }

    auto skip_whitespace_and_comments =
        [&](const unsigned char*& ptr)->bool {
            while (ptr < end) {
                unsigned char ch = *ptr;
                if (ch == '#') {
                    while (ptr < end && *ptr != '\n') ptr++;
                    continue;
                }
                if (ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n') {
                    ptr++;
                    continue;
                }
                break;
            }
            return ptr < end;
        };

    if (!skip_whitespace_and_comments(cursor)) {
        free(data);
        set_diag_message(diag, "failed to parse width");
        return LoadDecodeError;
    }

    auto parse_positive_int =
        [&](unsigned* out_value)->bool {
            unsigned value = 0;
            bool any = false;
            while (cursor < end) {
                unsigned char ch = *cursor;
                if (ch < '0' || ch > '9') break;
                any = true;
                value = value * 10u + (ch - '0');
                cursor++;
            }
            if (!any) return false;
            *out_value = value;
            return true;
        };

    unsigned width = 0;
    if (!parse_positive_int(&width) || width == 0) {
        free(data);
        set_diag_message(diag, "invalid width");
        return LoadDecodeError;
    }
    if (!skip_whitespace_and_comments(cursor)) {
        free(data);
        set_diag_message(diag, "failed to parse height");
        return LoadDecodeError;
    }
    unsigned height = 0;
    if (!parse_positive_int(&height) || height == 0) {
        free(data);
        set_diag_message(diag, "invalid height");
        return LoadDecodeError;
    }
    if (!skip_whitespace_and_comments(cursor)) {
        free(data);
        set_diag_message(diag, "failed to parse maxval");
        return LoadDecodeError;
    }
    unsigned maxval = 0;
    if (!parse_positive_int(&maxval)) {
        free(data);
        set_diag_message(diag, "invalid maxval");
        return LoadDecodeError;
    }
    if (maxval != 255u) {
        free(data);
        set_diag_message(diag, "maxval must be 255");
        return LoadUnsupportedFormat;
    }
    if (!skip_whitespace_and_comments(cursor)) {
        free(data);
        set_diag_message(diag, "missing raster data");
        return LoadDecodeError;
    }

    usize remaining = (usize)(end - cursor);
    usize expected_bytes = (usize)width * (usize)height * (is_p6 ? 3u : 1u);
    if (remaining < expected_bytes) {
        free(data);
        set_diag_message(diag, "truncated raster data");
        return LoadDecodeError;
    }

    unsigned char* pixels = (unsigned char*)malloc((usize)width * (usize)height);
    if (!pixels) {
        free(data);
        set_diag_message(diag, "allocation failed");
        return LoadOutOfMemory;
    }

    if (is_p5) {
        for (usize i = 0; i < (usize)width * (usize)height; ++i) {
            pixels[i] = cursor[i];
        }
    } else {
        const unsigned char* src = cursor;
        for (usize i = 0; i < (usize)width * (usize)height; ++i) {
            unsigned char r = src[0];
            unsigned char g = src[1];
            unsigned char b = src[2];
            pixels[i] = (unsigned char)((r + g + b) / 3u);
            src += 3;
        }
    }

    free(data);

    out.width = width;
    out.height = height;
    out.pixels = pixels;
    return LoadSuccess;
}

void compute_histogram(const ImageBuffer& image, Histogram& histogram)
{
    for (int i = 0; i < 256; ++i) {
        histogram.bins[i] = 0;
    }
    histogram.average = 0;

    if (!image.pixels) {
        return;
    }

    unsigned long long total = 0;
    usize total_pixels = (usize)image.width * (usize)image.height;
    if (!total_pixels) {
        return;
    }
    for (usize i = 0; i < total_pixels; ++i) {
        unsigned char value = image.pixels[i];
        histogram.bins[value]++;
        total += value;
    }
    unsigned long long rounded = total + (total_pixels >> 1u);
    histogram.average = (unsigned char)(rounded / total_pixels);
}

bool analyze_cut_levels(const Histogram& histogram,
                        double sync_white_cut,
                        CutLevels& out_levels)
{
    if (sync_white_cut < 0.0 || sync_white_cut > 1.0) {
        return false;
    }

    unsigned char global_cut = histogram.average;
    unsigned char fill_cut = histogram.average;

    for (int iter = 0; iter < kMaxIterations; ++iter) {
        unsigned char last_cut = global_cut;
        unsigned long long black_pixels = 0;
        unsigned long long white_pixels = 0;
        double black_rms = 0.0;
        double white_rms = 0.0;

        for (int i = 0; i < (int)global_cut; ++i) {
            unsigned long long count = histogram.bins[i];
            if (!count) {
                continue;
            }
            double diff = (double)((int)global_cut - i);
            black_rms += diff * diff * (double)count;
            black_pixels += count;
        }

        for (int i = (int)global_cut + 1; i < 256; ++i) {
            unsigned long long count = histogram.bins[i];
            if (!count) {
                continue;
            }
            double diff = (double)(i - (int)global_cut);
            white_rms += diff * diff * (double)count;
            white_pixels += count;
        }

        if (black_pixels == 0 || white_pixels == 0) {
            break;
        }

        black_rms = sqrt(black_rms / (double)black_pixels);
        white_rms = sqrt(white_rms / (double)white_pixels);

        double black = (double)global_cut - black_rms;
        double white = (double)global_cut + white_rms;

        double weighted_cut = white * sync_white_cut +
                              black * (1.0 - sync_white_cut);
        double fill = 0.5 * white + 0.5 * black;

        double rounded_global = floor(weighted_cut + 0.5);
        double rounded_fill = floor(fill + 0.5);
        if (rounded_global < 0.0) rounded_global = 0.0;
        if (rounded_global > 255.0) rounded_global = 255.0;
        if (rounded_fill < 0.0) rounded_fill = 0.0;
        if (rounded_fill > 255.0) rounded_fill = 255.0;

        global_cut = (unsigned char)rounded_global;
        fill_cut = (unsigned char)rounded_fill;

        if (global_cut == last_cut) {
            break;
        }
    }

    out_levels.global_cut = global_cut;
    out_levels.fill_cut = fill_cut;
    return true;
}

struct CornerDetectionConfig {
    u32 logical_width;
    u32 logical_height;
    u32 cross_half;
    double cross_trim;

    CornerDetectionConfig()
        : logical_width(0u),
          logical_height(0u),
          cross_half(3u),
          cross_trim(0.75) {}
};

struct CornerDetectionResult {
    bool valid;
    double corners[4][2];
    double hpixel;
    double vpixel;
    double pixelhx;
    double pixelhy;
    double pixelvx;
    double pixelvy;
    int chalf;
    int chalf_fine;
    double skew_degrees;
    double perpendicularity_degrees;
    unsigned left_edge;
    unsigned right_edge;
    unsigned top_edge;
    unsigned bottom_edge;

    CornerDetectionResult()
        : valid(false),
          hpixel(0.0),
          vpixel(0.0),
          pixelhx(0.0),
          pixelhy(0.0),
          pixelvx(0.0),
          pixelvy(0.0),
          chalf(0),
          chalf_fine(0),
          skew_degrees(0.0),
          perpendicularity_degrees(0.0),
          left_edge(0u),
          right_edge(0u),
          top_edge(0u),
          bottom_edge(0u) {
        for (int i = 0; i < 4; ++i) {
            corners[i][0] = 0.0;
            corners[i][1] = 0.0;
        }
    }
};

static unsigned char sample_pixel(const ImageBuffer& image, int x, int y)
{
    if (!image.pixels) {
        return 0xFFu;
    }
    if (x < 0 || y < 0) {
        return 0xFFu;
    }
    if ((unsigned)x >= image.width || (unsigned)y >= image.height) {
        return 0xFFu;
    }
    return image.pixels[(unsigned)y * image.width + (unsigned)x];
}

static void scan_diagonal(const ImageBuffer& image,
                          int start_x,
                          int start_y,
                          int outer_dx,
                          int step_y,
                          unsigned char cutlevel,
                          int& out_x,
                          int& out_y)
{
    unsigned limit = image.width < image.height ? image.width : image.height;
    int step_x = -outer_dx;
    for (unsigned diag = 0u; diag < limit; ++diag) {
        int x = start_x + outer_dx * (int)diag;
        int y = start_y;
        unsigned len = diag + 1u;
        for (unsigned step = 0u; step < len; ++step) {
            unsigned char value = sample_pixel(image, x, y);
            if (value < cutlevel) {
                out_x = x;
                out_y = y;
                return;
            }
            x += step_x;
            y += step_y;
        }
    }
    out_x = -1;
    out_y = -1;
}

static void normalize_vector(double& x, double& y)
{
    double length = sqrt(x * x + y * y);
    if (length <= 0.0) {
        x = 0.0;
        y = 0.0;
        return;
    }
    x /= length;
    y /= length;
}

static double angle(double x, double y)
{
    static const double kRadToDeg = 180.0 / 3.14159265358979323846;
    double radians = atan2(y, x);
    double degrees = radians * kRadToDeg;
    if (degrees < 0.0) {
        degrees += 360.0;
    }
    return degrees;
}

static double normalize_angle(double value)
{
    while (value <= -180.0) {
        value += 360.0;
    }
    while (value > 180.0) {
        value -= 360.0;
    }
    return value;
}

bool find_corners(const ImageBuffer& image,
                  unsigned char global_cut,
                  const CornerDetectionConfig& config,
                  CornerDetectionResult& result)
{
    result = CornerDetectionResult();
    if (!image.pixels || !image.width || !image.height) {
        return false;
    }
    if (config.logical_width == 0u || config.logical_height == 0u) {
        return false;
    }
    if (config.cross_half == 0u) {
        return false;
    }

    int x = 0;
    int y = 0;

    scan_diagonal(image, 0, 0, +1, +1, global_cut, x, y);
    if (x < 0) {
        return false;
    }
    result.corners[0][0] = (double)x;
    result.corners[0][1] = (double)y;

    scan_diagonal(image, (int)image.width - 1, 0, -1, +1, global_cut, x, y);
    if (x < 0) {
        return false;
    }
    result.corners[1][0] = (double)(x + 1);
    result.corners[1][1] = (double)y;

    scan_diagonal(image, 0, (int)image.height - 1, +1, -1, global_cut, x, y);
    if (x < 0) {
        return false;
    }
    result.corners[2][0] = (double)x;
    result.corners[2][1] = (double)(y + 1);

    scan_diagonal(image, (int)image.width - 1, (int)image.height - 1, -1, -1, global_cut, x, y);
    if (x < 0) {
        return false;
    }
    result.corners[3][0] = (double)(x + 1);
    result.corners[3][1] = (double)(y + 1);

    double left = result.corners[0][0] < result.corners[2][0] ? result.corners[0][0] : result.corners[2][0];
    double right = result.corners[1][0] > result.corners[3][0] ? result.corners[1][0] : result.corners[3][0];
    double top = result.corners[0][1] < result.corners[1][1] ? result.corners[0][1] : result.corners[1][1];
    double bottom = result.corners[2][1] > result.corners[3][1] ? result.corners[2][1] : result.corners[3][1];
    if (left < 0.0) left = 0.0;
    if (top < 0.0) top = 0.0;
    if (bottom < 0.0) bottom = 0.0;
    result.left_edge = (unsigned)left;
    result.right_edge = (unsigned)right;
    result.top_edge = (unsigned)top;
    result.bottom_edge = (unsigned)bottom;

    double hpixel = ((result.corners[1][0] + result.corners[3][0]) -
                     (result.corners[0][0] + result.corners[0][0])) * 0.5;
    hpixel /= (double)config.logical_width;
    double vpixel = ((result.corners[2][1] + result.corners[3][1]) -
                     (result.corners[0][1] + result.corners[1][1])) * 0.5;
    vpixel /= (double)config.logical_height;
    result.hpixel = hpixel;
    result.vpixel = vpixel;

    result.pixelhx = ((result.corners[1][0] + result.corners[3][0]) -
                      (result.corners[0][0] + result.corners[2][0])) * 0.5;
    result.pixelhy = ((result.corners[1][1] + result.corners[3][1]) -
                      (result.corners[0][1] + result.corners[2][1])) * 0.5;
    result.pixelvx = ((result.corners[2][0] + result.corners[3][0]) -
                      (result.corners[0][0] + result.corners[1][0])) * 0.5;
    result.pixelvy = ((result.corners[2][1] + result.corners[3][1]) -
                      (result.corners[0][1] + result.corners[1][1])) * 0.5;

    normalize_vector(result.pixelhx, result.pixelhy);
    normalize_vector(result.pixelvx, result.pixelvy);

    double horiz_angle = angle(result.pixelhx, -result.pixelhy);
    double vert_angle = angle(result.pixelvx, -result.pixelvy);
    result.skew_degrees = normalize_angle(horiz_angle + vert_angle + 90.0) * 0.5;
    result.perpendicularity_degrees = horiz_angle - vert_angle;

    double half_scale = (double)config.cross_half * 0.5;
    unsigned h_half = (unsigned)(hpixel * half_scale);
    unsigned v_half = (unsigned)(vpixel * half_scale);
    result.chalf = (int)(h_half < v_half ? h_half : v_half);

    double trim = config.cross_trim;
    if (trim < 0.0) {
        trim = 0.0;
    }
    double core = (double)config.cross_half - trim;
    if (core < 0.0) {
        core = 0.0;
    }
    unsigned h_fine = (unsigned)(hpixel * core);
    unsigned v_fine = (unsigned)(vpixel * core);
    result.chalf_fine = (int)(h_fine < v_fine ? h_fine : v_fine);

    result.valid = true;
    return true;
}

} /* namespace image */

struct ByteBuffer {
    u8*   data;
    usize size;
    usize capacity;

    ByteBuffer() : data(0), size(0), capacity(0) {}

    ~ByteBuffer() {
        release();
    }

    void release() {
        if (data) {
            free(data);
            data = 0;
        }
        size = 0;
        capacity = 0;
    }

    bool reserve(usize new_capacity) {
        if (new_capacity <= capacity) {
            return true;
        }
        if (new_capacity > (USIZE_MAX_VALUE / 2u)) {
            return false;
        }
        u8* new_data = (u8*)malloc(new_capacity);
        if (!new_data) {
            return false;
        }
        for (usize i = 0; i < size; ++i) {
            new_data[i] = data[i];
        }
        free(data);
        data = new_data;
        capacity = new_capacity;
        return true;
    }

    bool ensure(usize required) {
        if (required <= capacity) {
            return true;
        }
        usize grow = capacity ? capacity : (usize)64;
        while (grow < required) {
            usize doubled = grow + grow;
            if (doubled <= grow) {
                grow = required;
                break;
            }
            grow = doubled;
        }
        return reserve(grow);
    }

    bool push(u8 value) {
        if (!ensure(size + 1u)) {
            return false;
        }
        data[size++] = value;
        return true;
    }

    bool append_bytes(const u8* source, usize length) {
        if (!source || length == 0u) {
            return true;
        }
        if (!ensure(size + length)) {
            return false;
        }
        for (usize i = 0; i < length; ++i) {
            data[size + i] = source[i];
        }
        size += length;
        return true;
    }

    bool append_ascii(const char* text) {
        if (!text) {
            return true;
        }
        return append_bytes((const u8*)text, ascii_length(text));
    }

    bool append_char(char c) {
        return append_bytes((const u8*)&c, 1u);
    }
};

/* ===== Begin Embedded LZMA SDK (Public Domain, Igor Pavlov) ===== */

// --- Types.h ---
/* Types.h -- Basic types
2008-11-23 : Igor Pavlov : Public domain */

#ifndef __7Z_TYPES_H
#define __7Z_TYPES_H


#ifdef _WIN32
#include <windows.h>
#endif

#define SZ_OK 0

#define SZ_ERROR_DATA 1
#define SZ_ERROR_MEM 2
#define SZ_ERROR_CRC 3
#define SZ_ERROR_UNSUPPORTED 4
#define SZ_ERROR_PARAM 5
#define SZ_ERROR_INPUT_EOF 6
#define SZ_ERROR_OUTPUT_EOF 7
#define SZ_ERROR_READ 8
#define SZ_ERROR_WRITE 9
#define SZ_ERROR_PROGRESS 10
#define SZ_ERROR_FAIL 11
#define SZ_ERROR_THREAD 12

#define SZ_ERROR_ARCHIVE 16
#define SZ_ERROR_NO_ARCHIVE 17

typedef int SRes;

#ifdef _WIN32
typedef DWORD WRes;
#else
typedef int WRes;
#endif

#ifndef RINOK
#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
#endif

typedef unsigned char Byte;
typedef short Int16;
typedef unsigned short UInt16;

#ifdef _LZMA_UINT32_IS_ULONG
typedef long Int32;
typedef unsigned long UInt32;
#else
typedef int Int32;
typedef unsigned int UInt32;
#endif

#ifdef _SZ_NO_INT_64

/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
   NOTES: Some code will work incorrectly in that case! */

typedef long Int64;
typedef unsigned long UInt64;

#else

#if defined(_MSC_VER) || defined(__BORLANDC__)
typedef __int64 Int64;
typedef unsigned __int64 UInt64;
#else
typedef long long int Int64;
typedef unsigned long long int UInt64;
#endif

#endif

#ifdef _LZMA_NO_SYSTEM_SIZE_T
typedef UInt32 SizeT;
#else
typedef size_t SizeT;
#endif

typedef int Bool;
#define True 1
#define False 0


#ifdef _MSC_VER

#if _MSC_VER >= 1300
#define MY_NO_INLINE __declspec(noinline)
#else
#define MY_NO_INLINE
#endif

#define MY_CDECL __cdecl
#define MY_STD_CALL __stdcall
#define MY_FAST_CALL MY_NO_INLINE __fastcall

#else

#define MY_CDECL
#define MY_STD_CALL
#define MY_FAST_CALL

#endif


/* The following interfaces use first parameter as pointer to structure */

typedef struct
{
  SRes (*Read)(void *p, void *buf, size_t *size);
    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) < input(*size)) is allowed */
} ISeqInStream;

/* it can return SZ_ERROR_INPUT_EOF */
SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);

typedef struct
{
  size_t (*Write)(void *p, const void *buf, size_t size);
    /* Returns: result - the number of actually written bytes.
       (result < size) means error */
} ISeqOutStream;

typedef enum
{
  SZ_SEEK_SET = 0,
  SZ_SEEK_CUR = 1,
  SZ_SEEK_END = 2
} ESzSeek;

typedef struct
{
  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
} ISeekInStream;

typedef struct
{
  SRes (*Look)(void *p, void **buf, size_t *size);
    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) > input(*size)) is not allowed
       (output(*size) < input(*size)) is allowed */
  SRes (*Skip)(void *p, size_t offset);
    /* offset must be <= output(*size) of Look */

  SRes (*Read)(void *p, void *buf, size_t *size);
    /* reads directly (without buffer). It's same as ISeqInStream::Read */
  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
} ILookInStream;

SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);

/* reads via ILookInStream::Read */
SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);

#define LookToRead_BUF_SIZE (1 << 14)

typedef struct
{
  ILookInStream s;
  ISeekInStream *realStream;
  size_t pos;
  size_t size;
  Byte buf[LookToRead_BUF_SIZE];
} CLookToRead;

void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
void LookToRead_Init(CLookToRead *p);

typedef struct
{
  ISeqInStream s;
  ILookInStream *realStream;
} CSecToLook;

void SecToLook_CreateVTable(CSecToLook *p);

typedef struct
{
  ISeqInStream s;
  ILookInStream *realStream;
} CSecToRead;

void SecToRead_CreateVTable(CSecToRead *p);

typedef struct
{
  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
    /* Returns: result. (result != SZ_OK) means break.
       Value (UInt64)(Int64)-1 for size means unknown value. */
} ICompressProgress;

typedef struct
{
  void *(*Alloc)(void *p, size_t size);
  void (*Free)(void *p, void *address); /* address can be 0 */
} ISzAlloc;

#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
#define IAlloc_Free(p, a) (p)->Free((p), a)

#endif
// --- End Types.h ---

// --- CpuArch.h ---
/* CpuArch.h
2008-08-05
Igor Pavlov
Public domain */

#ifndef __CPUARCH_H
#define __CPUARCH_H

/*
LITTLE_ENDIAN_UNALIGN means:
  1) CPU is LITTLE_ENDIAN
  2) it's allowed to make unaligned memory accesses
if LITTLE_ENDIAN_UNALIGN is not defined, it means that we don't know
about these properties of platform.
*/

#if defined(_M_IX86) || defined(_M_X64) || defined(_M_AMD64) || defined(__i386__) || defined(__x86_64__)
#define LITTLE_ENDIAN_UNALIGN
#endif

#ifdef LITTLE_ENDIAN_UNALIGN

#define GetUi16(p) (*(const UInt16 *)(p))
#define GetUi32(p) (*(const UInt32 *)(p))
#define GetUi64(p) (*(const UInt64 *)(p))
#define SetUi32(p, d) *(UInt32 *)(p) = (d);

#else

#define GetUi16(p) (((const Byte *)(p))[0] | ((UInt16)((const Byte *)(p))[1] << 8))

#define GetUi32(p) ( \
             ((const Byte *)(p))[0]        | \
    ((UInt32)((const Byte *)(p))[1] <<  8) | \
    ((UInt32)((const Byte *)(p))[2] << 16) | \
    ((UInt32)((const Byte *)(p))[3] << 24))

#define GetUi64(p) (GetUi32(p) | ((UInt64)GetUi32(((const Byte *)(p)) + 4) << 32))

#define SetUi32(p, d) { UInt32 _x_ = (d); \
    ((Byte *)(p))[0] = (Byte)_x_; \
    ((Byte *)(p))[1] = (Byte)(_x_ >> 8); \
    ((Byte *)(p))[2] = (Byte)(_x_ >> 16); \
    ((Byte *)(p))[3] = (Byte)(_x_ >> 24); }

#endif

#if defined(LITTLE_ENDIAN_UNALIGN) && defined(_WIN64) && (_MSC_VER >= 1300)

#pragma intrinsic(_byteswap_ulong)
#pragma intrinsic(_byteswap_uint64)
#define GetBe32(p) _byteswap_ulong(*(const UInt32 *)(const Byte *)(p))
#define GetBe64(p) _byteswap_uint64(*(const UInt64 *)(const Byte *)(p))

#else

#define GetBe32(p) ( \
    ((UInt32)((const Byte *)(p))[0] << 24) | \
    ((UInt32)((const Byte *)(p))[1] << 16) | \
    ((UInt32)((const Byte *)(p))[2] <<  8) | \
             ((const Byte *)(p))[3] )

#define GetBe64(p) (((UInt64)GetBe32(p) << 32) | GetBe32(((const Byte *)(p)) + 4))

#endif

#define GetBe16(p) (((UInt16)((const Byte *)(p))[0] << 8) | ((const Byte *)(p))[1])

#endif
// --- End CpuArch.h ---

// --- Alloc.h ---
/* Alloc.h -- Memory allocation functions
2008-03-13
Igor Pavlov
Public domain */

#ifndef __COMMON_ALLOC_H
#define __COMMON_ALLOC_H


void *MyAlloc(size_t size);
void MyFree(void *address);

#ifdef _WIN32

void SetLargePageSize();

void *MidAlloc(size_t size);
void MidFree(void *address);
void *BigAlloc(size_t size);
void BigFree(void *address);

#else

#define MidAlloc(size) MyAlloc(size)
#define MidFree(address) MyFree(address)
#define BigAlloc(size) MyAlloc(size)
#define BigFree(address) MyFree(address)

#endif

#endif
// --- End Alloc.h ---

// --- LzHash.h ---
/* LzHash.h -- HASH functions for LZ algorithms
2008-10-04 : Igor Pavlov : Public domain */

#ifndef __LZHASH_H
#define __LZHASH_H

#define kHash2Size (1 << 10)
#define kHash3Size (1 << 16)
#define kHash4Size (1 << 20)

#define kFix3HashSize (kHash2Size)
#define kFix4HashSize (kHash2Size + kHash3Size)
#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)

#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] << 8);

#define HASH3_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }

#define HASH4_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }

#define HASH5_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
  hash4Value &= (kHash4Size - 1); }

/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;


#define MT_HASH2_CALC \
  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);

#define MT_HASH3_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }

#define MT_HASH4_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }

#endif
// --- End LzHash.h ---

// --- LzmaDec.h ---
/* LzmaDec.h -- LZMA Decoder
2008-10-04 : Igor Pavlov : Public domain */

#ifndef __LZMADEC_H
#define __LZMADEC_H


/* #define _LZMA_PROB32 */
/* _LZMA_PROB32 can increase the speed on some CPUs,
   but memory usage for CLzmaDec::probs will be doubled in that case */

#ifdef _LZMA_PROB32
#define CLzmaProb UInt32
#else
#define CLzmaProb UInt16
#endif


/* ---------- LZMA Properties ---------- */

#ifndef LZMA_PROPS_SIZE
#ifndef LZMA_PROPS_SIZE
#define LZMA_PROPS_SIZE 5
#endif
#endif

typedef struct _CLzmaProps
{
  unsigned lc, lp, pb;
  UInt32 dicSize;
} CLzmaProps;

/* LzmaProps_Decode - decodes properties
Returns:
  SZ_OK
  SZ_ERROR_UNSUPPORTED - Unsupported properties
*/

SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);


/* ---------- LZMA Decoder state ---------- */

/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */

#define LZMA_REQUIRED_INPUT_MAX 20

typedef struct
{
  CLzmaProps prop;
  CLzmaProb *probs;
  Byte *dic;
  const Byte *buf;
  UInt32 range, code;
  SizeT dicPos;
  SizeT dicBufSize;
  UInt32 processedPos;
  UInt32 checkDicSize;
  unsigned state;
  UInt32 reps[4];
  unsigned remainLen;
  int needFlush;
  int needInitState;
  UInt32 numProbs;
  unsigned tempBufSize;
  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
} CLzmaDec;

#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }

void LzmaDec_Init(CLzmaDec *p);

/* There are two types of LZMA streams:
     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */

typedef enum
{
  LZMA_FINISH_ANY,   /* finish at any point */
  LZMA_FINISH_END    /* block must be finished at the end */
} ELzmaFinishMode;

/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!

   You must use LZMA_FINISH_END, when you know that current output buffer
   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.

   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
   and output value of destLen will be less than output buffer size limit.
   You can check status result also.

   You can use multiple checks to test data integrity after full decompression:
     1) Check Result and "status" variable.
     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
        You must use correct finish mode in that case. */

typedef enum
{
  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
} ELzmaStatus;

/* ELzmaStatus is used only as output value for function call */


/* ---------- Interfaces ---------- */

/* There are 3 levels of interfaces:
     1) Dictionary Interface
     2) Buffer Interface
     3) One Call Interface
   You can select any of these interfaces, but don't mix functions from different
   groups for same object. */


/* There are two variants to allocate state for Dictionary Interface:
     1) LzmaDec_Allocate / LzmaDec_Free
     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
   You can use variant 2, if you set dictionary buffer manually.
   For Buffer Interface you must always use variant 1.

LzmaDec_Allocate* can return:
  SZ_OK
  SZ_ERROR_MEM         - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
*/
   
SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);

SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);

/* ---------- Dictionary Interface ---------- */

/* You can use it, if you want to eliminate the overhead for data copying from
   dictionary to some other external buffer.
   You must work with CLzmaDec variables directly in this interface.

   STEPS:
     LzmaDec_Constr()
     LzmaDec_Allocate()
     for (each new stream)
     {
       LzmaDec_Init()
       while (it needs more decompression)
       {
         LzmaDec_DecodeToDic()
         use data from CLzmaDec::dic and update CLzmaDec::dicPos
       }
     }
     LzmaDec_Free()
*/

/* LzmaDec_DecodeToDic
   
   The decoding to internal dictionary buffer (CLzmaDec::dic).
   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!

finishMode:
  It has meaning only if the decoding reaches output limit (dicLimit).
  LZMA_FINISH_ANY - Decode just dicLimit bytes.
  LZMA_FINISH_END - Stream must be finished after dicLimit.

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_NEEDS_MORE_INPUT
      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
  SZ_ERROR_DATA - Data error
*/

SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);


/* ---------- Buffer Interface ---------- */

/* It's zlib-like interface.
   See LzmaDec_DecodeToDic description for information about STEPS and return results,
   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
   to work with CLzmaDec variables manually.

finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - Decode just destLen bytes.
  LZMA_FINISH_END - Stream must be finished after (*destLen).
*/

SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);


/* ---------- One Call Interface ---------- */

/* LzmaDecode

finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - Decode just destLen bytes.
  LZMA_FINISH_END - Stream must be finished after (*destLen).

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
  SZ_ERROR_DATA - Data error
  SZ_ERROR_MEM  - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
*/

SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
    ELzmaStatus *status, ISzAlloc *alloc);

#endif
// --- End LzmaDec.h ---

// --- LzmaEnc.h ---
/*  LzmaEnc.h -- LZMA Encoder
2008-10-04 : Igor Pavlov : Public domain */

#ifndef __LZMAENC_H
#define __LZMAENC_H


#define LZMA_PROPS_SIZE 5

typedef struct _CLzmaEncProps
{
  int level;       /*  0 <= level <= 9 */
  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
                       default = (1 << 24) */
  int lc;          /* 0 <= lc <= 8, default = 3 */
  int lp;          /* 0 <= lp <= 4, default = 0 */
  int pb;          /* 0 <= pb <= 4, default = 2 */
  int algo;        /* 0 - fast, 1 - normal, default = 1 */
  int fb;          /* 5 <= fb <= 273, default = 32 */
  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
  int numHashBytes; /* 2, 3 or 4, default = 4 */
  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
  int numThreads;  /* 1 or 2, default = 2 */
} CLzmaEncProps;

void LzmaEncProps_Init(CLzmaEncProps *p);
void LzmaEncProps_Normalize(CLzmaEncProps *p);
UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);


/* ---------- CLzmaEncHandle Interface ---------- */

/* LzmaEnc_* functions can return the following exit codes:
Returns:
  SZ_OK           - OK
  SZ_ERROR_MEM    - Memory allocation error
  SZ_ERROR_PARAM  - Incorrect paramater in props
  SZ_ERROR_WRITE  - Write callback error.
  SZ_ERROR_PROGRESS - some break from progress callback
  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
*/

typedef void * CLzmaEncHandle;

CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);

/* ---------- One Call Interface ---------- */

/* LzmaEncode
Return code:
  SZ_OK               - OK
  SZ_ERROR_MEM        - Memory allocation error
  SZ_ERROR_PARAM      - Incorrect paramater
  SZ_ERROR_OUTPUT_EOF - output buffer overflow
  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
*/

SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);

#endif
// --- End LzmaEnc.h ---

// --- LzFind.h ---
/* LzFind.h -- Match finder for LZ algorithms
2008-10-04 : Igor Pavlov : Public domain */

#ifndef __LZFIND_H
#define __LZFIND_H


typedef UInt32 CLzRef;

typedef struct _CMatchFinder
{
  Byte *buffer;
  UInt32 pos;
  UInt32 posLimit;
  UInt32 streamPos;
  UInt32 lenLimit;

  UInt32 cyclicBufferPos;
  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */

  UInt32 matchMaxLen;
  CLzRef *hash;
  CLzRef *son;
  UInt32 hashMask;
  UInt32 cutValue;

  Byte *bufferBase;
  ISeqInStream *stream;
  int streamEndWasReached;

  UInt32 blockSize;
  UInt32 keepSizeBefore;
  UInt32 keepSizeAfter;

  UInt32 numHashBytes;
  int directInput;
  int btMode;
  /* int skipModeBits; */
  int bigHash;
  UInt32 historySize;
  UInt32 fixedHashSize;
  UInt32 hashSizeSum;
  UInt32 numSons;
  SRes result;
  UInt32 crc[256];
} CMatchFinder;

#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])

#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)

int MatchFinder_NeedMove(CMatchFinder *p);
Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
void MatchFinder_MoveBlock(CMatchFinder *p);
void MatchFinder_ReadIfRequired(CMatchFinder *p);

void MatchFinder_Construct(CMatchFinder *p);

/* Conditions:
     historySize <= 3 GB
     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
*/
int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
    ISzAlloc *alloc);
void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);

UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
    UInt32 *distances, UInt32 maxLen);

/*
Conditions:
  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
*/

typedef void (*Mf_Init_Func)(void *object);
typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
typedef void (*Mf_Skip_Func)(void *object, UInt32);

typedef struct _IMatchFinder
{
  Mf_Init_Func Init;
  Mf_GetIndexByte_Func GetIndexByte;
  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
  Mf_GetMatches_Func GetMatches;
  Mf_Skip_Func Skip;
} IMatchFinder;

void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);

void MatchFinder_Init(CMatchFinder *p);
UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);

#endif
// --- End LzFind.h ---

// --- Alloc.c ---
/* Alloc.c -- Memory allocation functions
2008-09-24
Igor Pavlov
Public domain */

#ifdef _WIN32
#include <windows.h>
#endif


/* #define _SZ_ALLOC_DEBUG */

/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
#ifdef _SZ_ALLOC_DEBUG
#include <stdio.h>
int g_allocCount = 0;
int g_allocCountMid = 0;
int g_allocCountBig = 0;
#endif

void *MyAlloc(size_t size)
{
  if (size == 0)
    return 0;
  #ifdef _SZ_ALLOC_DEBUG
  {
    void *p = malloc(size);
    fprintf(stderr, "\nAlloc %10d bytes, count = %10d,  addr = %8X", size, g_allocCount++, (unsigned)p);
    return p;
  }
  #else
  return malloc(size);
  #endif
}

void MyFree(void *address)
{
  #ifdef _SZ_ALLOC_DEBUG
  if (address != 0)
    fprintf(stderr, "\nFree; count = %10d,  addr = %8X", --g_allocCount, (unsigned)address);
  #endif
  free(address);
}

#ifdef _WIN32

void *MidAlloc(size_t size)
{
  if (size == 0)
    return 0;
  #ifdef _SZ_ALLOC_DEBUG
  fprintf(stderr, "\nAlloc_Mid %10d bytes;  count = %10d", size, g_allocCountMid++);
  #endif
  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
}

void MidFree(void *address)
{
  #ifdef _SZ_ALLOC_DEBUG
  if (address != 0)
    fprintf(stderr, "\nFree_Mid; count = %10d", --g_allocCountMid);
  #endif
  if (address == 0)
    return;
  VirtualFree(address, 0, MEM_RELEASE);
}

#ifndef MEM_LARGE_PAGES
#undef _7ZIP_LARGE_PAGES
#endif

#ifdef _7ZIP_LARGE_PAGES
SIZE_T g_LargePageSize = 0;
typedef SIZE_T (WINAPI *GetLargePageMinimumP)();
#endif

void SetLargePageSize()
{
  #ifdef _7ZIP_LARGE_PAGES
  SIZE_T size = 0;
  GetLargePageMinimumP largePageMinimum = (GetLargePageMinimumP)
        GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetLargePageMinimum");
  if (largePageMinimum == 0)
    return;
  size = largePageMinimum();
  if (size == 0 || (size & (size - 1)) != 0)
    return;
  g_LargePageSize = size;
  #endif
}


void *BigAlloc(size_t size)
{
  if (size == 0)
    return 0;
  #ifdef _SZ_ALLOC_DEBUG
  fprintf(stderr, "\nAlloc_Big %10d bytes;  count = %10d", size, g_allocCountBig++);
  #endif
  
  #ifdef _7ZIP_LARGE_PAGES
  if (g_LargePageSize != 0 && g_LargePageSize <= (1 << 30) && size >= (1 << 18))
  {
    void *res = VirtualAlloc(0, (size + g_LargePageSize - 1) & (~(g_LargePageSize - 1)),
        MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE);
    if (res != 0)
      return res;
  }
  #endif
  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
}

void BigFree(void *address)
{
  #ifdef _SZ_ALLOC_DEBUG
  if (address != 0)
    fprintf(stderr, "\nFree_Big; count = %10d", --g_allocCountBig);
  #endif
  
  if (address == 0)
    return;
  VirtualFree(address, 0, MEM_RELEASE);
}

#endif
// --- End Alloc.c ---

// --- LzFind.c ---
/* LzFind.c -- Match finder for LZ algorithms
2008-10-04 : Igor Pavlov : Public domain */



#define kEmptyHashValue 0
#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */
#define kNormalizeMask (~(kNormalizeStepMin - 1))
#define kMaxHistorySize ((UInt32)3 << 30)

#define kStartMaxLen 3

static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
{
  if (!p->directInput)
  {
    alloc->Free(alloc, p->bufferBase);
    p->bufferBase = 0;
  }
}

/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */

static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
{
  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
  if (p->directInput)
  {
    p->blockSize = blockSize;
    return 1;
  }
  if (p->bufferBase == 0 || p->blockSize != blockSize)
  {
    LzInWindow_Free(p, alloc);
    p->blockSize = blockSize;
    p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
  }
  return (p->bufferBase != 0);
}

Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }

UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }

void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
{
  p->posLimit -= subValue;
  p->pos -= subValue;
  p->streamPos -= subValue;
}

static void MatchFinder_ReadBlock(CMatchFinder *p)
{
  if (p->streamEndWasReached || p->result != SZ_OK)
    return;
  for (;;)
  {
    Byte *dest = p->buffer + (p->streamPos - p->pos);
    size_t size = (p->bufferBase + p->blockSize - dest);
    if (size == 0)
      return;
    p->result = p->stream->Read(p->stream, dest, &size);
    if (p->result != SZ_OK)
      return;
    if (size == 0)
    {
      p->streamEndWasReached = 1;
      return;
    }
    p->streamPos += (UInt32)size;
    if (p->streamPos - p->pos > p->keepSizeAfter)
      return;
  }
}

void MatchFinder_MoveBlock(CMatchFinder *p)
{
  memmove(p->bufferBase,
    p->buffer - p->keepSizeBefore,
    (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
  p->buffer = p->bufferBase + p->keepSizeBefore;
}

int MatchFinder_NeedMove(CMatchFinder *p)
{
  /* if (p->streamEndWasReached) return 0; */
  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
}

void MatchFinder_ReadIfRequired(CMatchFinder *p)
{
  if (p->streamEndWasReached)
    return;
  if (p->keepSizeAfter >= p->streamPos - p->pos)
    MatchFinder_ReadBlock(p);
}

static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
{
  if (MatchFinder_NeedMove(p))
    MatchFinder_MoveBlock(p);
  MatchFinder_ReadBlock(p);
}

static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
{
  p->cutValue = 32;
  p->btMode = 1;
  p->numHashBytes = 4;
  /* p->skipModeBits = 0; */
  p->directInput = 0;
  p->bigHash = 0;
}

#define kCrcPoly 0xEDB88320

void MatchFinder_Construct(CMatchFinder *p)
{
  UInt32 i;
  p->bufferBase = 0;
  p->directInput = 0;
  p->hash = 0;
  MatchFinder_SetDefaultSettings(p);

  for (i = 0; i < 256; i++)
  {
    UInt32 r = i;
    int j;
    for (j = 0; j < 8; j++)
      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
    p->crc[i] = r;
  }
}

static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
{
  alloc->Free(alloc, p->hash);
  p->hash = 0;
}

void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
{
  MatchFinder_FreeThisClassMemory(p, alloc);
  LzInWindow_Free(p, alloc);
}

static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
{
  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
  if (sizeInBytes / sizeof(CLzRef) != num)
    return 0;
  return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
}

int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
    ISzAlloc *alloc)
{
  UInt32 sizeReserv;
  if (historySize > kMaxHistorySize)
  {
    MatchFinder_Free(p, alloc);
    return 0;
  }
  sizeReserv = historySize >> 1;
  if (historySize > ((UInt32)2 << 30))
    sizeReserv = historySize >> 2;
  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);

  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
  if (LzInWindow_Create(p, sizeReserv, alloc))
  {
    UInt32 newCyclicBufferSize = (historySize /* >> p->skipModeBits */) + 1;
    UInt32 hs;
    p->matchMaxLen = matchMaxLen;
    {
      p->fixedHashSize = 0;
      if (p->numHashBytes == 2)
        hs = (1 << 16) - 1;
      else
      {
        hs = historySize - 1;
        hs |= (hs >> 1);
        hs |= (hs >> 2);
        hs |= (hs >> 4);
        hs |= (hs >> 8);
        hs >>= 1;
        /* hs >>= p->skipModeBits; */
        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
        if (hs > (1 << 24))
        {
          if (p->numHashBytes == 3)
            hs = (1 << 24) - 1;
          else
            hs >>= 1;
        }
      }
      p->hashMask = hs;
      hs++;
      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
      hs += p->fixedHashSize;
    }

    {
      UInt32 prevSize = p->hashSizeSum + p->numSons;
      UInt32 newSize;
      p->historySize = historySize;
      p->hashSizeSum = hs;
      p->cyclicBufferSize = newCyclicBufferSize;
      p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
      newSize = p->hashSizeSum + p->numSons;
      if (p->hash != 0 && prevSize == newSize)
        return 1;
      MatchFinder_FreeThisClassMemory(p, alloc);
      p->hash = AllocRefs(newSize, alloc);
      if (p->hash != 0)
      {
        p->son = p->hash + p->hashSizeSum;
        return 1;
      }
    }
  }
  MatchFinder_Free(p, alloc);
  return 0;
}

static void MatchFinder_SetLimits(CMatchFinder *p)
{
  UInt32 limit = kMaxValForNormalize - p->pos;
  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
  if (limit2 < limit)
    limit = limit2;
  limit2 = p->streamPos - p->pos;
  if (limit2 <= p->keepSizeAfter)
  {
    if (limit2 > 0)
      limit2 = 1;
  }
  else
    limit2 -= p->keepSizeAfter;
  if (limit2 < limit)
    limit = limit2;
  {
    UInt32 lenLimit = p->streamPos - p->pos;
    if (lenLimit > p->matchMaxLen)
      lenLimit = p->matchMaxLen;
    p->lenLimit = lenLimit;
  }
  p->posLimit = p->pos + limit;
}

void MatchFinder_Init(CMatchFinder *p)
{
  UInt32 i;
  for (i = 0; i < p->hashSizeSum; i++)
    p->hash[i] = kEmptyHashValue;
  p->cyclicBufferPos = 0;
  p->buffer = p->bufferBase;
  p->pos = p->streamPos = p->cyclicBufferSize;
  p->result = SZ_OK;
  p->streamEndWasReached = 0;
  MatchFinder_ReadBlock(p);
  MatchFinder_SetLimits(p);
}

static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
{
  return (p->pos - p->historySize - 1) & kNormalizeMask;
}

void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
{
  UInt32 i;
  for (i = 0; i < numItems; i++)
  {
    UInt32 value = items[i];
    if (value <= subValue)
      value = kEmptyHashValue;
    else
      value -= subValue;
    items[i] = value;
  }
}

static void MatchFinder_Normalize(CMatchFinder *p)
{
  UInt32 subValue = MatchFinder_GetSubValue(p);
  MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
  MatchFinder_ReduceOffsets(p, subValue);
}

static void MatchFinder_CheckLimits(CMatchFinder *p)
{
  if (p->pos == kMaxValForNormalize)
    MatchFinder_Normalize(p);
  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
    MatchFinder_CheckAndMoveAndRead(p);
  if (p->cyclicBufferPos == p->cyclicBufferSize)
    p->cyclicBufferPos = 0;
  MatchFinder_SetLimits(p);
}

static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
    UInt32 *distances, UInt32 maxLen)
{
  son[_cyclicBufferPos] = curMatch;
  for (;;)
  {
    UInt32 delta = pos - curMatch;
    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
      return distances;
    {
      const Byte *pb = cur - delta;
      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
      {
        UInt32 len = 0;
        while (++len != lenLimit)
          if (pb[len] != cur[len])
            break;
        if (maxLen < len)
        {
          *distances++ = maxLen = len;
          *distances++ = delta - 1;
          if (len == lenLimit)
            return distances;
        }
      }
    }
  }
}

UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
    UInt32 *distances, UInt32 maxLen)
{
  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
  UInt32 len0 = 0, len1 = 0;
  for (;;)
  {
    UInt32 delta = pos - curMatch;
    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
    {
      *ptr0 = *ptr1 = kEmptyHashValue;
      return distances;
    }
    {
      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
      const Byte *pb = cur - delta;
      UInt32 len = (len0 < len1 ? len0 : len1);
      if (pb[len] == cur[len])
      {
        if (++len != lenLimit && pb[len] == cur[len])
          while (++len != lenLimit)
            if (pb[len] != cur[len])
              break;
        if (maxLen < len)
        {
          *distances++ = maxLen = len;
          *distances++ = delta - 1;
          if (len == lenLimit)
          {
            *ptr1 = pair[0];
            *ptr0 = pair[1];
            return distances;
          }
        }
      }
      if (pb[len] < cur[len])
      {
        *ptr1 = curMatch;
        ptr1 = pair + 1;
        curMatch = *ptr1;
        len1 = len;
      }
      else
      {
        *ptr0 = curMatch;
        ptr0 = pair;
        curMatch = *ptr0;
        len0 = len;
      }
    }
  }
}

static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
{
  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
  UInt32 len0 = 0, len1 = 0;
  for (;;)
  {
    UInt32 delta = pos - curMatch;
    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
    {
      *ptr0 = *ptr1 = kEmptyHashValue;
      return;
    }
    {
      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
      const Byte *pb = cur - delta;
      UInt32 len = (len0 < len1 ? len0 : len1);
      if (pb[len] == cur[len])
      {
        while (++len != lenLimit)
          if (pb[len] != cur[len])
            break;
        {
          if (len == lenLimit)
          {
            *ptr1 = pair[0];
            *ptr0 = pair[1];
            return;
          }
        }
      }
      if (pb[len] < cur[len])
      {
        *ptr1 = curMatch;
        ptr1 = pair + 1;
        curMatch = *ptr1;
        len1 = len;
      }
      else
      {
        *ptr0 = curMatch;
        ptr0 = pair;
        curMatch = *ptr0;
        len0 = len;
      }
    }
  }
}

#define MOVE_POS \
  ++p->cyclicBufferPos; \
  p->buffer++; \
  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);

#define MOVE_POS_RET MOVE_POS return offset;

static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }

#define GET_MATCHES_HEADER2(minLen, ret_op) \
  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
  cur = p->buffer;

#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)

#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue

#define GET_MATCHES_FOOTER(offset, maxLen) \
  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
  distances + offset, maxLen) - distances); MOVE_POS_RET;

#define SKIP_FOOTER \
  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;

static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
  UInt32 offset;
  GET_MATCHES_HEADER(2)
  HASH2_CALC;
  curMatch = p->hash[hashValue];
  p->hash[hashValue] = p->pos;
  offset = 0;
  GET_MATCHES_FOOTER(offset, 1)
}

UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
  UInt32 offset;
  GET_MATCHES_HEADER(3)
  HASH_ZIP_CALC;
  curMatch = p->hash[hashValue];
  p->hash[hashValue] = p->pos;
  offset = 0;
  GET_MATCHES_FOOTER(offset, 2)
}

static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
  UInt32 hash2Value, delta2, maxLen, offset;
  GET_MATCHES_HEADER(3)

  HASH3_CALC;

  delta2 = p->pos - p->hash[hash2Value];
  curMatch = p->hash[kFix3HashSize + hashValue];
  
  p->hash[hash2Value] =
  p->hash[kFix3HashSize + hashValue] = p->pos;


  maxLen = 2;
  offset = 0;
  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
  {
    for (; maxLen != lenLimit; maxLen++)
      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
        break;
    distances[0] = maxLen;
    distances[1] = delta2 - 1;
    offset = 2;
    if (maxLen == lenLimit)
    {
      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
      MOVE_POS_RET;
    }
  }
  GET_MATCHES_FOOTER(offset, maxLen)
}

static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
  GET_MATCHES_HEADER(4)

  HASH4_CALC;

  delta2 = p->pos - p->hash[                hash2Value];
  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
  curMatch = p->hash[kFix4HashSize + hashValue];
  
  p->hash[                hash2Value] =
  p->hash[kFix3HashSize + hash3Value] =
  p->hash[kFix4HashSize + hashValue] = p->pos;

  maxLen = 1;
  offset = 0;
  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
  {
    distances[0] = maxLen = 2;
    distances[1] = delta2 - 1;
    offset = 2;
  }
  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
  {
    maxLen = 3;
    distances[offset + 1] = delta3 - 1;
    offset += 2;
    delta2 = delta3;
  }
  if (offset != 0)
  {
    for (; maxLen != lenLimit; maxLen++)
      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
        break;
    distances[offset - 2] = maxLen;
    if (maxLen == lenLimit)
    {
      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
      MOVE_POS_RET;
    }
  }
  if (maxLen < 3)
    maxLen = 3;
  GET_MATCHES_FOOTER(offset, maxLen)
}

static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
  GET_MATCHES_HEADER(4)

  HASH4_CALC;

  delta2 = p->pos - p->hash[                hash2Value];
  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
  curMatch = p->hash[kFix4HashSize + hashValue];

  p->hash[                hash2Value] =
  p->hash[kFix3HashSize + hash3Value] =
  p->hash[kFix4HashSize + hashValue] = p->pos;

  maxLen = 1;
  offset = 0;
  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
  {
    distances[0] = maxLen = 2;
    distances[1] = delta2 - 1;
    offset = 2;
  }
  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
  {
    maxLen = 3;
    distances[offset + 1] = delta3 - 1;
    offset += 2;
    delta2 = delta3;
  }
  if (offset != 0)
  {
    for (; maxLen != lenLimit; maxLen++)
      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
        break;
    distances[offset - 2] = maxLen;
    if (maxLen == lenLimit)
    {
      p->son[p->cyclicBufferPos] = curMatch;
      MOVE_POS_RET;
    }
  }
  if (maxLen < 3)
    maxLen = 3;
  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
    distances + offset, maxLen) - (distances));
  MOVE_POS_RET
}

UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
  UInt32 offset;
  GET_MATCHES_HEADER(3)
  HASH_ZIP_CALC;
  curMatch = p->hash[hashValue];
  p->hash[hashValue] = p->pos;
  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
    distances, 2) - (distances));
  MOVE_POS_RET
}

static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
  do
  {
    SKIP_HEADER(2)
    HASH2_CALC;
    curMatch = p->hash[hashValue];
    p->hash[hashValue] = p->pos;
    SKIP_FOOTER
  }
  while (--num != 0);
}

void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
  do
  {
    SKIP_HEADER(3)
    HASH_ZIP_CALC;
    curMatch = p->hash[hashValue];
    p->hash[hashValue] = p->pos;
    SKIP_FOOTER
  }
  while (--num != 0);
}

static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
  do
  {
    UInt32 hash2Value;
    SKIP_HEADER(3)
    HASH3_CALC;
    curMatch = p->hash[kFix3HashSize + hashValue];
    p->hash[hash2Value] =
    p->hash[kFix3HashSize + hashValue] = p->pos;
    SKIP_FOOTER
  }
  while (--num != 0);
}

static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
  do
  {
    UInt32 hash2Value, hash3Value;
    SKIP_HEADER(4)
    HASH4_CALC;
    curMatch = p->hash[kFix4HashSize + hashValue];
    p->hash[                hash2Value] =
    p->hash[kFix3HashSize + hash3Value] = p->pos;
    p->hash[kFix4HashSize + hashValue] = p->pos;
    SKIP_FOOTER
  }
  while (--num != 0);
}

static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
  do
  {
    UInt32 hash2Value, hash3Value;
    SKIP_HEADER(4)
    HASH4_CALC;
    curMatch = p->hash[kFix4HashSize + hashValue];
    p->hash[                hash2Value] =
    p->hash[kFix3HashSize + hash3Value] =
    p->hash[kFix4HashSize + hashValue] = p->pos;
    p->son[p->cyclicBufferPos] = curMatch;
    MOVE_POS
  }
  while (--num != 0);
}

void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
  do
  {
    SKIP_HEADER(3)
    HASH_ZIP_CALC;
    curMatch = p->hash[hashValue];
    p->hash[hashValue] = p->pos;
    p->son[p->cyclicBufferPos] = curMatch;
    MOVE_POS
  }
  while (--num != 0);
}

void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
{
  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
  if (!p->btMode)
  {
    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
  }
  else if (p->numHashBytes == 2)
  {
    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
  }
  else if (p->numHashBytes == 3)
  {
    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
  }
  else
  {
    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
  }
}
// --- End LzFind.c ---

// --- LzmaDec.c ---
/* LzmaDec.c -- LZMA Decoder
2008-11-06 : Igor Pavlov : Public domain */



#define kNumTopBits 24
#define kTopValue ((UInt32)1 << kNumTopBits)

#define kNumBitModelTotalBits 11
#define kBitModelTotal (1 << kNumBitModelTotalBits)
#define kNumMoveBits 5

#define RC_INIT_SIZE 5

#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }

#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
  { UPDATE_0(p); i = (i + i); A0; } else \
  { UPDATE_1(p); i = (i + i) + 1; A1; }
#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)

#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
#define TREE_DECODE(probs, limit, i) \
  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }

/* #define _LZMA_SIZE_OPT */

#ifdef _LZMA_SIZE_OPT
#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
#else
#define TREE_6_DECODE(probs, i) \
  { i = 1; \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  i -= 0x40; }
#endif

#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }

#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
#define UPDATE_0_CHECK range = bound;
#define UPDATE_1_CHECK range -= bound; code -= bound;
#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
  { UPDATE_0_CHECK; i = (i + i); A0; } else \
  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
#define TREE_DECODE_CHECK(probs, limit, i) \
  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }


#define kNumPosBitsMax 4
#define kNumPosStatesMax (1 << kNumPosBitsMax)

#define kLenNumLowBits 3
#define kLenNumLowSymbols (1 << kLenNumLowBits)
#define kLenNumMidBits 3
#define kLenNumMidSymbols (1 << kLenNumMidBits)
#define kLenNumHighBits 8
#define kLenNumHighSymbols (1 << kLenNumHighBits)

#define LenChoice 0
#define LenChoice2 (LenChoice + 1)
#define LenLow (LenChoice2 + 1)
#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
#define kNumLenProbs (LenHigh + kLenNumHighSymbols)


#define kNumStates 12
#define kNumLitStates 7

#define kStartPosModelIndex 4
#define kEndPosModelIndex 14
#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))

#define kNumPosSlotBits 6
#define kNumLenToPosStates 4

#define kNumAlignBits 4
#define kAlignTableSize (1 << kNumAlignBits)

#define kMatchMinLen 2
#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)

#define IsMatch 0
#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
#define IsRepG0 (IsRep + kNumStates)
#define IsRepG1 (IsRepG0 + kNumStates)
#define IsRepG2 (IsRepG1 + kNumStates)
#define IsRep0Long (IsRepG2 + kNumStates)
#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
#define LenCoder (Align + kAlignTableSize)
#define RepLenCoder (LenCoder + kNumLenProbs)
#define Literal (RepLenCoder + kNumLenProbs)

#define LZMA_BASE_SIZE 1846
#define LZMA_LIT_SIZE 768

#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))

#if Literal != LZMA_BASE_SIZE
StopCompilingDueBUG
#endif

static const Byte kLiteralNextStatesDec[kNumStates * 2] =
{
  0, 0, 0, 0, 1, 2, 3,  4,  5,  6,  4,  5,
  7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10
};

#define LZMA_DIC_MIN (1 << 12)

/* First LZMA-symbol is always decoded.
And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
Out:
  Result:
    SZ_OK - OK
    SZ_ERROR_DATA - Error
  p->remainLen:
    < kMatchSpecLenStart : normal remain
    = kMatchSpecLenStart : finished
    = kMatchSpecLenStart + 1 : Flush marker
    = kMatchSpecLenStart + 2 : State Init Marker
*/

static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
{
  CLzmaProb *probs = p->probs;

  unsigned state = p->state;
  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
  unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
  unsigned lc = p->prop.lc;

  Byte *dic = p->dic;
  SizeT dicBufSize = p->dicBufSize;
  SizeT dicPos = p->dicPos;
  
  UInt32 processedPos = p->processedPos;
  UInt32 checkDicSize = p->checkDicSize;
  unsigned len = 0;

  const Byte *buf = p->buf;
  UInt32 range = p->range;
  UInt32 code = p->code;

  do
  {
    CLzmaProb *prob;
    UInt32 bound;
    unsigned ttt;
    unsigned posState = processedPos & pbMask;

    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
    IF_BIT_0(prob)
    {
      unsigned symbol;
      UPDATE_0(prob);
      prob = probs + Literal;
      if (checkDicSize != 0 || processedPos != 0)
        prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));

      if (state < kNumLitStates)
      {
        symbol = 1;
        do { GET_BIT(prob + symbol, symbol) } while (symbol < 0x100);
      }
      else
      {
        unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
        unsigned offs = 0x100;
        symbol = 1;
        do
        {
          unsigned bit;
          CLzmaProb *probLit;
          matchByte <<= 1;
          bit = (matchByte & offs);
          probLit = prob + offs + bit + symbol;
          GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
        }
        while (symbol < 0x100);
      }
      dic[dicPos++] = (Byte)symbol;
      processedPos++;

      state = kLiteralNextStatesDec[state];
      /* if (state < 4) state = 0; else if (state < 10) state -= 3; else state -= 6; */
      continue;
    }
    else
    {
      UPDATE_1(prob);
      prob = probs + IsRep + state;
      IF_BIT_0(prob)
      {
        UPDATE_0(prob);
        state += kNumStates;
        prob = probs + LenCoder;
      }
      else
      {
        UPDATE_1(prob);
        if (checkDicSize == 0 && processedPos == 0)
          return SZ_ERROR_DATA;
        prob = probs + IsRepG0 + state;
        IF_BIT_0(prob)
        {
          UPDATE_0(prob);
          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
          IF_BIT_0(prob)
          {
            UPDATE_0(prob);
            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
            dicPos++;
            processedPos++;
            state = state < kNumLitStates ? 9 : 11;
            continue;
          }
          UPDATE_1(prob);
        }
        else
        {
          UInt32 distance;
          UPDATE_1(prob);
          prob = probs + IsRepG1 + state;
          IF_BIT_0(prob)
          {
            UPDATE_0(prob);
            distance = rep1;
          }
          else
          {
            UPDATE_1(prob);
            prob = probs + IsRepG2 + state;
            IF_BIT_0(prob)
            {
              UPDATE_0(prob);
              distance = rep2;
            }
            else
            {
              UPDATE_1(prob);
              distance = rep3;
              rep3 = rep2;
            }
            rep2 = rep1;
          }
          rep1 = rep0;
          rep0 = distance;
        }
        state = state < kNumLitStates ? 8 : 11;
        prob = probs + RepLenCoder;
      }
      {
        unsigned limit, offset;
        CLzmaProb *probLen = prob + LenChoice;
        IF_BIT_0(probLen)
        {
          UPDATE_0(probLen);
          probLen = prob + LenLow + (posState << kLenNumLowBits);
          offset = 0;
          limit = (1 << kLenNumLowBits);
        }
        else
        {
          UPDATE_1(probLen);
          probLen = prob + LenChoice2;
          IF_BIT_0(probLen)
          {
            UPDATE_0(probLen);
            probLen = prob + LenMid + (posState << kLenNumMidBits);
            offset = kLenNumLowSymbols;
            limit = (1 << kLenNumMidBits);
          }
          else
          {
            UPDATE_1(probLen);
            probLen = prob + LenHigh;
            offset = kLenNumLowSymbols + kLenNumMidSymbols;
            limit = (1 << kLenNumHighBits);
          }
        }
        TREE_DECODE(probLen, limit, len);
        len += offset;
      }

      if (state >= kNumStates)
      {
        UInt32 distance;
        prob = probs + PosSlot +
            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
        TREE_6_DECODE(prob, distance);
        if (distance >= kStartPosModelIndex)
        {
          unsigned posSlot = (unsigned)distance;
          int numDirectBits = (int)(((distance >> 1) - 1));
          distance = (2 | (distance & 1));
          if (posSlot < kEndPosModelIndex)
          {
            distance <<= numDirectBits;
            prob = probs + SpecPos + distance - posSlot - 1;
            {
              UInt32 mask = 1;
              unsigned i = 1;
              do
              {
                GET_BIT2(prob + i, i, ; , distance |= mask);
                mask <<= 1;
              }
              while (--numDirectBits != 0);
            }
          }
          else
          {
            numDirectBits -= kNumAlignBits;
            do
            {
              NORMALIZE
              range >>= 1;
              
              {
                UInt32 t;
                code -= range;
                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
                distance = (distance << 1) + (t + 1);
                code += range & t;
              }
              /*
              distance <<= 1;
              if (code >= range)
              {
                code -= range;
                distance |= 1;
              }
              */
            }
            while (--numDirectBits != 0);
            prob = probs + Align;
            distance <<= kNumAlignBits;
            {
              unsigned i = 1;
              GET_BIT2(prob + i, i, ; , distance |= 1);
              GET_BIT2(prob + i, i, ; , distance |= 2);
              GET_BIT2(prob + i, i, ; , distance |= 4);
              GET_BIT2(prob + i, i, ; , distance |= 8);
            }
            if (distance == (UInt32)0xFFFFFFFF)
            {
              len += kMatchSpecLenStart;
              state -= kNumStates;
              break;
            }
          }
        }
        rep3 = rep2;
        rep2 = rep1;
        rep1 = rep0;
        rep0 = distance + 1;
        if (checkDicSize == 0)
        {
          if (distance >= processedPos)
            return SZ_ERROR_DATA;
        }
        else if (distance >= checkDicSize)
          return SZ_ERROR_DATA;
        state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
        /* state = kLiteralNextStatesDec[state]; */
      }

      len += kMatchMinLen;

      if (limit == dicPos)
        return SZ_ERROR_DATA;
      {
        SizeT rem = limit - dicPos;
        unsigned curLen = ((rem < len) ? (unsigned)rem : len);
        SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);

        processedPos += curLen;

        len -= curLen;
        if (pos + curLen <= dicBufSize)
        {
          Byte *dest = dic + dicPos;
          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
          const Byte *lim = dest + curLen;
          dicPos += curLen;
          do
            *(dest) = (Byte)*(dest + src);
          while (++dest != lim);
        }
        else
        {
          do
          {
            dic[dicPos++] = dic[pos];
            if (++pos == dicBufSize)
              pos = 0;
          }
          while (--curLen != 0);
        }
      }
    }
  }
  while (dicPos < limit && buf < bufLimit);
  NORMALIZE;
  p->buf = buf;
  p->range = range;
  p->code = code;
  p->remainLen = len;
  p->dicPos = dicPos;
  p->processedPos = processedPos;
  p->reps[0] = rep0;
  p->reps[1] = rep1;
  p->reps[2] = rep2;
  p->reps[3] = rep3;
  p->state = state;

  return SZ_OK;
}

static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
{
  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
  {
    Byte *dic = p->dic;
    SizeT dicPos = p->dicPos;
    SizeT dicBufSize = p->dicBufSize;
    unsigned len = p->remainLen;
    UInt32 rep0 = p->reps[0];
    if (limit - dicPos < len)
      len = (unsigned)(limit - dicPos);

    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
      p->checkDicSize = p->prop.dicSize;

    p->processedPos += len;
    p->remainLen -= len;
    while (len-- != 0)
    {
      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
      dicPos++;
    }
    p->dicPos = dicPos;
  }
}

static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
{
  do
  {
    SizeT limit2 = limit;
    if (p->checkDicSize == 0)
    {
      UInt32 rem = p->prop.dicSize - p->processedPos;
      if (limit - p->dicPos > rem)
        limit2 = p->dicPos + rem;
    }
    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
    if (p->processedPos >= p->prop.dicSize)
      p->checkDicSize = p->prop.dicSize;
    LzmaDec_WriteRem(p, limit);
  }
  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);

  if (p->remainLen > kMatchSpecLenStart)
  {
    p->remainLen = kMatchSpecLenStart;
  }
  return 0;
}

typedef enum
{
  DUMMY_ERROR, /* unexpected end of input stream */
  DUMMY_LIT,
  DUMMY_MATCH,
  DUMMY_REP
} ELzmaDummy;

static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
{
  UInt32 range = p->range;
  UInt32 code = p->code;
  const Byte *bufLimit = buf + inSize;
  CLzmaProb *probs = p->probs;
  unsigned state = p->state;
  ELzmaDummy res;

  {
    CLzmaProb *prob;
    UInt32 bound;
    unsigned ttt;
    unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);

    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
    IF_BIT_0_CHECK(prob)
    {
      UPDATE_0_CHECK

      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */

      prob = probs + Literal;
      if (p->checkDicSize != 0 || p->processedPos != 0)
        prob += (LZMA_LIT_SIZE *
          ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
          (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));

      if (state < kNumLitStates)
      {
        unsigned symbol = 1;
        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);
      }
      else
      {
        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
            ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
        unsigned offs = 0x100;
        unsigned symbol = 1;
        do
        {
          unsigned bit;
          CLzmaProb *probLit;
          matchByte <<= 1;
          bit = (matchByte & offs);
          probLit = prob + offs + bit + symbol;
          GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
        }
        while (symbol < 0x100);
      }
      res = DUMMY_LIT;
    }
    else
    {
      unsigned len;
      UPDATE_1_CHECK;

      prob = probs + IsRep + state;
      IF_BIT_0_CHECK(prob)
      {
        UPDATE_0_CHECK;
        state = 0;
        prob = probs + LenCoder;
        res = DUMMY_MATCH;
      }
      else
      {
        UPDATE_1_CHECK;
        res = DUMMY_REP;
        prob = probs + IsRepG0 + state;
        IF_BIT_0_CHECK(prob)
        {
          UPDATE_0_CHECK;
          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
          IF_BIT_0_CHECK(prob)
          {
            UPDATE_0_CHECK;
            NORMALIZE_CHECK;
            return DUMMY_REP;
          }
          else
          {
            UPDATE_1_CHECK;
          }
        }
        else
        {
          UPDATE_1_CHECK;
          prob = probs + IsRepG1 + state;
          IF_BIT_0_CHECK(prob)
          {
            UPDATE_0_CHECK;
          }
          else
          {
            UPDATE_1_CHECK;
            prob = probs + IsRepG2 + state;
            IF_BIT_0_CHECK(prob)
            {
              UPDATE_0_CHECK;
            }
            else
            {
              UPDATE_1_CHECK;
            }
          }
        }
        state = kNumStates;
        prob = probs + RepLenCoder;
      }
      {
        unsigned limit, offset;
        CLzmaProb *probLen = prob + LenChoice;
        IF_BIT_0_CHECK(probLen)
        {
          UPDATE_0_CHECK;
          probLen = prob + LenLow + (posState << kLenNumLowBits);
          offset = 0;
          limit = 1 << kLenNumLowBits;
        }
        else
        {
          UPDATE_1_CHECK;
          probLen = prob + LenChoice2;
          IF_BIT_0_CHECK(probLen)
          {
            UPDATE_0_CHECK;
            probLen = prob + LenMid + (posState << kLenNumMidBits);
            offset = kLenNumLowSymbols;
            limit = 1 << kLenNumMidBits;
          }
          else
          {
            UPDATE_1_CHECK;
            probLen = prob + LenHigh;
            offset = kLenNumLowSymbols + kLenNumMidSymbols;
            limit = 1 << kLenNumHighBits;
          }
        }
        TREE_DECODE_CHECK(probLen, limit, len);
        len += offset;
      }

      if (state < 4)
      {
        unsigned posSlot;
        prob = probs + PosSlot +
            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
            kNumPosSlotBits);
        TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
        if (posSlot >= kStartPosModelIndex)
        {
          int numDirectBits = ((posSlot >> 1) - 1);

          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */

          if (posSlot < kEndPosModelIndex)
          {
            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
          }
          else
          {
            numDirectBits -= kNumAlignBits;
            do
            {
              NORMALIZE_CHECK
              range >>= 1;
              code -= range & (((code - range) >> 31) - 1);
              /* if (code >= range) code -= range; */
            }
            while (--numDirectBits != 0);
            prob = probs + Align;
            numDirectBits = kNumAlignBits;
          }
          {
            unsigned i = 1;
            do
            {
              GET_BIT_CHECK(prob + i, i);
            }
            while (--numDirectBits != 0);
          }
        }
      }
    }
  }
  NORMALIZE_CHECK;
  return res;
}


static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
{
  p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
  p->range = 0xFFFFFFFF;
  p->needFlush = 0;
}

void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
{
  p->needFlush = 1;
  p->remainLen = 0;
  p->tempBufSize = 0;

  if (initDic)
  {
    p->processedPos = 0;
    p->checkDicSize = 0;
    p->needInitState = 1;
  }
  if (initState)
    p->needInitState = 1;
}

void LzmaDec_Init(CLzmaDec *p)
{
  p->dicPos = 0;
  LzmaDec_InitDicAndState(p, True, True);
}

static void LzmaDec_InitStateReal(CLzmaDec *p)
{
  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
  UInt32 i;
  CLzmaProb *probs = p->probs;
  for (i = 0; i < numProbs; i++)
    probs[i] = kBitModelTotal >> 1;
  p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
  p->state = 0;
  p->needInitState = 0;
}

SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
    ELzmaFinishMode finishMode, ELzmaStatus *status)
{
  SizeT inSize = *srcLen;
  (*srcLen) = 0;
  LzmaDec_WriteRem(p, dicLimit);
  
  *status = LZMA_STATUS_NOT_SPECIFIED;

  while (p->remainLen != kMatchSpecLenStart)
  {
      int checkEndMarkNow;

      if (p->needFlush != 0)
      {
        for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
          p->tempBuf[p->tempBufSize++] = *src++;
        if (p->tempBufSize < RC_INIT_SIZE)
        {
          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
          return SZ_OK;
        }
        if (p->tempBuf[0] != 0)
          return SZ_ERROR_DATA;

        LzmaDec_InitRc(p, p->tempBuf);
        p->tempBufSize = 0;
      }

      checkEndMarkNow = 0;
      if (p->dicPos >= dicLimit)
      {
        if (p->remainLen == 0 && p->code == 0)
        {
          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
          return SZ_OK;
        }
        if (finishMode == LZMA_FINISH_ANY)
        {
          *status = LZMA_STATUS_NOT_FINISHED;
          return SZ_OK;
        }
        if (p->remainLen != 0)
        {
          *status = LZMA_STATUS_NOT_FINISHED;
          return SZ_ERROR_DATA;
        }
        checkEndMarkNow = 1;
      }

      if (p->needInitState)
        LzmaDec_InitStateReal(p);
  
      if (p->tempBufSize == 0)
      {
        SizeT processed;
        const Byte *bufLimit;
        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
        {
          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
          if (dummyRes == DUMMY_ERROR)
          {
            memcpy(p->tempBuf, src, inSize);
            p->tempBufSize = (unsigned)inSize;
            (*srcLen) += inSize;
            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
            return SZ_OK;
          }
          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
          {
            *status = LZMA_STATUS_NOT_FINISHED;
            return SZ_ERROR_DATA;
          }
          bufLimit = src;
        }
        else
          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
        p->buf = src;
        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
          return SZ_ERROR_DATA;
        processed = (SizeT)(p->buf - src);
        (*srcLen) += processed;
        src += processed;
        inSize -= processed;
      }
      else
      {
        unsigned rem = p->tempBufSize, lookAhead = 0;
        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
          p->tempBuf[rem++] = src[lookAhead++];
        p->tempBufSize = rem;
        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
        {
          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
          if (dummyRes == DUMMY_ERROR)
          {
            (*srcLen) += lookAhead;
            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
            return SZ_OK;
          }
          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
          {
            *status = LZMA_STATUS_NOT_FINISHED;
            return SZ_ERROR_DATA;
          }
        }
        p->buf = p->tempBuf;
        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
          return SZ_ERROR_DATA;
        lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
        (*srcLen) += lookAhead;
        src += lookAhead;
        inSize -= lookAhead;
        p->tempBufSize = 0;
      }
  }
  if (p->code == 0)
    *status = LZMA_STATUS_FINISHED_WITH_MARK;
  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
}

SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
{
  SizeT outSize = *destLen;
  SizeT inSize = *srcLen;
  *srcLen = *destLen = 0;
  for (;;)
  {
    SizeT inSizeCur = inSize, outSizeCur, dicPos;
    ELzmaFinishMode curFinishMode;
    SRes res;
    if (p->dicPos == p->dicBufSize)
      p->dicPos = 0;
    dicPos = p->dicPos;
    if (outSize > p->dicBufSize - dicPos)
    {
      outSizeCur = p->dicBufSize;
      curFinishMode = LZMA_FINISH_ANY;
    }
    else
    {
      outSizeCur = dicPos + outSize;
      curFinishMode = finishMode;
    }

    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
    src += inSizeCur;
    inSize -= inSizeCur;
    *srcLen += inSizeCur;
    outSizeCur = p->dicPos - dicPos;
    memcpy(dest, p->dic + dicPos, outSizeCur);
    dest += outSizeCur;
    outSize -= outSizeCur;
    *destLen += outSizeCur;
    if (res != 0)
      return res;
    if (outSizeCur == 0 || outSize == 0)
      return SZ_OK;
  }
}

void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
{
  alloc->Free(alloc, p->probs);
  p->probs = 0;
}

static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
{
  alloc->Free(alloc, p->dic);
  p->dic = 0;
}

void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
{
  LzmaDec_FreeProbs(p, alloc);
  LzmaDec_FreeDict(p, alloc);
}

SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
{
  UInt32 dicSize;
  Byte d;
  
  if (size < LZMA_PROPS_SIZE)
    return SZ_ERROR_UNSUPPORTED;
  else
    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);
 
  if (dicSize < LZMA_DIC_MIN)
    dicSize = LZMA_DIC_MIN;
  p->dicSize = dicSize;

  d = data[0];
  if (d >= (9 * 5 * 5))
    return SZ_ERROR_UNSUPPORTED;

  p->lc = d % 9;
  d /= 9;
  p->pb = d / 5;
  p->lp = d % 5;

  return SZ_OK;
}

static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
{
  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
  if (p->probs == 0 || numProbs != p->numProbs)
  {
    LzmaDec_FreeProbs(p, alloc);
    p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
    p->numProbs = numProbs;
    if (p->probs == 0)
      return SZ_ERROR_MEM;
  }
  return SZ_OK;
}

SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
{
  CLzmaProps propNew;
  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
  p->prop = propNew;
  return SZ_OK;
}

SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
{
  CLzmaProps propNew;
  SizeT dicBufSize;
  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
  dicBufSize = propNew.dicSize;
  if (p->dic == 0 || dicBufSize != p->dicBufSize)
  {
    LzmaDec_FreeDict(p, alloc);
    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
    if (p->dic == 0)
    {
      LzmaDec_FreeProbs(p, alloc);
      return SZ_ERROR_MEM;
    }
  }
  p->dicBufSize = dicBufSize;
  p->prop = propNew;
  return SZ_OK;
}

SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
    ELzmaStatus *status, ISzAlloc *alloc)
{
  CLzmaDec p;
  SRes res;
  SizeT inSize = *srcLen;
  SizeT outSize = *destLen;
  *srcLen = *destLen = 0;
  if (inSize < RC_INIT_SIZE)
    return SZ_ERROR_INPUT_EOF;

  LzmaDec_Construct(&p);
  res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);
  if (res != 0)
    return res;
  p.dic = dest;
  p.dicBufSize = outSize;

  LzmaDec_Init(&p);
  
  *srcLen = inSize;
  res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);

  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
    res = SZ_ERROR_INPUT_EOF;

  (*destLen) = p.dicPos;
  LzmaDec_FreeProbs(&p, alloc);
  return res;
}
// --- End LzmaDec.c ---

// Macro cleanup for LzmaDec.c
#undef kNumTopBits
#undef kTopValue
#undef kNumBitModelTotalBits
#undef kBitModelTotal
#undef kNumMoveBits
#undef RC_INIT_SIZE
#undef NORMALIZE
#undef IF_BIT_0
#undef UPDATE_0
#undef UPDATE_1
#undef GET_BIT2
#undef GET_BIT
#undef TREE_GET_BIT
#undef TREE_DECODE
#undef TREE_6_DECODE
#undef NORMALIZE_CHECK
#undef IF_BIT_0_CHECK
#undef UPDATE_0_CHECK
#undef UPDATE_1_CHECK
#undef GET_BIT2_CHECK
#undef GET_BIT_CHECK
#undef TREE_DECODE_CHECK
#undef kNumPosBitsMax
#undef kNumPosStatesMax
#undef kLenNumLowBits
#undef kLenNumLowSymbols
#undef kLenNumMidBits
#undef kLenNumMidSymbols
#undef kLenNumHighBits
#undef kLenNumHighSymbols
#undef LenChoice
#undef LenChoice2
#undef LenLow
#undef LenMid
#undef LenHigh
#undef kNumLenProbs
#undef kNumStates
#undef kNumLitStates
#undef kStartPosModelIndex
#undef kEndPosModelIndex
#undef kNumFullDistances
#undef kNumPosSlotBits
#undef kNumLenToPosStates
#undef kNumAlignBits
#undef kAlignTableSize
#undef kMatchMinLen
#undef kMatchSpecLenStart
#undef IsMatch
#undef IsRep
#undef IsRepG0
#undef IsRepG1
#undef IsRepG2
#undef IsRep0Long
#undef PosSlot
#undef SpecPos
#undef Align
#undef LenCoder
#undef RepLenCoder
#undef Literal
#undef LZMA_BASE_SIZE
#undef LZMA_LIT_SIZE
#undef LzmaProps_GetNumProbs
#undef LZMA_DIC_MIN


// --- LzmaEnc.c ---
/* LzmaEnc.c -- LZMA Encoder
2008-10-04 : Igor Pavlov : Public domain */


/* #define SHOW_STAT */
/* #define SHOW_STAT2 */

#if defined(SHOW_STAT) || defined(SHOW_STAT2)
#include <stdio.h>
#endif


#ifdef COMPRESS_MF_MT
#endif

#ifdef SHOW_STAT
static int ttt = 0;
#endif

#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)

#define kBlockSize (9 << 10)
#define kUnpackBlockSize (1 << 18)
#define kMatchArraySize (1 << 21)
#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)

#define kNumMaxDirectBits (31)

#define kNumTopBits 24
#define kTopValue ((UInt32)1 << kNumTopBits)

#define kNumBitModelTotalBits 11
#define kBitModelTotal (1 << kNumBitModelTotalBits)
#define kNumMoveBits 5
#define kProbInitValue (kBitModelTotal >> 1)

#define kNumMoveReducingBits 4
#define kNumBitPriceShiftBits 4
#define kBitPrice (1 << kNumBitPriceShiftBits)

void LzmaEncProps_Init(CLzmaEncProps *p)
{
  p->level = 5;
  p->dictSize = p->mc = 0;
  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
  p->writeEndMark = 0;
}

void LzmaEncProps_Normalize(CLzmaEncProps *p)
{
  int level = p->level;
  if (level < 0) level = 5;
  p->level = level;
  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
  if (p->lc < 0) p->lc = 3;
  if (p->lp < 0) p->lp = 0;
  if (p->pb < 0) p->pb = 2;
  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
  if (p->numHashBytes < 0) p->numHashBytes = 4;
  if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
  if (p->numThreads < 0) p->numThreads = ((p->btMode && p->algo) ? 2 : 1);
}

UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
{
  CLzmaEncProps props = *props2;
  LzmaEncProps_Normalize(&props);
  return props.dictSize;
}

/* #define LZMA_LOG_BSR */
/* Define it for Intel's CPU */


#ifdef LZMA_LOG_BSR

#define kDicLogSizeMaxCompress 30

#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }

UInt32 GetPosSlot1(UInt32 pos)
{
  UInt32 res;
  BSR2_RET(pos, res);
  return res;
}
#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }

#else

#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)

void LzmaEnc_FastPosInit(Byte *g_FastPos)
{
  int c = 2, slotFast;
  g_FastPos[0] = 0;
  g_FastPos[1] = 1;
  
  for (slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)
  {
    UInt32 k = (1 << ((slotFast >> 1) - 1));
    UInt32 j;
    for (j = 0; j < k; j++, c++)
      g_FastPos[c] = (Byte)slotFast;
  }
}

#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
  res = p->g_FastPos[pos >> i] + (i * 2); }
/*
#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
  p->g_FastPos[pos >> 6] + 12 : \
  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
*/

#define GetPosSlot1(pos) p->g_FastPos[pos]
#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }

#endif


#define LZMA_NUM_REPS 4

typedef unsigned CState;

typedef struct _COptimal
{
  UInt32 price;

  CState state;
  int prev1IsChar;
  int prev2;

  UInt32 posPrev2;
  UInt32 backPrev2;

  UInt32 posPrev;
  UInt32 backPrev;
  UInt32 backs[LZMA_NUM_REPS];
} COptimal;

#define kNumOpts (1 << 12)

#define kNumLenToPosStates 4
#define kNumPosSlotBits 6
#define kDicLogSizeMin 0
#define kDicLogSizeMax 32
#define kDistTableSizeMax (kDicLogSizeMax * 2)


#define kNumAlignBits 4
#define kAlignTableSize (1 << kNumAlignBits)
#define kAlignMask (kAlignTableSize - 1)

#define kStartPosModelIndex 4
#define kEndPosModelIndex 14
#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)

#define kNumFullDistances (1 << (kEndPosModelIndex / 2))

#ifdef _LZMA_PROB32
#define CLzmaProb UInt32
#else
#define CLzmaProb UInt16
#endif

#define LZMA_PB_MAX 4
#define LZMA_LC_MAX 8
#define LZMA_LP_MAX 4

#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)


#define kLenNumLowBits 3
#define kLenNumLowSymbols (1 << kLenNumLowBits)
#define kLenNumMidBits 3
#define kLenNumMidSymbols (1 << kLenNumMidBits)
#define kLenNumHighBits 8
#define kLenNumHighSymbols (1 << kLenNumHighBits)

#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)

#define LZMA_MATCH_LEN_MIN 2
#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)

#define kNumStates 12

typedef struct
{
  CLzmaProb choice;
  CLzmaProb choice2;
  CLzmaProb low[LZMA_NUM_PB_STATES_MAX << kLenNumLowBits];
  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX << kLenNumMidBits];
  CLzmaProb high[kLenNumHighSymbols];
} CLenEnc;

typedef struct
{
  CLenEnc p;
  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
  UInt32 tableSize;
  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
} CLenPriceEnc;

typedef struct _CRangeEnc
{
  UInt32 range;
  Byte cache;
  UInt64 low;
  UInt64 cacheSize;
  Byte *buf;
  Byte *bufLim;
  Byte *bufBase;
  ISeqOutStream *outStream;
  UInt64 processed;
  SRes res;
} CRangeEnc;

typedef struct _CSeqInStreamBuf
{
  ISeqInStream funcTable;
  const Byte *data;
  SizeT rem;
} CSeqInStreamBuf;

static SRes MyRead(void *pp, void *data, size_t *size)
{
  size_t curSize = *size;
  CSeqInStreamBuf *p = (CSeqInStreamBuf *)pp;
  if (p->rem < curSize)
    curSize = p->rem;
  memcpy(data, p->data, curSize);
  p->rem -= curSize;
  p->data += curSize;
  *size = curSize;
  return SZ_OK;
}

typedef struct
{
  CLzmaProb *litProbs;

  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
  CLzmaProb isRep[kNumStates];
  CLzmaProb isRepG0[kNumStates];
  CLzmaProb isRepG1[kNumStates];
  CLzmaProb isRepG2[kNumStates];
  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];

  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
  
  CLenPriceEnc lenEnc;
  CLenPriceEnc repLenEnc;

  UInt32 reps[LZMA_NUM_REPS];
  UInt32 state;
} CSaveState;

typedef struct _CLzmaEnc
{
  IMatchFinder matchFinder;
  void *matchFinderObj;

  #ifdef COMPRESS_MF_MT
  Bool mtMode;
  CMatchFinderMt matchFinderMt;
  #endif

  CMatchFinder matchFinderBase;

  #ifdef COMPRESS_MF_MT
  Byte pad[128];
  #endif
  
  UInt32 optimumEndIndex;
  UInt32 optimumCurrentIndex;

  UInt32 longestMatchLength;
  UInt32 numPairs;
  UInt32 numAvail;
  COptimal opt[kNumOpts];
  
  #ifndef LZMA_LOG_BSR
  Byte g_FastPos[1 << kNumLogBits];
  #endif

  UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
  UInt32 numFastBytes;
  UInt32 additionalOffset;
  UInt32 reps[LZMA_NUM_REPS];
  UInt32 state;

  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
  UInt32 alignPrices[kAlignTableSize];
  UInt32 alignPriceCount;

  UInt32 distTableSize;

  unsigned lc, lp, pb;
  unsigned lpMask, pbMask;

  CLzmaProb *litProbs;

  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
  CLzmaProb isRep[kNumStates];
  CLzmaProb isRepG0[kNumStates];
  CLzmaProb isRepG1[kNumStates];
  CLzmaProb isRepG2[kNumStates];
  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];

  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
  
  CLenPriceEnc lenEnc;
  CLenPriceEnc repLenEnc;

  unsigned lclp;

  Bool fastMode;
  
  CRangeEnc rc;

  Bool writeEndMark;
  UInt64 nowPos64;
  UInt32 matchPriceCount;
  Bool finished;
  Bool multiThread;

  SRes result;
  UInt32 dictSize;
  UInt32 matchFinderCycles;

  ISeqInStream *inStream;
  CSeqInStreamBuf seqBufInStream;

  CSaveState saveState;
} CLzmaEnc;

void LzmaEnc_SaveState(CLzmaEncHandle pp)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  CSaveState *dest = &p->saveState;
  int i;
  dest->lenEnc = p->lenEnc;
  dest->repLenEnc = p->repLenEnc;
  dest->state = p->state;

  for (i = 0; i < kNumStates; i++)
  {
    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
  }
  for (i = 0; i < kNumLenToPosStates; i++)
    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
  memcpy(dest->reps, p->reps, sizeof(p->reps));
  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
}

void LzmaEnc_RestoreState(CLzmaEncHandle pp)
{
  CLzmaEnc *dest = (CLzmaEnc *)pp;
  const CSaveState *p = &dest->saveState;
  int i;
  dest->lenEnc = p->lenEnc;
  dest->repLenEnc = p->repLenEnc;
  dest->state = p->state;

  for (i = 0; i < kNumStates; i++)
  {
    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
  }
  for (i = 0; i < kNumLenToPosStates; i++)
    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
  memcpy(dest->reps, p->reps, sizeof(p->reps));
  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
}

SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  CLzmaEncProps props = *props2;
  LzmaEncProps_Normalize(&props);

  if (props.lc > LZMA_LC_MAX || props.lp > LZMA_LP_MAX || props.pb > LZMA_PB_MAX ||
      props.dictSize > (UInt32)(1u << kDicLogSizeMaxCompress) || props.dictSize > (UInt32)(1u << 30))
    return SZ_ERROR_PARAM;
  p->dictSize = props.dictSize;
  p->matchFinderCycles = props.mc;
  {
    unsigned fb = props.fb;
    if (fb < 5)
      fb = 5;
    if (fb > LZMA_MATCH_LEN_MAX)
      fb = LZMA_MATCH_LEN_MAX;
    p->numFastBytes = fb;
  }
  p->lc = props.lc;
  p->lp = props.lp;
  p->pb = props.pb;
  p->fastMode = (props.algo == 0);
  p->matchFinderBase.btMode = props.btMode;
  {
    UInt32 numHashBytes = 4;
    if (props.btMode)
    {
      if (props.numHashBytes < 2)
        numHashBytes = 2;
      else if (props.numHashBytes < 4)
        numHashBytes = props.numHashBytes;
    }
    p->matchFinderBase.numHashBytes = numHashBytes;
  }

  p->matchFinderBase.cutValue = props.mc;

  p->writeEndMark = props.writeEndMark;

  #ifdef COMPRESS_MF_MT
  /*
  if (newMultiThread != _multiThread)
  {
    ReleaseMatchFinder();
    _multiThread = newMultiThread;
  }
  */
  p->multiThread = (props.numThreads > 1);
  #endif

  return SZ_OK;
}

static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};

#define IsCharState(s) ((s) < 7)

#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)

#define kInfinityPrice (1 << 30)

static void RangeEnc_Construct(CRangeEnc *p)
{
  p->outStream = 0;
  p->bufBase = 0;
}

#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)

#define RC_BUF_SIZE (1 << 16)
static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
{
  if (p->bufBase == 0)
  {
    p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
    if (p->bufBase == 0)
      return 0;
    p->bufLim = p->bufBase + RC_BUF_SIZE;
  }
  return 1;
}

static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
{
  alloc->Free(alloc, p->bufBase);
  p->bufBase = 0;
}

static void RangeEnc_Init(CRangeEnc *p)
{
  /* Stream.Init(); */
  p->low = 0;
  p->range = 0xFFFFFFFF;
  p->cacheSize = 1;
  p->cache = 0;

  p->buf = p->bufBase;

  p->processed = 0;
  p->res = SZ_OK;
}

static void RangeEnc_FlushStream(CRangeEnc *p)
{
  size_t num;
  if (p->res != SZ_OK)
    return;
  num = p->buf - p->bufBase;
  if (num != p->outStream->Write(p->outStream, p->bufBase, num))
    p->res = SZ_ERROR_WRITE;
  p->processed += num;
  p->buf = p->bufBase;
}

static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
{
  if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
  {
    Byte temp = p->cache;
    do
    {
      Byte *buf = p->buf;
      *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
      p->buf = buf;
      if (buf == p->bufLim)
        RangeEnc_FlushStream(p);
      temp = 0xFF;
    }
    while (--p->cacheSize != 0);
    p->cache = (Byte)((UInt32)p->low >> 24);
  }
  p->cacheSize++;
  p->low = (UInt32)p->low << 8;
}

static void RangeEnc_FlushData(CRangeEnc *p)
{
  int i;
  for (i = 0; i < 5; i++)
    RangeEnc_ShiftLow(p);
}

static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
{
  do
  {
    p->range >>= 1;
    p->low += p->range & (0 - ((value >> --numBits) & 1));
    if (p->range < kTopValue)
    {
      p->range <<= 8;
      RangeEnc_ShiftLow(p);
    }
  }
  while (numBits != 0);
}

static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
{
  UInt32 ttt = *prob;
  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
  if (symbol == 0)
  {
    p->range = newBound;
    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
  }
  else
  {
    p->low += newBound;
    p->range -= newBound;
    ttt -= ttt >> kNumMoveBits;
  }
  *prob = (CLzmaProb)ttt;
  if (p->range < kTopValue)
  {
    p->range <<= 8;
    RangeEnc_ShiftLow(p);
  }
}

static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
{
  symbol |= 0x100;
  do
  {
    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
    symbol <<= 1;
  }
  while (symbol < 0x10000);
}

static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
{
  UInt32 offs = 0x100;
  symbol |= 0x100;
  do
  {
    matchByte <<= 1;
    RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
    symbol <<= 1;
    offs &= ~(matchByte ^ symbol);
  }
  while (symbol < 0x10000);
}

void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
{
  UInt32 i;
  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
  {
    const int kCyclesBits = kNumBitPriceShiftBits;
    UInt32 w = i;
    UInt32 bitCount = 0;
    int j;
    for (j = 0; j < kCyclesBits; j++)
    {
      w = w * w;
      bitCount <<= 1;
      while (w >= ((UInt32)1 << 16))
      {
        w >>= 1;
        bitCount++;
      }
    }
    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
  }
}


#define GET_PRICE(prob, symbol) \
  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];

#define GET_PRICEa(prob, symbol) \
  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];

#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]

#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]

static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
{
  UInt32 price = 0;
  symbol |= 0x100;
  do
  {
    price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
    symbol <<= 1;
  }
  while (symbol < 0x10000);
  return price;
}

static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
{
  UInt32 price = 0;
  UInt32 offs = 0x100;
  symbol |= 0x100;
  do
  {
    matchByte <<= 1;
    price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
    symbol <<= 1;
    offs &= ~(matchByte ^ symbol);
  }
  while (symbol < 0x10000);
  return price;
}


static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
{
  UInt32 m = 1;
  int i;
  for (i = numBitLevels; i != 0;)
  {
    UInt32 bit;
    i--;
    bit = (symbol >> i) & 1;
    RangeEnc_EncodeBit(rc, probs + m, bit);
    m = (m << 1) | bit;
  }
}

static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
{
  UInt32 m = 1;
  int i;
  for (i = 0; i < numBitLevels; i++)
  {
    UInt32 bit = symbol & 1;
    RangeEnc_EncodeBit(rc, probs + m, bit);
    m = (m << 1) | bit;
    symbol >>= 1;
  }
}

static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
{
  UInt32 price = 0;
  symbol |= (1 << numBitLevels);
  while (symbol != 1)
  {
    price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
    symbol >>= 1;
  }
  return price;
}

static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
{
  UInt32 price = 0;
  UInt32 m = 1;
  int i;
  for (i = numBitLevels; i != 0; i--)
  {
    UInt32 bit = symbol & 1;
    symbol >>= 1;
    price += GET_PRICEa(probs[m], bit);
    m = (m << 1) | bit;
  }
  return price;
}


static void LenEnc_Init(CLenEnc *p)
{
  unsigned i;
  p->choice = p->choice2 = kProbInitValue;
  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
    p->low[i] = kProbInitValue;
  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
    p->mid[i] = kProbInitValue;
  for (i = 0; i < kLenNumHighSymbols; i++)
    p->high[i] = kProbInitValue;
}

static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
{
  if (symbol < kLenNumLowSymbols)
  {
    RangeEnc_EncodeBit(rc, &p->choice, 0);
    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
  }
  else
  {
    RangeEnc_EncodeBit(rc, &p->choice, 1);
    if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
    {
      RangeEnc_EncodeBit(rc, &p->choice2, 0);
      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
    }
    else
    {
      RangeEnc_EncodeBit(rc, &p->choice2, 1);
      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
    }
  }
}

static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
{
  UInt32 a0 = GET_PRICE_0a(p->choice);
  UInt32 a1 = GET_PRICE_1a(p->choice);
  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
  UInt32 i = 0;
  for (i = 0; i < kLenNumLowSymbols; i++)
  {
    if (i >= numSymbols)
      return;
    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
  }
  for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
  {
    if (i >= numSymbols)
      return;
    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
  }
  for (; i < numSymbols; i++)
    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
}

static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
{
  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
  p->counters[posState] = p->tableSize;
}

static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
{
  UInt32 posState;
  for (posState = 0; posState < numPosStates; posState++)
    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
}

static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
{
  LenEnc_Encode(&p->p, rc, symbol, posState);
  if (updatePrice)
    if (--p->counters[posState] == 0)
      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
}




static void MovePos(CLzmaEnc *p, UInt32 num)
{
  #ifdef SHOW_STAT
  ttt += num;
  printf("\n MovePos %d", num);
  #endif
  if (num != 0)
  {
    p->additionalOffset += num;
    p->matchFinder.Skip(p->matchFinderObj, num);
  }
}

static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
{
  UInt32 lenRes = 0, numPairs;
  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
  #ifdef SHOW_STAT
  printf("\n i = %d numPairs = %d    ", ttt, numPairs / 2);
  ttt++;
  {
    UInt32 i;
    for (i = 0; i < numPairs; i += 2)
      printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
  }
  #endif
  if (numPairs > 0)
  {
    lenRes = p->matches[numPairs - 2];
    if (lenRes == p->numFastBytes)
    {
      const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
      UInt32 distance = p->matches[numPairs - 1] + 1;
      UInt32 numAvail = p->numAvail;
      if (numAvail > LZMA_MATCH_LEN_MAX)
        numAvail = LZMA_MATCH_LEN_MAX;
      {
        const Byte *pby2 = pby - distance;
        for (; lenRes < numAvail && pby[lenRes] == pby2[lenRes]; lenRes++);
      }
    }
  }
  p->additionalOffset++;
  *numDistancePairsRes = numPairs;
  return lenRes;
}


#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
#define IsShortRep(p) ((p)->backPrev == 0)

static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
{
  return
    GET_PRICE_0(p->isRepG0[state]) +
    GET_PRICE_0(p->isRep0Long[state][posState]);
}

static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
{
  UInt32 price;
  if (repIndex == 0)
  {
    price = GET_PRICE_0(p->isRepG0[state]);
    price += GET_PRICE_1(p->isRep0Long[state][posState]);
  }
  else
  {
    price = GET_PRICE_1(p->isRepG0[state]);
    if (repIndex == 1)
      price += GET_PRICE_0(p->isRepG1[state]);
    else
    {
      price += GET_PRICE_1(p->isRepG1[state]);
      price += GET_PRICE(p->isRepG2[state], repIndex - 2);
    }
  }
  return price;
}

static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
{
  return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
    GetPureRepPrice(p, repIndex, state, posState);
}

static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
{
  UInt32 posMem = p->opt[cur].posPrev;
  UInt32 backMem = p->opt[cur].backPrev;
  p->optimumEndIndex = cur;
  do
  {
    if (p->opt[cur].prev1IsChar)
    {
      MakeAsChar(&p->opt[posMem])
      p->opt[posMem].posPrev = posMem - 1;
      if (p->opt[cur].prev2)
      {
        p->opt[posMem - 1].prev1IsChar = False;
        p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
        p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
      }
    }
    {
      UInt32 posPrev = posMem;
      UInt32 backCur = backMem;
      
      backMem = p->opt[posPrev].backPrev;
      posMem = p->opt[posPrev].posPrev;
      
      p->opt[posPrev].backPrev = backCur;
      p->opt[posPrev].posPrev = cur;
      cur = posPrev;
    }
  }
  while (cur != 0);
  *backRes = p->opt[0].backPrev;
  p->optimumCurrentIndex  = p->opt[0].posPrev;
  return p->optimumCurrentIndex;
}

#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)

static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
{
  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
  UInt32 *matches;
  const Byte *data;
  Byte curByte, matchByte;
  if (p->optimumEndIndex != p->optimumCurrentIndex)
  {
    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
    *backRes = opt->backPrev;
    p->optimumCurrentIndex = opt->posPrev;
    return lenRes;
  }
  p->optimumCurrentIndex = p->optimumEndIndex = 0;
  
  if (p->additionalOffset == 0)
    mainLen = ReadMatchDistances(p, &numPairs);
  else
  {
    mainLen = p->longestMatchLength;
    numPairs = p->numPairs;
  }

  numAvail = p->numAvail;
  if (numAvail < 2)
  {
    *backRes = (UInt32)(-1);
    return 1;
  }
  if (numAvail > LZMA_MATCH_LEN_MAX)
    numAvail = LZMA_MATCH_LEN_MAX;

  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
  repMaxIndex = 0;
  for (i = 0; i < LZMA_NUM_REPS; i++)
  {
    UInt32 lenTest;
    const Byte *data2;
    reps[i] = p->reps[i];
    data2 = data - (reps[i] + 1);
    if (data[0] != data2[0] || data[1] != data2[1])
    {
      repLens[i] = 0;
      continue;
    }
    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
    repLens[i] = lenTest;
    if (lenTest > repLens[repMaxIndex])
      repMaxIndex = i;
  }
  if (repLens[repMaxIndex] >= p->numFastBytes)
  {
    UInt32 lenRes;
    *backRes = repMaxIndex;
    lenRes = repLens[repMaxIndex];
    MovePos(p, lenRes - 1);
    return lenRes;
  }

  matches = p->matches;
  if (mainLen >= p->numFastBytes)
  {
    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
    MovePos(p, mainLen - 1);
    return mainLen;
  }
  curByte = *data;
  matchByte = *(data - (reps[0] + 1));

  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
  {
    *backRes = (UInt32)-1;
    return 1;
  }

  p->opt[0].state = (CState)p->state;

  posState = (position & p->pbMask);

  {
    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
        (!IsCharState(p->state) ?
          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
  }

  MakeAsChar(&p->opt[1]);

  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);

  if (matchByte == curByte)
  {
    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
    if (shortRepPrice < p->opt[1].price)
    {
      p->opt[1].price = shortRepPrice;
      MakeAsShortRep(&p->opt[1]);
    }
  }
  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);

  if (lenEnd < 2)
  {
    *backRes = p->opt[1].backPrev;
    return 1;
  }

  p->opt[1].posPrev = 0;
  for (i = 0; i < LZMA_NUM_REPS; i++)
    p->opt[0].backs[i] = reps[i];

  len = lenEnd;
  do
    p->opt[len--].price = kInfinityPrice;
  while (len >= 2);

  for (i = 0; i < LZMA_NUM_REPS; i++)
  {
    UInt32 repLen = repLens[i];
    UInt32 price;
    if (repLen < 2)
      continue;
    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
    do
    {
      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
      COptimal *opt = &p->opt[repLen];
      if (curAndLenPrice < opt->price)
      {
        opt->price = curAndLenPrice;
        opt->posPrev = 0;
        opt->backPrev = i;
        opt->prev1IsChar = False;
      }
    }
    while (--repLen >= 2);
  }

  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);

  len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
  if (len <= mainLen)
  {
    UInt32 offs = 0;
    while (len > matches[offs])
      offs += 2;
    for (; ; len++)
    {
      COptimal *opt;
      UInt32 distance = matches[offs + 1];

      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
      UInt32 lenToPosState = GetLenToPosState(len);
      if (distance < kNumFullDistances)
        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
      else
      {
        UInt32 slot;
        GetPosSlot2(distance, slot);
        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
      }
      opt = &p->opt[len];
      if (curAndLenPrice < opt->price)
      {
        opt->price = curAndLenPrice;
        opt->posPrev = 0;
        opt->backPrev = distance + LZMA_NUM_REPS;
        opt->prev1IsChar = False;
      }
      if (len == matches[offs])
      {
        offs += 2;
        if (offs == numPairs)
          break;
      }
    }
  }

  cur = 0;

    #ifdef SHOW_STAT2
    if (position >= 0)
    {
      unsigned i;
      printf("\n pos = %4X", position);
      for (i = cur; i <= lenEnd; i++)
      printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
    }
    #endif

  for (;;)
  {
    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
    Bool nextIsChar;
    Byte curByte, matchByte;
    const Byte *data;
    COptimal *curOpt;
    COptimal *nextOpt;

    cur++;
    if (cur == lenEnd)
      return Backward(p, backRes, cur);

    newLen = ReadMatchDistances(p, &numPairs);
    if (newLen >= p->numFastBytes)
    {
      p->numPairs = numPairs;
      p->longestMatchLength = newLen;
      return Backward(p, backRes, cur);
    }
    position++;
    curOpt = &p->opt[cur];
    posPrev = curOpt->posPrev;
    if (curOpt->prev1IsChar)
    {
      posPrev--;
      if (curOpt->prev2)
      {
        state = p->opt[curOpt->posPrev2].state;
        if (curOpt->backPrev2 < LZMA_NUM_REPS)
          state = kRepNextStates[state];
        else
          state = kMatchNextStates[state];
      }
      else
        state = p->opt[posPrev].state;
      state = kLiteralNextStates[state];
    }
    else
      state = p->opt[posPrev].state;
    if (posPrev == cur - 1)
    {
      if (IsShortRep(curOpt))
        state = kShortRepNextStates[state];
      else
        state = kLiteralNextStates[state];
    }
    else
    {
      UInt32 pos;
      const COptimal *prevOpt;
      if (curOpt->prev1IsChar && curOpt->prev2)
      {
        posPrev = curOpt->posPrev2;
        pos = curOpt->backPrev2;
        state = kRepNextStates[state];
      }
      else
      {
        pos = curOpt->backPrev;
        if (pos < LZMA_NUM_REPS)
          state = kRepNextStates[state];
        else
          state = kMatchNextStates[state];
      }
      prevOpt = &p->opt[posPrev];
      if (pos < LZMA_NUM_REPS)
      {
        UInt32 i;
        reps[0] = prevOpt->backs[pos];
        for (i = 1; i <= pos; i++)
          reps[i] = prevOpt->backs[i - 1];
        for (; i < LZMA_NUM_REPS; i++)
          reps[i] = prevOpt->backs[i];
      }
      else
      {
        UInt32 i;
        reps[0] = (pos - LZMA_NUM_REPS);
        for (i = 1; i < LZMA_NUM_REPS; i++)
          reps[i] = prevOpt->backs[i - 1];
      }
    }
    curOpt->state = (CState)state;

    curOpt->backs[0] = reps[0];
    curOpt->backs[1] = reps[1];
    curOpt->backs[2] = reps[2];
    curOpt->backs[3] = reps[3];

    curPrice = curOpt->price;
    nextIsChar = False;
    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
    curByte = *data;
    matchByte = *(data - (reps[0] + 1));

    posState = (position & p->pbMask);

    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
    {
      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
      curAnd1Price +=
        (!IsCharState(state) ?
          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
    }

    nextOpt = &p->opt[cur + 1];

    if (curAnd1Price < nextOpt->price)
    {
      nextOpt->price = curAnd1Price;
      nextOpt->posPrev = cur;
      MakeAsChar(nextOpt);
      nextIsChar = True;
    }

    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
    
    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
    {
      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
      if (shortRepPrice <= nextOpt->price)
      {
        nextOpt->price = shortRepPrice;
        nextOpt->posPrev = cur;
        MakeAsShortRep(nextOpt);
        nextIsChar = True;
      }
    }
    numAvailFull = p->numAvail;
    {
      UInt32 temp = kNumOpts - 1 - cur;
      if (temp < numAvailFull)
        numAvailFull = temp;
    }

    if (numAvailFull < 2)
      continue;
    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);

    if (!nextIsChar && matchByte != curByte) /* speed optimization */
    {
      /* try Literal + rep0 */
      UInt32 temp;
      UInt32 lenTest2;
      const Byte *data2 = data - (reps[0] + 1);
      UInt32 limit = p->numFastBytes + 1;
      if (limit > numAvailFull)
        limit = numAvailFull;

      for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
      lenTest2 = temp - 1;
      if (lenTest2 >= 2)
      {
        UInt32 state2 = kLiteralNextStates[state];
        UInt32 posStateNext = (position + 1) & p->pbMask;
        UInt32 nextRepMatchPrice = curAnd1Price +
            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
            GET_PRICE_1(p->isRep[state2]);
        /* for (; lenTest2 >= 2; lenTest2--) */
        {
          UInt32 curAndLenPrice;
          COptimal *opt;
          UInt32 offset = cur + 1 + lenTest2;
          while (lenEnd < offset)
            p->opt[++lenEnd].price = kInfinityPrice;
          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
          opt = &p->opt[offset];
          if (curAndLenPrice < opt->price)
          {
            opt->price = curAndLenPrice;
            opt->posPrev = cur + 1;
            opt->backPrev = 0;
            opt->prev1IsChar = True;
            opt->prev2 = False;
          }
        }
      }
    }
    
    startLen = 2; /* speed optimization */
    {
    UInt32 repIndex;
    for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
    {
      UInt32 lenTest;
      UInt32 lenTestTemp;
      UInt32 price;
      const Byte *data2 = data - (reps[repIndex] + 1);
      if (data[0] != data2[0] || data[1] != data2[1])
        continue;
      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
      while (lenEnd < cur + lenTest)
        p->opt[++lenEnd].price = kInfinityPrice;
      lenTestTemp = lenTest;
      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
      do
      {
        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
        COptimal *opt = &p->opt[cur + lenTest];
        if (curAndLenPrice < opt->price)
        {
          opt->price = curAndLenPrice;
          opt->posPrev = cur;
          opt->backPrev = repIndex;
          opt->prev1IsChar = False;
        }
      }
      while (--lenTest >= 2);
      lenTest = lenTestTemp;
      
      if (repIndex == 0)
        startLen = lenTest + 1;
        
      /* if (_maxMode) */
        {
          UInt32 lenTest2 = lenTest + 1;
          UInt32 limit = lenTest2 + p->numFastBytes;
          UInt32 nextRepMatchPrice;
          if (limit > numAvailFull)
            limit = numAvailFull;
          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
          lenTest2 -= lenTest + 1;
          if (lenTest2 >= 2)
          {
            UInt32 state2 = kRepNextStates[state];
            UInt32 posStateNext = (position + lenTest) & p->pbMask;
            UInt32 curAndLenCharPrice =
                price + p->repLenEnc.prices[posState][lenTest - 2] +
                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
                    data[lenTest], data2[lenTest], p->ProbPrices);
            state2 = kLiteralNextStates[state2];
            posStateNext = (position + lenTest + 1) & p->pbMask;
            nextRepMatchPrice = curAndLenCharPrice +
                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
                GET_PRICE_1(p->isRep[state2]);
            
            /* for (; lenTest2 >= 2; lenTest2--) */
            {
              UInt32 curAndLenPrice;
              COptimal *opt;
              UInt32 offset = cur + lenTest + 1 + lenTest2;
              while (lenEnd < offset)
                p->opt[++lenEnd].price = kInfinityPrice;
              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
              opt = &p->opt[offset];
              if (curAndLenPrice < opt->price)
              {
                opt->price = curAndLenPrice;
                opt->posPrev = cur + lenTest + 1;
                opt->backPrev = 0;
                opt->prev1IsChar = True;
                opt->prev2 = True;
                opt->posPrev2 = cur;
                opt->backPrev2 = repIndex;
              }
            }
          }
        }
    }
    }
    /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
    if (newLen > numAvail)
    {
      newLen = numAvail;
      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
      matches[numPairs] = newLen;
      numPairs += 2;
    }
    if (newLen >= startLen)
    {
      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
      UInt32 offs, curBack, posSlot;
      UInt32 lenTest;
      while (lenEnd < cur + newLen)
        p->opt[++lenEnd].price = kInfinityPrice;

      offs = 0;
      while (startLen > matches[offs])
        offs += 2;
      curBack = matches[offs + 1];
      GetPosSlot2(curBack, posSlot);
      for (lenTest = /*2*/ startLen; ; lenTest++)
      {
        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
        UInt32 lenToPosState = GetLenToPosState(lenTest);
        COptimal *opt;
        if (curBack < kNumFullDistances)
          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
        else
          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
        
        opt = &p->opt[cur + lenTest];
        if (curAndLenPrice < opt->price)
        {
          opt->price = curAndLenPrice;
          opt->posPrev = cur;
          opt->backPrev = curBack + LZMA_NUM_REPS;
          opt->prev1IsChar = False;
        }

        if (/*_maxMode && */lenTest == matches[offs])
        {
          /* Try Match + Literal + Rep0 */
          const Byte *data2 = data - (curBack + 1);
          UInt32 lenTest2 = lenTest + 1;
          UInt32 limit = lenTest2 + p->numFastBytes;
          UInt32 nextRepMatchPrice;
          if (limit > numAvailFull)
            limit = numAvailFull;
          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
          lenTest2 -= lenTest + 1;
          if (lenTest2 >= 2)
          {
            UInt32 state2 = kMatchNextStates[state];
            UInt32 posStateNext = (position + lenTest) & p->pbMask;
            UInt32 curAndLenCharPrice = curAndLenPrice +
                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
                    data[lenTest], data2[lenTest], p->ProbPrices);
            state2 = kLiteralNextStates[state2];
            posStateNext = (posStateNext + 1) & p->pbMask;
            nextRepMatchPrice = curAndLenCharPrice +
                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
                GET_PRICE_1(p->isRep[state2]);
            
            /* for (; lenTest2 >= 2; lenTest2--) */
            {
              UInt32 offset = cur + lenTest + 1 + lenTest2;
              UInt32 curAndLenPrice;
              COptimal *opt;
              while (lenEnd < offset)
                p->opt[++lenEnd].price = kInfinityPrice;
              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
              opt = &p->opt[offset];
              if (curAndLenPrice < opt->price)
              {
                opt->price = curAndLenPrice;
                opt->posPrev = cur + lenTest + 1;
                opt->backPrev = 0;
                opt->prev1IsChar = True;
                opt->prev2 = True;
                opt->posPrev2 = cur;
                opt->backPrev2 = curBack + LZMA_NUM_REPS;
              }
            }
          }
          offs += 2;
          if (offs == numPairs)
            break;
          curBack = matches[offs + 1];
          if (curBack >= kNumFullDistances)
            GetPosSlot2(curBack, posSlot);
        }
      }
    }
  }
}

#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))

static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
{
  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
  const Byte *data;
  const UInt32 *matches;

  if (p->additionalOffset == 0)
    mainLen = ReadMatchDistances(p, &numPairs);
  else
  {
    mainLen = p->longestMatchLength;
    numPairs = p->numPairs;
  }

  numAvail = p->numAvail;
  *backRes = (UInt32)-1;
  if (numAvail < 2)
    return 1;
  if (numAvail > LZMA_MATCH_LEN_MAX)
    numAvail = LZMA_MATCH_LEN_MAX;
  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;

  repLen = repIndex = 0;
  for (i = 0; i < LZMA_NUM_REPS; i++)
  {
    UInt32 len;
    const Byte *data2 = data - (p->reps[i] + 1);
    if (data[0] != data2[0] || data[1] != data2[1])
      continue;
    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
    if (len >= p->numFastBytes)
    {
      *backRes = i;
      MovePos(p, len - 1);
      return len;
    }
    if (len > repLen)
    {
      repIndex = i;
      repLen = len;
    }
  }

  matches = p->matches;
  if (mainLen >= p->numFastBytes)
  {
    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
    MovePos(p, mainLen - 1);
    return mainLen;
  }

  mainDist = 0; /* for GCC */
  if (mainLen >= 2)
  {
    mainDist = matches[numPairs - 1];
    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
    {
      if (!ChangePair(matches[numPairs - 3], mainDist))
        break;
      numPairs -= 2;
      mainLen = matches[numPairs - 2];
      mainDist = matches[numPairs - 1];
    }
    if (mainLen == 2 && mainDist >= 0x80)
      mainLen = 1;
  }

  if (repLen >= 2 && (
        (repLen + 1 >= mainLen) ||
        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
  {
    *backRes = repIndex;
    MovePos(p, repLen - 1);
    return repLen;
  }
  
  if (mainLen < 2 || numAvail <= 2)
    return 1;

  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
  if (p->longestMatchLength >= 2)
  {
    UInt32 newDistance = matches[p->numPairs - 1];
    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
        (p->longestMatchLength > mainLen + 1) ||
        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
      return 1;
  }
  
  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
  for (i = 0; i < LZMA_NUM_REPS; i++)
  {
    UInt32 len, limit;
    const Byte *data2 = data - (p->reps[i] + 1);
    if (data[0] != data2[0] || data[1] != data2[1])
      continue;
    limit = mainLen - 1;
    for (len = 2; len < limit && data[len] == data2[len]; len++);
    if (len >= limit)
      return 1;
  }
  *backRes = mainDist + LZMA_NUM_REPS;
  MovePos(p, mainLen - 2);
  return mainLen;
}

static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
{
  UInt32 len;
  RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
  RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
  p->state = kMatchNextStates[p->state];
  len = LZMA_MATCH_LEN_MIN;
  LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
  RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
  RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
  RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
}

static SRes CheckErrors(CLzmaEnc *p)
{
  if (p->result != SZ_OK)
    return p->result;
  if (p->rc.res != SZ_OK)
    p->result = SZ_ERROR_WRITE;
  if (p->matchFinderBase.result != SZ_OK)
    p->result = SZ_ERROR_READ;
  if (p->result != SZ_OK)
    p->finished = True;
  return p->result;
}

static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
{
  /* ReleaseMFStream(); */
  p->finished = True;
  if (p->writeEndMark)
    WriteEndMarker(p, nowPos & p->pbMask);
  RangeEnc_FlushData(&p->rc);
  RangeEnc_FlushStream(&p->rc);
  return CheckErrors(p);
}

static void FillAlignPrices(CLzmaEnc *p)
{
  UInt32 i;
  for (i = 0; i < kAlignTableSize; i++)
    p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
  p->alignPriceCount = 0;
}

static void FillDistancesPrices(CLzmaEnc *p)
{
  UInt32 tempPrices[kNumFullDistances];
  UInt32 i, lenToPosState;
  for (i = kStartPosModelIndex; i < kNumFullDistances; i++)
  {
    UInt32 posSlot = GetPosSlot1(i);
    UInt32 footerBits = ((posSlot >> 1) - 1);
    UInt32 base = ((2 | (posSlot & 1)) << footerBits);
    tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
  }

  for (lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
  {
    UInt32 posSlot;
    const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
    UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
    for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
    for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
      posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);

    {
      UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
      UInt32 i;
      for (i = 0; i < kStartPosModelIndex; i++)
        distancesPrices[i] = posSlotPrices[i];
      for (; i < kNumFullDistances; i++)
        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
    }
  }
  p->matchPriceCount = 0;
}

void LzmaEnc_Construct(CLzmaEnc *p)
{
  RangeEnc_Construct(&p->rc);
  MatchFinder_Construct(&p->matchFinderBase);
  #ifdef COMPRESS_MF_MT
  MatchFinderMt_Construct(&p->matchFinderMt);
  p->matchFinderMt.MatchFinder = &p->matchFinderBase;
  #endif

  {
    CLzmaEncProps props;
    LzmaEncProps_Init(&props);
    LzmaEnc_SetProps(p, &props);
  }

  #ifndef LZMA_LOG_BSR
  LzmaEnc_FastPosInit(p->g_FastPos);
  #endif

  LzmaEnc_InitPriceTables(p->ProbPrices);
  p->litProbs = 0;
  p->saveState.litProbs = 0;
}

CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
{
  void *p;
  p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
  if (p != 0)
    LzmaEnc_Construct((CLzmaEnc *)p);
  return p;
}

void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
{
  alloc->Free(alloc, p->litProbs);
  alloc->Free(alloc, p->saveState.litProbs);
  p->litProbs = 0;
  p->saveState.litProbs = 0;
}

void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  #ifdef COMPRESS_MF_MT
  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
  #endif
  MatchFinder_Free(&p->matchFinderBase, allocBig);
  LzmaEnc_FreeLits(p, alloc);
  RangeEnc_Free(&p->rc, alloc);
}

void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
  alloc->Free(alloc, p);
}

static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
{
  UInt32 nowPos32, startPos32;
  if (p->inStream != 0)
  {
    p->matchFinderBase.stream = p->inStream;
    p->matchFinder.Init(p->matchFinderObj);
    p->inStream = 0;
  }

  if (p->finished)
    return p->result;
  RINOK(CheckErrors(p));

  nowPos32 = (UInt32)p->nowPos64;
  startPos32 = nowPos32;

  if (p->nowPos64 == 0)
  {
    UInt32 numPairs;
    Byte curByte;
    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
      return Flush(p, nowPos32);
    ReadMatchDistances(p, &numPairs);
    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
    p->state = kLiteralNextStates[p->state];
    curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
    LitEnc_Encode(&p->rc, p->litProbs, curByte);
    p->additionalOffset--;
    nowPos32++;
  }

  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
  for (;;)
  {
    UInt32 pos, len, posState;

    if (p->fastMode)
      len = GetOptimumFast(p, &pos);
    else
      len = GetOptimum(p, nowPos32, &pos);

    #ifdef SHOW_STAT2
    printf("\n pos = %4X,   len = %d   pos = %d", nowPos32, len, pos);
    #endif

    posState = nowPos32 & p->pbMask;
    if (len == 1 && pos == (UInt32)-1)
    {
      Byte curByte;
      CLzmaProb *probs;
      const Byte *data;

      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
      curByte = *data;
      probs = LIT_PROBS(nowPos32, *(data - 1));
      if (IsCharState(p->state))
        LitEnc_Encode(&p->rc, probs, curByte);
      else
        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
      p->state = kLiteralNextStates[p->state];
    }
    else
    {
      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
      if (pos < LZMA_NUM_REPS)
      {
        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
        if (pos == 0)
        {
          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
        }
        else
        {
          UInt32 distance = p->reps[pos];
          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
          if (pos == 1)
            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
          else
          {
            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
            if (pos == 3)
              p->reps[3] = p->reps[2];
            p->reps[2] = p->reps[1];
          }
          p->reps[1] = p->reps[0];
          p->reps[0] = distance;
        }
        if (len == 1)
          p->state = kShortRepNextStates[p->state];
        else
        {
          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
          p->state = kRepNextStates[p->state];
        }
      }
      else
      {
        UInt32 posSlot;
        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
        p->state = kMatchNextStates[p->state];
        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
        pos -= LZMA_NUM_REPS;
        GetPosSlot(pos, posSlot);
        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
        
        if (posSlot >= kStartPosModelIndex)
        {
          UInt32 footerBits = ((posSlot >> 1) - 1);
          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
          UInt32 posReduced = pos - base;

          if (posSlot < kEndPosModelIndex)
            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
          else
          {
            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
            p->alignPriceCount++;
          }
        }
        p->reps[3] = p->reps[2];
        p->reps[2] = p->reps[1];
        p->reps[1] = p->reps[0];
        p->reps[0] = pos;
        p->matchPriceCount++;
      }
    }
    p->additionalOffset -= len;
    nowPos32 += len;
    if (p->additionalOffset == 0)
    {
      UInt32 processed;
      if (!p->fastMode)
      {
        if (p->matchPriceCount >= (1 << 7))
          FillDistancesPrices(p);
        if (p->alignPriceCount >= kAlignTableSize)
          FillAlignPrices(p);
      }
      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
        break;
      processed = nowPos32 - startPos32;
      if (useLimits)
      {
        if (processed + kNumOpts + 300 >= maxUnpackSize ||
            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
          break;
      }
      else if (processed >= (1 << 15))
      {
        p->nowPos64 += nowPos32 - startPos32;
        return CheckErrors(p);
      }
    }
  }
  p->nowPos64 += nowPos32 - startPos32;
  return Flush(p, nowPos32);
}

#define kBigHashDicLimit ((UInt32)1 << 24)

static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  UInt32 beforeSize = kNumOpts;
  if (!RangeEnc_Alloc(&p->rc, alloc))
    return SZ_ERROR_MEM;
  #ifdef COMPRESS_MF_MT
  const Bool btMode = (p->matchFinderBase.btMode != 0);
  p->mtMode = (p->multiThread && !p->fastMode && btMode);
  #endif

  {
    unsigned lclp = p->lc + p->lp;
    if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
    {
      LzmaEnc_FreeLits(p, alloc);
      p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
      p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
      if (p->litProbs == 0 || p->saveState.litProbs == 0)
      {
        LzmaEnc_FreeLits(p, alloc);
        return SZ_ERROR_MEM;
      }
      p->lclp = lclp;
    }
  }

  p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);

  if (beforeSize + p->dictSize < keepWindowSize)
    beforeSize = keepWindowSize - p->dictSize;

  #ifdef COMPRESS_MF_MT
  if (p->mtMode)
  {
    RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
    p->matchFinderObj = &p->matchFinderMt;
    MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
  }
  else
  #endif
  {
    if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
      return SZ_ERROR_MEM;
    p->matchFinderObj = &p->matchFinderBase;
    MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
  }
  return SZ_OK;
}

void LzmaEnc_Init(CLzmaEnc *p)
{
  UInt32 i;
  p->state = 0;
  for (i = 0 ; i < LZMA_NUM_REPS; i++)
    p->reps[i] = 0;

  RangeEnc_Init(&p->rc);


  for (i = 0; i < kNumStates; i++)
  {
    UInt32 j;
    for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)
    {
      p->isMatch[i][j] = kProbInitValue;
      p->isRep0Long[i][j] = kProbInitValue;
    }
    p->isRep[i] = kProbInitValue;
    p->isRepG0[i] = kProbInitValue;
    p->isRepG1[i] = kProbInitValue;
    p->isRepG2[i] = kProbInitValue;
  }

  {
    UInt32 num = 0x300 << (p->lp + p->lc);
    for (i = 0; i < num; i++)
      p->litProbs[i] = kProbInitValue;
  }

  {
    for (i = 0; i < kNumLenToPosStates; i++)
    {
      CLzmaProb *probs = p->posSlotEncoder[i];
      UInt32 j;
      for (j = 0; j < (1 << kNumPosSlotBits); j++)
        probs[j] = kProbInitValue;
    }
  }
  {
    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
      p->posEncoders[i] = kProbInitValue;
  }

  LenEnc_Init(&p->lenEnc.p);
  LenEnc_Init(&p->repLenEnc.p);

  for (i = 0; i < (1 << kNumAlignBits); i++)
    p->posAlignEncoder[i] = kProbInitValue;

  p->optimumEndIndex = 0;
  p->optimumCurrentIndex = 0;
  p->additionalOffset = 0;

  p->pbMask = (1 << p->pb) - 1;
  p->lpMask = (1 << p->lp) - 1;
}

void LzmaEnc_InitPrices(CLzmaEnc *p)
{
  if (!p->fastMode)
  {
    FillDistancesPrices(p);
    FillAlignPrices(p);
  }

  p->lenEnc.tableSize =
  p->repLenEnc.tableSize =
      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
}

static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  UInt32 i;
  for (i = 0; i < (UInt32)kDicLogSizeMaxCompress; i++)
    if (p->dictSize <= ((UInt32)1 << i))
      break;
  p->distTableSize = i * 2;

  p->finished = False;
  p->result = SZ_OK;
  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
  LzmaEnc_Init(p);
  LzmaEnc_InitPrices(p);
  p->nowPos64 = 0;
  return SZ_OK;
}

static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqInStream *inStream, ISeqOutStream *outStream,
    ISzAlloc *alloc, ISzAlloc *allocBig)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  p->inStream = inStream;
  p->rc.outStream = outStream;
  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
}

SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
    ISeqInStream *inStream, UInt32 keepWindowSize,
    ISzAlloc *alloc, ISzAlloc *allocBig)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  p->inStream = inStream;
  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
}

static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
{
  p->seqBufInStream.funcTable.Read = MyRead;
  p->seqBufInStream.data = src;
  p->seqBufInStream.rem = srcLen;
}

SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  LzmaEnc_SetInputBuf(p, src, srcLen);
  p->inStream = &p->seqBufInStream.funcTable;
  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
}

void LzmaEnc_Finish(CLzmaEncHandle pp)
{
  #ifdef COMPRESS_MF_MT
  CLzmaEnc *p = (CLzmaEnc *)pp;
  if (p->mtMode)
    MatchFinderMt_ReleaseStream(&p->matchFinderMt);
  #else
  (void)pp;
  #endif
}

typedef struct _CSeqOutStreamBuf
{
  ISeqOutStream funcTable;
  Byte *data;
  SizeT rem;
  Bool overflow;
} CSeqOutStreamBuf;

static size_t MyWrite(void *pp, const void *data, size_t size)
{
  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
  if (p->rem < size)
  {
    size = p->rem;
    p->overflow = True;
  }
  memcpy(p->data, data, size);
  p->rem -= size;
  p->data += size;
  return size;
}


UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
{
  const CLzmaEnc *p = (CLzmaEnc *)pp;
  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
}

const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
{
  const CLzmaEnc *p = (CLzmaEnc *)pp;
  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
}

SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  UInt64 nowPos64;
  SRes res;
  CSeqOutStreamBuf outStream;

  outStream.funcTable.Write = MyWrite;
  outStream.data = dest;
  outStream.rem = *destLen;
  outStream.overflow = False;

  p->writeEndMark = False;
  p->finished = False;
  p->result = SZ_OK;

  if (reInit)
    LzmaEnc_Init(p);
  LzmaEnc_InitPrices(p);
  nowPos64 = p->nowPos64;
  RangeEnc_Init(&p->rc);
  p->rc.outStream = &outStream.funcTable;

  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
  
  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
  *destLen -= outStream.rem;
  if (outStream.overflow)
    return SZ_ERROR_OUTPUT_EOF;

  return res;
}

SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
    ISzAlloc *alloc, ISzAlloc *allocBig)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  SRes res = SZ_OK;

  #ifdef COMPRESS_MF_MT
  Byte allocaDummy[0x300];
  int i = 0;
  for (i = 0; i < 16; i++)
    allocaDummy[i] = (Byte)i;
  #endif

  RINOK(LzmaEnc_Prepare(pp, inStream, outStream, alloc, allocBig));

  for (;;)
  {
    res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
    if (res != SZ_OK || p->finished != 0)
      break;
    if (progress != 0)
    {
      res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
      if (res != SZ_OK)
      {
        res = SZ_ERROR_PROGRESS;
        break;
      }
    }
  }
  LzmaEnc_Finish(pp);
  return res;
}

SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  int i;
  UInt32 dictSize = p->dictSize;
  if (*size < LZMA_PROPS_SIZE)
    return SZ_ERROR_PARAM;
  *size = LZMA_PROPS_SIZE;
  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);

  for (i = 11; i <= 30; i++)
  {
    if (dictSize <= ((UInt32)2 << i))
    {
      dictSize = (2 << i);
      break;
    }
    if (dictSize <= ((UInt32)3 << i))
    {
      dictSize = (3 << i);
      break;
    }
  }

  for (i = 0; i < 4; i++)
    props[1 + i] = (Byte)(dictSize >> (8 * i));
  return SZ_OK;
}

SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  SRes res;
  CLzmaEnc *p = (CLzmaEnc *)pp;

  CSeqOutStreamBuf outStream;

  LzmaEnc_SetInputBuf(p, src, srcLen);

  outStream.funcTable.Write = MyWrite;
  outStream.data = dest;
  outStream.rem = *destLen;
  outStream.overflow = False;

  p->writeEndMark = writeEndMark;
  res = LzmaEnc_Encode(pp, &outStream.funcTable, &p->seqBufInStream.funcTable,
      progress, alloc, allocBig);

  *destLen -= outStream.rem;
  if (outStream.overflow)
    return SZ_ERROR_OUTPUT_EOF;
  return res;
}

SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
  SRes res;
  if (p == 0)
    return SZ_ERROR_MEM;

  res = LzmaEnc_SetProps(p, props);
  if (res == SZ_OK)
  {
    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
    if (res == SZ_OK)
      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
          writeEndMark, progress, alloc, allocBig);
  }

  LzmaEnc_Destroy(p, alloc, allocBig);
  return res;
}
// --- End LzmaEnc.c ---

// Macro cleanup for LzmaEnc.c
#undef kBlockSizeMax
#undef kBlockSize
#undef kUnpackBlockSize
#undef kMatchArraySize
#undef kMatchRecordMaxSize
#undef kNumMaxDirectBits
#undef kNumTopBits
#undef kTopValue
#undef kNumBitModelTotalBits
#undef kBitModelTotal
#undef kNumMoveBits
#undef kProbInitValue
#undef kNumMoveReducingBits
#undef kNumBitPriceShiftBits
#undef kBitPrice
#undef kDicLogSizeMaxCompress
#undef BSR2_RET
#undef GetPosSlot2
#undef GetPosSlot
#undef kNumLogBits
#undef GetPosSlot1
#undef LZMA_NUM_REPS
#undef kNumOpts
#undef kNumLenToPosStates
#undef kNumPosSlotBits
#undef kDicLogSizeMin
#undef kDicLogSizeMax
#undef kDistTableSizeMax
#undef kNumAlignBits
#undef kAlignTableSize
#undef kAlignMask
#undef kStartPosModelIndex
#undef kEndPosModelIndex
#undef kNumPosModels
#undef kNumFullDistances
#undef CLzmaProb
#undef LZMA_PB_MAX
#undef LZMA_LC_MAX
#undef LZMA_LP_MAX
#undef LZMA_NUM_PB_STATES_MAX
#undef kLenNumLowBits
#undef kLenNumLowSymbols
#undef kLenNumMidBits
#undef kLenNumMidSymbols
#undef kLenNumHighBits
#undef kLenNumHighSymbols
#undef kLenNumSymbolsTotal
#undef LZMA_MATCH_LEN_MIN
#undef LZMA_MATCH_LEN_MAX
#undef kNumStates
#undef IsCharState
#undef GetLenToPosState
#undef kInfinityPrice
#undef RangeEnc_GetProcessed
#undef RC_BUF_SIZE
#undef GET_PRICE
#undef GET_PRICEa
#undef GET_PRICE_0
#undef GET_PRICE_1
#undef GET_PRICE_0a
#undef GET_PRICE_1a
#undef MakeAsChar
#undef MakeAsShortRep
#undef IsShortRep
#undef LIT_PROBS
#undef ChangePair
#undef kBigHashDicLimit


// --- LzmaLib.h ---
/* LzmaLib.h -- LZMA library interface
2008-08-05
Igor Pavlov
Public domain */

#ifndef __LZMALIB_H
#define __LZMALIB_H


#ifdef __cplusplus
  #define MY_EXTERN_C extern "C"
#else
  #define MY_EXTERN_C extern
#endif

#define MY_STDAPI MY_EXTERN_C int MY_STD_CALL

#define LZMA_PROPS_SIZE 5

/*
RAM requirements for LZMA:
  for compression:   (dictSize * 11.5 + 6 MB) + state_size
  for decompression: dictSize + state_size
    state_size = (4 + (1.5 << (lc + lp))) KB
    by default (lc=3, lp=0), state_size = 16 KB.

LZMA properties (5 bytes) format
    Offset Size  Description
      0     1    lc, lp and pb in encoded form.
      1     4    dictSize (little endian).
*/

/*
LzmaCompress
------------

outPropsSize -
     In:  the pointer to the size of outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
     Out: the pointer to the size of written properties in outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.

  LZMA Encoder will use defult values for any parameter, if it is
  -1  for any from: level, loc, lp, pb, fb, numThreads
   0  for dictSize
  
level - compression level: 0 <= level <= 9;

  level dictSize algo  fb
    0:    16 KB   0    32
    1:    64 KB   0    32
    2:   256 KB   0    32
    3:     1 MB   0    32
    4:     4 MB   0    32
    5:    16 MB   1    32
    6:    32 MB   1    32
    7+:   64 MB   1    64
 
  The default value for "level" is 5.

  algo = 0 means fast method
  algo = 1 means normal method

dictSize - The dictionary size in bytes. The maximum value is
        128 MB = (1 << 27) bytes for 32-bit version
          1 GB = (1 << 30) bytes for 64-bit version
     The default value is 16 MB = (1 << 24) bytes.
     It's recommended to use the dictionary that is larger than 4 KB and
     that can be calculated as (1 << N) or (3 << N) sizes.

lc - The number of literal context bits (high bits of previous literal).
     It can be in the range from 0 to 8. The default value is 3.
     Sometimes lc=4 gives the gain for big files.

lp - The number of literal pos bits (low bits of current position for literals).
     It can be in the range from 0 to 4. The default value is 0.
     The lp switch is intended for periodical data when the period is equal to 2^lp.
     For example, for 32-bit (4 bytes) periodical data you can use lp=2. Often it's
     better to set lc=0, if you change lp switch.

pb - The number of pos bits (low bits of current position).
     It can be in the range from 0 to 4. The default value is 2.
     The pb switch is intended for periodical data when the period is equal 2^pb.

fb - Word size (the number of fast bytes).
     It can be in the range from 5 to 273. The default value is 32.
     Usually, a big number gives a little bit better compression ratio and
     slower compression process.

numThreads - The number of thereads. 1 or 2. The default value is 2.
     Fast mode (algo = 0) can use only 1 thread.

Out:
  destLen  - processed output size
Returns:
  SZ_OK               - OK
  SZ_ERROR_MEM        - Memory allocation error
  SZ_ERROR_PARAM      - Incorrect paramater
  SZ_ERROR_OUTPUT_EOF - output buffer overflow
  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
*/

MY_STDAPI LzmaCompress(unsigned char *dest, size_t *destLen, const unsigned char *src, size_t srcLen,
  unsigned char *outProps, size_t *outPropsSize, /* *outPropsSize must be = 5 */
  int level,      /* 0 <= level <= 9, default = 5 */
  unsigned dictSize,  /* default = (1 << 24) */
  int lc,        /* 0 <= lc <= 8, default = 3  */
  int lp,        /* 0 <= lp <= 4, default = 0  */
  int pb,        /* 0 <= pb <= 4, default = 2  */
  int fb,        /* 5 <= fb <= 273, default = 32 */
  int numThreads /* 1 or 2, default = 2 */
  );

/*
LzmaUncompress
--------------
In:
  dest     - output data
  destLen  - output data size
  src      - input data
  srcLen   - input data size
Out:
  destLen  - processed output size
  srcLen   - processed input size
Returns:
  SZ_OK                - OK
  SZ_ERROR_DATA        - Data error
  SZ_ERROR_MEM         - Memory allocation arror
  SZ_ERROR_UNSUPPORTED - Unsupported properties
  SZ_ERROR_INPUT_EOF   - it needs more bytes in input buffer (src)
*/

MY_STDAPI LzmaUncompress(unsigned char *dest, size_t *destLen, const unsigned char *src, SizeT *srcLen,
  const unsigned char *props, size_t propsSize);

#endif
// --- End LzmaLib.h ---

// --- LzmaLib.c ---
/* LzmaLib.c -- LZMA library wrapper
2008-08-05
Igor Pavlov
Public domain */


static void *SzAlloc(void *p, size_t size) { (void)p; return MyAlloc(size); }
static void SzFree(void *p, void *address) { (void)p; MyFree(address); }
static ISzAlloc g_Alloc = { SzAlloc, SzFree };

MY_STDAPI LzmaCompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  srcLen,
  unsigned char *outProps, size_t *outPropsSize,
  int level, /* 0 <= level <= 9, default = 5 */
  unsigned dictSize, /* use (1 << N) or (3 << N). 4 KB < dictSize <= 128 MB */
  int lc, /* 0 <= lc <= 8, default = 3  */
  int lp, /* 0 <= lp <= 4, default = 0  */
  int pb, /* 0 <= pb <= 4, default = 2  */
  int fb,  /* 5 <= fb <= 273, default = 32 */
  int numThreads /* 1 or 2, default = 2 */
)
{
  CLzmaEncProps props;
  LzmaEncProps_Init(&props);
  props.level = level;
  props.dictSize = dictSize;
  props.lc = lc;
  props.lp = lp;
  props.pb = pb;
  props.fb = fb;
  props.numThreads = numThreads;

  return LzmaEncode(dest, destLen, src, srcLen, &props, outProps, outPropsSize, 0,
      NULL, &g_Alloc, &g_Alloc);
}


MY_STDAPI LzmaUncompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  *srcLen,
  const unsigned char *props, size_t propsSize)
{
  ELzmaStatus status;
  return LzmaDecode(dest, destLen, src, srcLen, props, (unsigned)propsSize, LZMA_FINISH_ANY, &status, &g_Alloc);
}
// --- End LzmaLib.c ---

/* ===== End Embedded LZMA SDK ===== */

struct FloodQueue {
    usize* data;
    usize capacity;
    usize head;
    usize tail;

    FloodQueue() : data(0), capacity(0), head(0), tail(0) {}

    bool initialize(usize max_elements) {
        if (max_elements < 2u) {
            max_elements = 2u;
        }
        data = (usize*)malloc(max_elements * sizeof(usize));
        if (!data) {
            capacity = 0;
            head = tail = 0;
            return false;
        }
        capacity = max_elements;
        head = tail = 0;
        return true;
    }

    void release() {
        if (data) {
            free(data);
            data = 0;
        }
        capacity = 0;
        head = tail = 0;
    }

    void reset() {
        head = tail = 0;
    }

    bool push(usize value) {
        usize next = head + 1u;
        if (next >= capacity) {
            next = 0u;
        }
        if (next == tail) {
            return false;
        }
        data[head] = value;
        head = next;
        return true;
    }

    bool pop(usize& value) {
        if (head == tail) {
            return false;
        }
        value = data[tail];
        tail++;
        if (tail >= capacity) {
            tail = 0u;
        }
        return true;
    }
};

bool remove_border_dirt(image::ImageBuffer& image,
                        unsigned char fill_threshold,
                        ByteBuffer* out_mask,
                        unsigned protected_margin = 0u)
{
    unsigned width = image.width;
    unsigned height = image.height;
    if (!image.pixels || width == 0u || height == 0u) {
        if (out_mask) {
            out_mask->release();
        }
        return false;
    }
    usize total_pixels = (usize)width * (usize)height;
    if (!total_pixels) {
        if (out_mask) {
            out_mask->release();
        }
        return false;
    }

    bool has_protected_region = false;
    if (protected_margin > 0u && width > 0u && height > 0u) {
        unsigned double_margin = protected_margin * 2u;
        if (double_margin < width && double_margin < height) {
            has_protected_region = true;
        }
    }

    ByteBuffer mask;
    if (!mask.ensure(total_pixels)) {
        return false;
    }
    mask.size = total_pixels;
    for (usize i = 0; i < total_pixels; ++i) {
        mask.data[i] = 0xFFu;
    }

    usize queue_capacity = total_pixels + 1u;
    if (queue_capacity <= total_pixels) {
        mask.release();
        if (out_mask) {
            out_mask->release();
        }
        return false;
    }
    FloodQueue queue;
    if (!queue.initialize(queue_capacity)) {
        mask.release();
        return false;
    }

    bool queue_ok = true;
    unsigned char* pixels = image.pixels;

    auto try_copy = [&](unsigned x, unsigned y, bool require_white) {
        if (!queue_ok) {
            return;
        }
        if (x >= width || y >= height) {
            return;
        }
        usize index = (usize)y * (usize)width + (usize)x;
        if (mask.data[index] == 0u) {
            return;
        }
        if (require_white && pixels[index] < fill_threshold) {
            return;
        }
        mask.data[index] = 0u;
        if (!queue.push(index)) {
            queue_ok = false;
        }
    };

    auto flood = [&](unsigned start_x, unsigned start_y, bool require_white) {
        if (!queue_ok) {
            return;
        }
        queue.reset();
        try_copy(start_x, start_y, require_white);
        usize encoded = 0u;
        while (queue_ok && queue.pop(encoded)) {
            unsigned y = (unsigned)(encoded / (usize)width);
            unsigned x = (unsigned)(encoded - (usize)y * (usize)width);
            if (x + 1u < width) {
                try_copy(x + 1u, y, require_white);
            }
            if (x > 0u) {
                try_copy(x - 1u, y, require_white);
            }
            if (y + 1u < height) {
                try_copy(x, y + 1u, require_white);
            }
            if (y > 0u) {
                try_copy(x, y - 1u, require_white);
            }
        }
    };

    flood(0u, 0u, true);
    flood(width >> 1u, 0u, true);
    flood(width - 1u, 0u, true);
    flood(0u, height >> 1u, true);
    flood(0u, height - 1u, true);
    flood(width - 1u, height - 1u, true);
    flood(width - 1u, height >> 1u, true);
    flood(width >> 1u, height - 1u, true);
    flood(width >> 1u, height >> 1u, false);

    bool success = queue_ok;

    queue.release();

    if (!success) {
        mask.release();
        return false;
    }

    for (usize i = 0; i < total_pixels; ++i) {
        unsigned y = (unsigned)(i / (usize)width);
        unsigned x = (unsigned)(i - (usize)y * (usize)width);
        if (has_protected_region &&
            x >= protected_margin && x < (width - protected_margin) &&
            y >= protected_margin && y < (height - protected_margin)) {
            mask.data[i] = 0u;
            continue;
        }
        pixels[i] = (unsigned char)(pixels[i] | mask.data[i]);
    }

    if (out_mask) {
        out_mask->release();
        if (!out_mask->ensure(total_pixels)) {
            mask.release();
            return false;
        }
        out_mask->size = total_pixels;
        for (usize i = 0; i < total_pixels; ++i) {
            out_mask->data[i] = mask.data[i];
        }
    }

    mask.release();
    return true;
}

static const unsigned __int128 PCG64_MULTIPLIER =
    (((unsigned __int128)0x2360ED051FC65DA4ull) << 64u) | (unsigned __int128)0x4385DF649FCCF645ull;
static const unsigned __int128 PCG64_INCREMENT =
    (((unsigned __int128)0x5851F42D4C957F2Dull) << 64u) | (unsigned __int128)0x14057B7EF767814Full;

struct Pcg64Generator {
    unsigned __int128 state;

    Pcg64Generator() : state(0u) {}

    void seed(u64 seed_value) {
        state = 0u;
        (void)next();
        state += (unsigned __int128)seed_value;
        (void)next();
    }

    u64 next() {
        unsigned __int128 oldstate = state;
        state = oldstate * PCG64_MULTIPLIER + PCG64_INCREMENT;
        u64 xorshifted = (u64)(((oldstate >> 64u) ^ oldstate) >> 64u);
        u32 rot = (u32)(oldstate >> 122u);
        u32 rotate = rot & 63u;
        u32 inverse = (64u - rotate) & 63u;
        return (xorshifted >> rotate) | (xorshifted << inverse);
    }
};

static void crypto_random_bytes(u8* dest, usize count) {
    if (!dest || count == 0u) {
        return;
    }
    static Pcg64Generator rng;
    static bool seeded = false;
    if (!seeded) {
        u64 seed = (u64)time((long*)0);
        if (!seed) {
            seed = 0x726f6c6c6572756cull;
        }
        rng.seed(seed);
        seeded = true;
    }
    for (usize i = 0u; i < count; ) {
        u64 value = rng.next();
        for (u32 j = 0u; j < 8u && i < count; ++j) {
            dest[i++] = (u8)((value >> (j * 8u)) & 0xFFu);
        }
    }
}

static bool constant_time_equal(const u8* a, const u8* b, usize length) {
    if (!a || !b) {
        return false;
    }
    u8 diff = 0u;
    for (usize i = 0u; i < length; ++i) {
        diff |= (u8)(a[i] ^ b[i]);
    }
    return (diff == 0u);
}

static inline u32 rotl32(u32 value, u32 amount) {
    return (value << amount) | (value >> (32u - amount));
}

static inline u32 rotr32(u32 value, u32 amount) {
    return (value >> amount) | (value << (32u - amount));
}

static const u32 ENCRYPTION_HEADER_MAGIC = 0x4D454E43u;
static const u8  ENCRYPTION_HEADER_VERSION = 1u;
static const u8  ENCRYPTION_FLAG_PASSWORD = 0x01u;
static const u8  ENCRYPTION_KDF_PBKDF2_SHA256 = 1u;
static const usize ENCRYPTION_SALT_BYTES = (usize)16;
static const usize ENCRYPTION_NONCE_BYTES = (usize)12;
static const usize ENCRYPTION_TAG_BYTES = (usize)16;
static const usize ENCRYPTION_HEADER_BYTES = (usize)48;
static const u32 ENCRYPTION_PBKDF2_ITERATIONS = 60000u;

static const u32 SHA256_INITIAL_STATE[8] = {
    0x6a09e667u, 0xbb67ae85u, 0x3c6ef372u, 0xa54ff53au,
    0x510e527fu, 0x9b05688cu, 0x1f83d9abu, 0x5be0cd19u
};

static const u32 SHA256_K[64] = {
    0x428a2f98u, 0x71374491u, 0xb5c0fbcfu, 0xe9b5dba5u,
    0x3956c25bu, 0x59f111f1u, 0x923f82a4u, 0xab1c5ed5u,
    0xd807aa98u, 0x12835b01u, 0x243185beu, 0x550c7dc3u,
    0x72be5d74u, 0x80deb1feu, 0x9bdc06a7u, 0xc19bf174u,
    0xe49b69c1u, 0xefbe4786u, 0x0fc19dc6u, 0x240ca1ccu,
    0x2de92c6fu, 0x4a7484aau, 0x5cb0a9dcu, 0x76f988dau,
    0x983e5152u, 0xa831c66du, 0xb00327c8u, 0xbf597fc7u,
    0xc6e00bf3u, 0xd5a79147u, 0x06ca6351u, 0x14292967u,
    0x27b70a85u, 0x2e1b2138u, 0x4d2c6dfcu, 0x53380d13u,
    0x650a7354u, 0x766a0abbu, 0x81c2c92eu, 0x92722c85u,
    0xa2bfe8a1u, 0xa81a664bu, 0xc24b8b70u, 0xc76c51a3u,
    0xd192e819u, 0xd6990624u, 0xf40e3585u, 0x106aa070u,
    0x19a4c116u, 0x1e376c08u, 0x2748774cu, 0x34b0bcb5u,
    0x391c0cb3u, 0x4ed8aa4au, 0x5b9cca4fu, 0x682e6ff3u,
    0x748f82eeu, 0x78a5636fu, 0x84c87814u, 0x8cc70208u,
    0x90befffau, 0xa4506cebu, 0xbef9a3f7u, 0xc67178f2u
};

struct Sha256State {
    u32 h[8];
    u8 buffer[64];
    u64 bit_length;
    u32 buffer_used;

    Sha256State() : h(), buffer(), bit_length(0u), buffer_used(0u) {}
};

static void sha256_process_block(Sha256State& state, const u8* block) {
    u32 w[64];
    for (u32 i = 0u; i < 16u; ++i) {
        u32 b0 = (u32)block[i * 4u + 0u];
        u32 b1 = (u32)block[i * 4u + 1u];
        u32 b2 = (u32)block[i * 4u + 2u];
        u32 b3 = (u32)block[i * 4u + 3u];
        w[i] = (b0 << 24u) | (b1 << 16u) | (b2 << 8u) | b3;
    }
    for (u32 i = 16u; i < 64u; ++i) {
        u32 s0 = rotr32(w[i - 15u], 7u) ^ rotr32(w[i - 15u], 18u) ^ (w[i - 15u] >> 3u);
        u32 s1 = rotr32(w[i - 2u], 17u) ^ rotr32(w[i - 2u], 19u) ^ (w[i - 2u] >> 10u);
        w[i] = w[i - 16u] + s0 + w[i - 7u] + s1;
    }
    u32 a = state.h[0];
    u32 b = state.h[1];
    u32 c = state.h[2];
    u32 d = state.h[3];
    u32 e = state.h[4];
    u32 f = state.h[5];
    u32 g = state.h[6];
    u32 h = state.h[7];
    for (u32 i = 0u; i < 64u; ++i) {
        u32 s1 = rotr32(e, 6u) ^ rotr32(e, 11u) ^ rotr32(e, 25u);
        u32 ch = (e & f) ^ ((~e) & g);
        u32 temp1 = h + s1 + ch + SHA256_K[i] + w[i];
        u32 s0 = rotr32(a, 2u) ^ rotr32(a, 13u) ^ rotr32(a, 22u);
        u32 maj = (a & b) ^ (a & c) ^ (b & c);
        u32 temp2 = s0 + maj;
        h = g;
        g = f;
        f = e;
        e = d + temp1;
        d = c;
        c = b;
        b = a;
        a = temp1 + temp2;
    }
    state.h[0] += a;
    state.h[1] += b;
    state.h[2] += c;
    state.h[3] += d;
    state.h[4] += e;
    state.h[5] += f;
    state.h[6] += g;
    state.h[7] += h;
}

static void sha256_init(Sha256State& state) {
    for (u32 i = 0u; i < 8u; ++i) {
        state.h[i] = SHA256_INITIAL_STATE[i];
    }
    state.bit_length = 0u;
    state.buffer_used = 0u;
}

static void sha256_update(Sha256State& state, const u8* data, usize length) {
    if (!data || length == 0u) {
        return;
    }
    while (length > 0u) {
        usize to_copy = 64u - (usize)state.buffer_used;
        if (to_copy > length) {
            to_copy = length;
        }
        for (usize i = 0u; i < to_copy; ++i) {
            state.buffer[state.buffer_used + (u32)i] = data[i];
        }
        state.buffer_used += (u32)to_copy;
        data += to_copy;
        length -= to_copy;
        if (state.buffer_used == 64u) {
            sha256_process_block(state, state.buffer);
            state.bit_length += 512u;
            state.buffer_used = 0u;
        }
    }
}

static void sha256_finalize(Sha256State& state, u8 digest[32]) {
    state.bit_length += (u64)state.buffer_used * 8ull;
    state.buffer[state.buffer_used++] = 0x80u;
    if (state.buffer_used > 56u) {
        while (state.buffer_used < 64u) {
            state.buffer[state.buffer_used++] = 0u;
        }
        sha256_process_block(state, state.buffer);
        state.buffer_used = 0u;
    }
    while (state.buffer_used < 56u) {
        state.buffer[state.buffer_used++] = 0u;
    }
    u64 bits = state.bit_length;
    for (u32 i = 0u; i < 8u; ++i) {
        state.buffer[63u - i] = (u8)(bits & 0xFFu);
        bits >>= 8u;
    }
    sha256_process_block(state, state.buffer);
    for (u32 i = 0u; i < 8u; ++i) {
        digest[i * 4u + 0u] = (u8)((state.h[i] >> 24u) & 0xFFu);
        digest[i * 4u + 1u] = (u8)((state.h[i] >> 16u) & 0xFFu);
        digest[i * 4u + 2u] = (u8)((state.h[i] >> 8u) & 0xFFu);
        digest[i * 4u + 3u] = (u8)(state.h[i] & 0xFFu);
    }
}

static bool hmac_sha256(const u8* key,
                        usize key_length,
                        const u8* data,
                        usize data_length,
                        u8 output[32]) {
    if (!key || key_length == 0u || !output) {
        return false;
    }
    const usize block_size = 64u;
    u8 key_block[64];
    for (usize i = 0u; i < block_size; ++i) {
        key_block[i] = 0u;
    }
    if (key_length > block_size) {
        Sha256State temp;
        sha256_init(temp);
        sha256_update(temp, key, key_length);
        u8 hashed[32];
        sha256_finalize(temp, hashed);
        for (usize i = 0u; i < 32u; ++i) {
            key_block[i] = hashed[i];
        }
        for (usize i = 0u; i < 32u; ++i) {
            hashed[i] = 0u;
        }
    } else {
        for (usize i = 0u; i < key_length; ++i) {
            key_block[i] = key[i];
        }
    }
    u8 ipad[64];
    u8 opad[64];
    for (usize i = 0u; i < block_size; ++i) {
        ipad[i] = (u8)(key_block[i] ^ 0x36u);
        opad[i] = (u8)(key_block[i] ^ 0x5cu);
    }
    Sha256State inner;
    sha256_init(inner);
    sha256_update(inner, ipad, block_size);
    sha256_update(inner, data, data_length);
    u8 inner_digest[32];
    sha256_finalize(inner, inner_digest);
    Sha256State outer;
    sha256_init(outer);
    sha256_update(outer, opad, block_size);
    sha256_update(outer, inner_digest, 32u);
    sha256_finalize(outer, output);
    for (usize i = 0u; i < block_size; ++i) {
        key_block[i] = 0u;
        ipad[i] = 0u;
        opad[i] = 0u;
    }
    for (usize i = 0u; i < 32u; ++i) {
        inner_digest[i] = 0u;
    }
    return true;
}

static bool pbkdf2_hmac_sha256(const u8* password,
                               usize password_length,
                               const u8* salt,
                               usize salt_length,
                               u32 iterations,
                               u8* output,
                               usize output_length) {
    if (!password || password_length == 0u || !salt || !output || output_length == 0u || iterations == 0u) {
        return false;
    }
    u32 block_count = (u32)((output_length + 31u) / 32u);
    makocode::ByteBuffer salt_buffer;
    if (!salt_buffer.ensure(salt_length + 4u)) {
        return false;
    }
    for (usize i = 0u; i < salt_length; ++i) {
        salt_buffer.data[i] = salt[i];
    }
    salt_buffer.size = salt_length + 4u;
    u8 u[32];
    u8 t[32];
    for (u32 block_index = 1u; block_index <= block_count; ++block_index) {
        u32 bi = block_index;
        salt_buffer.data[salt_length + 0u] = (u8)((bi >> 24u) & 0xFFu);
        salt_buffer.data[salt_length + 1u] = (u8)((bi >> 16u) & 0xFFu);
        salt_buffer.data[salt_length + 2u] = (u8)((bi >> 8u) & 0xFFu);
        salt_buffer.data[salt_length + 3u] = (u8)(bi & 0xFFu);
        if (!hmac_sha256(password, password_length, salt_buffer.data, salt_length + 4u, u)) {
            salt_buffer.release();
            return false;
        }
        for (u32 i = 0u; i < 32u; ++i) {
            t[i] = u[i];
        }
        for (u32 iter = 1u; iter < iterations; ++iter) {
            if (!hmac_sha256(password, password_length, u, 32u, u)) {
                salt_buffer.release();
                return false;
            }
            for (u32 i = 0u; i < 32u; ++i) {
                t[i] ^= u[i];
            }
        }
        usize offset = (usize)(block_index - 1u) * 32u;
        usize remaining = output_length - offset;
        usize to_copy = (remaining < 32u) ? remaining : (usize)32u;
        for (usize i = 0u; i < to_copy; ++i) {
            output[offset + i] = t[i];
        }
    }
    for (u32 i = 0u; i < 32u; ++i) {
        u[i] = 0u;
        t[i] = 0u;
    }
    salt_buffer.release();
    return true;
}

static inline void chacha20_quarter_round(u32& a, u32& b, u32& c, u32& d) {
    a += b;
    d ^= a;
    d = rotl32(d, 16u);
    c += d;
    b ^= c;
    b = rotl32(b, 12u);
    a += b;
    d ^= a;
    d = rotl32(d, 8u);
    c += d;
    b ^= c;
    b = rotl32(b, 7u);
}

static void chacha20_block(const u8 key[32], const u8 nonce[12], u32 counter, u8 output[64]) {
    static const u32 constants[4] = {0x61707865u, 0x3320646eu, 0x79622d32u, 0x6b206574u};
    u32 state[16];
    state[0] = constants[0];
    state[1] = constants[1];
    state[2] = constants[2];
    state[3] = constants[3];
    for (u32 i = 0u; i < 8u; ++i) {
        state[4u + i] = read_le_u32(key + i * 4u);
    }
    state[12] = counter;
    state[13] = read_le_u32(nonce + 0u);
    state[14] = read_le_u32(nonce + 4u);
    state[15] = read_le_u32(nonce + 8u);
    u32 working[16];
    for (u32 i = 0u; i < 16u; ++i) {
        working[i] = state[i];
    }
    for (u32 round = 0u; round < 10u; ++round) {
        chacha20_quarter_round(working[0], working[4], working[8], working[12]);
        chacha20_quarter_round(working[1], working[5], working[9], working[13]);
        chacha20_quarter_round(working[2], working[6], working[10], working[14]);
        chacha20_quarter_round(working[3], working[7], working[11], working[15]);
        chacha20_quarter_round(working[0], working[5], working[10], working[15]);
        chacha20_quarter_round(working[1], working[6], working[11], working[12]);
        chacha20_quarter_round(working[2], working[7], working[8], working[13]);
        chacha20_quarter_round(working[3], working[4], working[9], working[14]);
    }
    for (u32 i = 0u; i < 16u; ++i) {
        working[i] += state[i];
        write_le_u32(output + i * 4u, working[i]);
    }
}

static bool chacha20_xor(const u8 key[32],
                         const u8 nonce[12],
                         u32 counter,
                         const u8* input,
                         u8* output,
                         usize length) {
    if ((!input && length > 0u) || !output) {
        return false;
    }
    u8 block[64];
    usize offset = 0u;
    while (offset < length) {
        chacha20_block(key, nonce, counter, block);
        counter += 1u;
        usize chunk = (length - offset >= 64u) ? 64u : (length - offset);
        for (usize i = 0u; i < chunk; ++i) {
            u8 keystream = block[i];
            u8 source = input ? input[offset + i] : 0u;
            output[offset + i] = (u8)(source ^ keystream);
        }
        offset += chunk;
    }
    for (u32 i = 0u; i < 64u; ++i) {
        block[i] = 0u;
    }
    return true;
}

struct Poly1305State {
    u64 r0, r1, r2, r3, r4;
    u64 s1, s2, s3, s4;
    u64 h0, h1, h2, h3, h4;

    Poly1305State()
        : r0(0u), r1(0u), r2(0u), r3(0u), r4(0u),
          s1(0u), s2(0u), s3(0u), s4(0u),
          h0(0u), h1(0u), h2(0u), h3(0u), h4(0u) {}
};

static void poly1305_init_state(Poly1305State& state, const u8 key[32]) {
    unsigned __int128 r = (unsigned __int128)read_le_u64(key) |
                          ((unsigned __int128)read_le_u64(key + 8u) << 64u);
    unsigned __int128 mask = (((unsigned __int128)0x0ffffffc0ffffffcull) << 64u) |
                             (unsigned __int128)0x0ffffffc0fffffffull;
    r &= mask;
    u64 r_low = (u64)(r & ((unsigned __int128)0xFFFFFFFFFFFFFFFFull));
    u64 r_high = (u64)(r >> 64u);
    state.r0 = r_low & 0x3ffffffu;
    state.r1 = ((r_low >> 26u) & 0x3ffffffu);
    state.r2 = (((r_low >> 52u) | (r_high << 12u)) & 0x3ffffffu);
    state.r3 = ((r_high >> 14u) & 0x3ffffffu);
    state.r4 = ((r_high >> 40u) & 0x3ffffffu);
    state.s1 = state.r1 * 5u;
    state.s2 = state.r2 * 5u;
    state.s3 = state.r3 * 5u;
    state.s4 = state.r4 * 5u;
    state.h0 = state.h1 = state.h2 = state.h3 = state.h4 = 0u;
}

static void poly1305_process_block(Poly1305State& state, const u8 block[16], u64 hibit) {
    u64 t0 = read_le_u64(block);
    u64 t1 = read_le_u64(block + 8u);
    state.h0 += t0 & 0x3ffffffu;
    state.h1 += (t0 >> 26u) & 0x3ffffffu;
    state.h2 += ((t0 >> 52u) | (t1 << 12u)) & 0x3ffffffu;
    state.h3 += (t1 >> 14u) & 0x3ffffffu;
    state.h4 += ((t1 >> 40u) & 0x3ffffffu) + hibit;

    unsigned __int128 d0 = (unsigned __int128)state.h0 * state.r0 +
                           (unsigned __int128)state.h1 * state.s4 +
                           (unsigned __int128)state.h2 * state.s3 +
                           (unsigned __int128)state.h3 * state.s2 +
                           (unsigned __int128)state.h4 * state.s1;
    unsigned __int128 d1 = (unsigned __int128)state.h0 * state.r1 +
                           (unsigned __int128)state.h1 * state.r0 +
                           (unsigned __int128)state.h2 * state.s4 +
                           (unsigned __int128)state.h3 * state.s3 +
                           (unsigned __int128)state.h4 * state.s2;
    unsigned __int128 d2 = (unsigned __int128)state.h0 * state.r2 +
                           (unsigned __int128)state.h1 * state.r1 +
                           (unsigned __int128)state.h2 * state.r0 +
                           (unsigned __int128)state.h3 * state.s4 +
                           (unsigned __int128)state.h4 * state.s3;
    unsigned __int128 d3 = (unsigned __int128)state.h0 * state.r3 +
                           (unsigned __int128)state.h1 * state.r2 +
                           (unsigned __int128)state.h2 * state.r1 +
                           (unsigned __int128)state.h3 * state.r0 +
                           (unsigned __int128)state.h4 * state.s4;
    unsigned __int128 d4 = (unsigned __int128)state.h0 * state.r4 +
                           (unsigned __int128)state.h1 * state.r3 +
                           (unsigned __int128)state.h2 * state.r2 +
                           (unsigned __int128)state.h3 * state.r1 +
                           (unsigned __int128)state.h4 * state.r0;

    u64 h0 = (u64)(d0 & 0x3ffffffu);
    u64 carry = (u64)(d0 >> 26u);
    d1 += carry;
    u64 h1 = (u64)(d1 & 0x3ffffffu);
    carry = (u64)(d1 >> 26u);
    d2 += carry;
    u64 h2 = (u64)(d2 & 0x3ffffffu);
    carry = (u64)(d2 >> 26u);
    d3 += carry;
    u64 h3 = (u64)(d3 & 0x3ffffffu);
    carry = (u64)(d3 >> 26u);
    d4 += carry;
    u64 h4 = (u64)(d4 & 0x3ffffffu);
    carry = (u64)(d4 >> 26u);
    h0 += carry * 5u;
    carry = h0 >> 26u;
    h0 &= 0x3ffffffu;
    h1 += carry;
    carry = h1 >> 26u;
    h1 &= 0x3ffffffu;
    h2 += carry;
    carry = h2 >> 26u;
    h2 &= 0x3ffffffu;
    h3 += carry;
    carry = h3 >> 26u;
    h3 &= 0x3ffffffu;
    h4 += carry;
    state.h0 = h0;
    state.h1 = h1;
    state.h2 = h2;
    state.h3 = h3;
    state.h4 = h4;
}

static void poly1305_update(Poly1305State& state, const u8* data, usize length) {
    if (!data || length == 0u) {
        return;
    }
    while (length >= 16u) {
        poly1305_process_block(state, data, (1ull << 24u));
        data += 16u;
        length -= 16u;
    }
    if (length > 0u) {
        u8 buffer[16];
        for (usize i = 0u; i < 16u; ++i) {
            buffer[i] = 0u;
        }
        for (usize i = 0u; i < length; ++i) {
            buffer[i] = data[i];
        }
        buffer[length] = 1u;
        poly1305_process_block(state, buffer, 0u);
    }
}

static void poly1305_pad16(Poly1305State& state, usize length) {
    usize remainder = length & 15u;
    if (!remainder) {
        return;
    }
    u8 padding[16];
    for (usize i = 0u; i < 16u; ++i) {
        padding[i] = 0u;
    }
    poly1305_update(state, padding, 16u - remainder);
}

static void poly1305_finish(Poly1305State& state, const u8 pad[16], u8 tag[16]) {
    u64 carry = state.h1 >> 26u;
    state.h1 &= 0x3ffffffu;
    state.h2 += carry;
    carry = state.h2 >> 26u;
    state.h2 &= 0x3ffffffu;
    state.h3 += carry;
    carry = state.h3 >> 26u;
    state.h3 &= 0x3ffffffu;
    state.h4 += carry;
    carry = state.h4 >> 26u;
    state.h4 &= 0x3ffffffu;
    state.h0 += carry * 5u;
    carry = state.h0 >> 26u;
    state.h0 &= 0x3ffffffu;
    state.h1 += carry;
    carry = state.h1 >> 26u;
    state.h1 &= 0x3ffffffu;
    state.h2 += carry;
    carry = state.h2 >> 26u;
    state.h2 &= 0x3ffffffu;
    state.h3 += carry;
    carry = state.h3 >> 26u;
    state.h3 &= 0x3ffffffu;
    state.h4 += carry;

    u64 g0 = state.h0 + 5u;
    carry = g0 >> 26u;
    g0 &= 0x3ffffffu;
    u64 g1 = state.h1 + carry;
    carry = g1 >> 26u;
    g1 &= 0x3ffffffu;
    u64 g2 = state.h2 + carry;
    carry = g2 >> 26u;
    g2 &= 0x3ffffffu;
    u64 g3 = state.h3 + carry;
    carry = g3 >> 26u;
    g3 &= 0x3ffffffu;
    u64 g4 = state.h4 + carry - (1ull << 26u);
    u64 mask = ((g4 >> 63u) - 1u);
    g0 &= mask;
    g1 &= mask;
    g2 &= mask;
    g3 &= mask;
    g4 &= mask;
    mask = ~mask;
    state.h0 = (state.h0 & mask) | g0;
    state.h1 = (state.h1 & mask) | g1;
    state.h2 = (state.h2 & mask) | g2;
    state.h3 = (state.h3 & mask) | g3;
    state.h4 = (state.h4 & mask) | g4;

    unsigned __int128 acc = (unsigned __int128)state.h0 |
                            ((unsigned __int128)state.h1 << 26u) |
                            ((unsigned __int128)state.h2 << 52u) |
                            ((unsigned __int128)state.h3 << 78u) |
                            ((unsigned __int128)state.h4 << 104u);
    unsigned __int128 sum0 = acc + (unsigned __int128)read_le_u64(pad);
    u64 f0 = (u64)sum0;
    unsigned __int128 sum1 = ((acc >> 64u) + (unsigned __int128)read_le_u64(pad + 8u) + (sum0 >> 64u));
    u64 f1 = (u64)sum1;
    write_le_u64(tag, f0);
    write_le_u64(tag + 8u, f1);
}

static bool chacha20_poly1305_encrypt(const u8* key,
                                      const u8* nonce,
                                      const u8* plaintext,
                                      usize plaintext_length,
                                      const u8* aad,
                                      usize aad_length,
                                      ByteBuffer& ciphertext,
                                      u8 tag[16]) {
    if (!key || !nonce || !tag) {
        return false;
    }
    ciphertext.release();
    if (plaintext_length > 0u && !ciphertext.ensure(plaintext_length)) {
        return false;
    }
    ciphertext.size = plaintext_length;
    if (plaintext_length > 0u && !ciphertext.data) {
        return false;
    }
    u8 initial_block[64];
    chacha20_block(key, nonce, 0u, initial_block);
    if (plaintext_length > 0u) {
        if (!chacha20_xor(key, nonce, 1u, plaintext, ciphertext.data, plaintext_length)) {
            for (u32 i = 0u; i < 64u; ++i) {
                initial_block[i] = 0u;
            }
            return false;
        }
    }
    Poly1305State mac;
    poly1305_init_state(mac, initial_block);
    if (aad && aad_length > 0u) {
        poly1305_update(mac, aad, aad_length);
    }
    poly1305_pad16(mac, aad_length);
    if (plaintext_length > 0u) {
        poly1305_update(mac, ciphertext.data, plaintext_length);
    }
    poly1305_pad16(mac, plaintext_length);
    u8 length_block[16];
    for (u32 i = 0u; i < 16u; ++i) {
        length_block[i] = 0u;
    }
    write_le_u64(length_block, (u64)aad_length);
    write_le_u64(length_block + 8u, (u64)plaintext_length);
    poly1305_process_block(mac, length_block, (1ull << 24u));
    poly1305_finish(mac, initial_block + 16u, tag);
    for (u32 i = 0u; i < 64u; ++i) {
        initial_block[i] = 0u;
    }
    return true;
}

static bool chacha20_poly1305_decrypt(const u8* key,
                                      const u8* nonce,
                                      const u8* ciphertext,
                                      usize ciphertext_length,
                                      const u8* aad,
                                      usize aad_length,
                                      ByteBuffer& plaintext,
                                      const u8 tag[16],
                                      bool* auth_failed) {
    if (!key || !nonce || (!ciphertext && ciphertext_length > 0u) || !tag) {
        return false;
    }
    if (auth_failed) {
        *auth_failed = false;
    }
    plaintext.release();
    u8 initial_block[64];
    chacha20_block(key, nonce, 0u, initial_block);
    Poly1305State mac;
    poly1305_init_state(mac, initial_block);
    if (aad && aad_length > 0u) {
        poly1305_update(mac, aad, aad_length);
    }
    poly1305_pad16(mac, aad_length);
    if (ciphertext_length > 0u) {
        poly1305_update(mac, ciphertext, ciphertext_length);
    }
    poly1305_pad16(mac, ciphertext_length);
    u8 length_block[16];
    for (u32 i = 0u; i < 16u; ++i) {
        length_block[i] = 0u;
    }
    write_le_u64(length_block, (u64)aad_length);
    write_le_u64(length_block + 8u, (u64)ciphertext_length);
    poly1305_process_block(mac, length_block, (1ull << 24u));
    u8 expected_tag[16];
    poly1305_finish(mac, initial_block + 16u, expected_tag);
    bool match = constant_time_equal(expected_tag, tag, ENCRYPTION_TAG_BYTES);
    for (u32 i = 0u; i < 16u; ++i) {
        expected_tag[i] = 0u;
    }
    if (!match) {
        if (auth_failed) {
            *auth_failed = true;
        }
        for (u32 i = 0u; i < 64u; ++i) {
            initial_block[i] = 0u;
        }
        return false;
    }
    if (ciphertext_length > 0u) {
        if (!plaintext.ensure(ciphertext_length)) {
            for (u32 i = 0u; i < 64u; ++i) {
                initial_block[i] = 0u;
            }
            return false;
        }
        plaintext.size = ciphertext_length;
        if (!chacha20_xor(key, nonce, 1u, ciphertext, plaintext.data, ciphertext_length)) {
            plaintext.release();
            for (u32 i = 0u; i < 64u; ++i) {
                initial_block[i] = 0u;
            }
            return false;
        }
    }
    for (u32 i = 0u; i < 64u; ++i) {
        initial_block[i] = 0u;
    }
    return true;
}

enum DecryptStatus {
    DecryptStatus_NotEncrypted = 0,
    DecryptStatus_Success = 1,
    DecryptStatus_AuthFailed = 2,
    DecryptStatus_FormatError = 3
};

static bool encrypt_payload_buffer(const ByteBuffer& plaintext,
                                   const char* password,
                                   usize password_length,
                                   ByteBuffer& output) {
    if (!password || password_length == 0u) {
        return false;
    }
    u8 salt[ENCRYPTION_SALT_BYTES];
    u8 nonce[ENCRYPTION_NONCE_BYTES];
    crypto_random_bytes(salt, ENCRYPTION_SALT_BYTES);
    crypto_random_bytes(nonce, ENCRYPTION_NONCE_BYTES);
    u8 key[32];
    if (!pbkdf2_hmac_sha256((const u8*)password,
                            password_length,
                            salt,
                            ENCRYPTION_SALT_BYTES,
                            ENCRYPTION_PBKDF2_ITERATIONS,
                            key,
                            32u)) {
        for (u32 i = 0u; i < 32u; ++i) {
            key[i] = 0u;
        }
        return false;
    }
    const u8* plain_ptr = plaintext.data;
    usize plain_size = plaintext.size;
    u8 header[ENCRYPTION_HEADER_BYTES];
    for (usize i = 0u; i < ENCRYPTION_HEADER_BYTES; ++i) {
        header[i] = 0u;
    }
    write_le_u32(header, ENCRYPTION_HEADER_MAGIC);
    header[4] = ENCRYPTION_HEADER_VERSION;
    header[5] = ENCRYPTION_FLAG_PASSWORD;
    header[6] = ENCRYPTION_KDF_PBKDF2_SHA256;
    header[7] = 0u;
    write_le_u32(header + 8u, ENCRYPTION_PBKDF2_ITERATIONS);
    write_le_u64(header + 12u, (u64)plain_size);
    for (usize i = 0u; i < ENCRYPTION_SALT_BYTES; ++i) {
        header[20u + i] = salt[i];
    }
    for (usize i = 0u; i < ENCRYPTION_NONCE_BYTES; ++i) {
        header[36u + i] = nonce[i];
    }
    ByteBuffer ciphertext;
    u8 tag[ENCRYPTION_TAG_BYTES];
    if (!chacha20_poly1305_encrypt(key,
                                   nonce,
                                   plain_ptr,
                                   plain_size,
                                   header,
                                   ENCRYPTION_HEADER_BYTES,
                                   ciphertext,
                                   tag)) {
        for (u32 i = 0u; i < 32u; ++i) {
            key[i] = 0u;
        }
        ciphertext.release();
        return false;
    }
    usize total_size = ENCRYPTION_HEADER_BYTES + ciphertext.size + ENCRYPTION_TAG_BYTES;
    output.release();
    if (!output.ensure(total_size)) {
        for (u32 i = 0u; i < 32u; ++i) {
            key[i] = 0u;
        }
        ciphertext.release();
        return false;
    }
    output.size = total_size;
    u8* dest = output.data;
    for (usize i = 0u; i < ENCRYPTION_HEADER_BYTES; ++i) {
        dest[i] = header[i];
    }
    if (ciphertext.size > 0u) {
        for (usize i = 0u; i < ciphertext.size; ++i) {
            dest[ENCRYPTION_HEADER_BYTES + i] = ciphertext.data[i];
        }
    }
    for (usize i = 0u; i < ENCRYPTION_TAG_BYTES; ++i) {
        dest[ENCRYPTION_HEADER_BYTES + ciphertext.size + i] = tag[i];
    }
    ciphertext.release();
    for (u32 i = 0u; i < 32u; ++i) {
        key[i] = 0u;
    }
    return true;
}

static DecryptStatus decrypt_payload_buffer(const u8* data,
                                            usize data_length,
                                            const char* password,
                                            usize password_length,
                                            ByteBuffer& plaintext) {
    plaintext.release();
    if (!data || data_length < ENCRYPTION_HEADER_BYTES + ENCRYPTION_TAG_BYTES) {
        return DecryptStatus_NotEncrypted;
    }
    u32 magic = read_le_u32(data);
    if (magic != ENCRYPTION_HEADER_MAGIC) {
        return DecryptStatus_NotEncrypted;
    }
    if (!password || password_length == 0u) {
        return DecryptStatus_FormatError;
    }
    u8 version = data[4];
    u8 flags = data[5];
    u8 kdf = data[6];
    if (version != ENCRYPTION_HEADER_VERSION || !(flags & ENCRYPTION_FLAG_PASSWORD) || kdf != ENCRYPTION_KDF_PBKDF2_SHA256) {
        return DecryptStatus_FormatError;
    }
    u32 iterations = read_le_u32(data + 8u);
    if (iterations == 0u) {
        return DecryptStatus_FormatError;
    }
    u64 plain_bytes = read_le_u64(data + 12u);
    if (plain_bytes > (u64)USIZE_MAX_VALUE) {
        return DecryptStatus_FormatError;
    }
    const u8* salt = data + 20u;
    const u8* nonce = data + 36u;
    if (data_length < ENCRYPTION_HEADER_BYTES + ENCRYPTION_TAG_BYTES) {
        return DecryptStatus_FormatError;
    }
    usize cipher_bytes = data_length - ENCRYPTION_HEADER_BYTES - ENCRYPTION_TAG_BYTES;
    if ((u64)cipher_bytes != plain_bytes) {
        return DecryptStatus_FormatError;
    }
    const u8* cipher = data + ENCRYPTION_HEADER_BYTES;
    const u8* tag = cipher + cipher_bytes;
    u8 key[32];
    if (!pbkdf2_hmac_sha256((const u8*)password,
                            password_length,
                            salt,
                            ENCRYPTION_SALT_BYTES,
                            iterations,
                            key,
                            32u)) {
        for (u32 i = 0u; i < 32u; ++i) {
            key[i] = 0u;
        }
        return DecryptStatus_FormatError;
    }
    bool auth_failed = false;
    if (!chacha20_poly1305_decrypt(key,
                                   nonce,
                                   cipher,
                                   cipher_bytes,
                                   data,
                                   ENCRYPTION_HEADER_BYTES,
                                   plaintext,
                                   tag,
                                   &auth_failed)) {
        for (u32 i = 0u; i < 32u; ++i) {
            key[i] = 0u;
        }
        plaintext.release();
        if (auth_failed) {
            return DecryptStatus_AuthFailed;
        }
        return DecryptStatus_FormatError;
    }
    if ((u64)plaintext.size != plain_bytes) {
        for (u32 i = 0u; i < 32u; ++i) {
            key[i] = 0u;
        }
        plaintext.release();
        return DecryptStatus_FormatError;
    }
    for (u32 i = 0u; i < 32u; ++i) {
        key[i] = 0u;
    }
    return DecryptStatus_Success;
}

static bool fisher_yates_shuffle(u8* data, usize count) {
    if (!data || count <= 1u) {
        return true;
    }
    Pcg64Generator rng;
    rng.seed(0u);
    for (usize i = count - 1u; i > 0u; --i) {
        u64 value = rng.next();
        usize j = (usize)(value % (u64)(i + 1u));
        u8 temp = data[i];
        data[i] = data[j];
        data[j] = temp;
    }
    return true;
}

static bool fisher_yates_unshuffle(u8* data, usize count) {
    if (!data || count <= 1u) {
        return true;
    }
    if (count > 0u && count > (USIZE_MAX_VALUE / (usize)sizeof(usize))) {
        return false;
    }
    usize* history = (usize*)malloc(sizeof(usize) * (count ? count : 1u));
    if (!history) {
        return false;
    }
    if (count > 0u) {
        history[0] = 0u;
    }
    Pcg64Generator rng;
    rng.seed(0u);
    for (usize i = count - 1u; i > 0u; --i) {
        u64 value = rng.next();
        usize j = (usize)(value % (u64)(i + 1u));
        history[i] = j;
    }
    for (usize i = 1u; i < count; ++i) {
        usize j = history[i];
        u8 temp = data[i];
        data[i] = data[j];
        data[j] = temp;
    }
    free(history);
    return true;
}

static bool shuffle_encoded_stream(u8* data, usize byte_count, bool ecc_enabled);
static bool unshuffle_encoded_stream(u8* data, usize byte_count);

struct BitWriter {
    ByteBuffer buffer;
    usize bit_position;
    bool  failed;

    BitWriter() : buffer(), bit_position(0u), failed(false) {}

    ~BitWriter() {
        reset();
    }

    void reset() {
        buffer.release();
        bit_position = 0u;
        failed = false;
    }

    bool ensure_bits(usize target_bits) {
        usize target_bytes = (target_bits + 7u) >> 3u;
        return buffer.ensure(target_bytes);
    }

    bool write_bit(u8 value) {
        if (failed) {
            return false;
        }
        if (!ensure_bits(bit_position + 1u)) {
            failed = true;
            return false;
        }
        usize byte_index = bit_position >> 3u;
        usize bit_offset = bit_position & 7u;
        u8 mask = (u8)(1u << bit_offset);
        if (byte_index >= buffer.size) {
            if (!buffer.push(0u)) {
                failed = true;
                return false;
            }
        }
        if (value & 1u) {
            buffer.data[byte_index] = (u8)(buffer.data[byte_index] | mask);
        } else {
            buffer.data[byte_index] = (u8)(buffer.data[byte_index] & (u8)(~mask));
        }
        ++bit_position;
        return true;
    }

    bool write_bits(u64 value, usize count) {
        if (count > 64u) {
            count = 64u;
        }
        for (usize i = 0; i < count; ++i) {
            u8 bit = (u8)((value >> i) & 1u);
            if (!write_bit(bit)) {
                return false;
            }
        }
        return true;
    }

    bool align_to_byte() {
        usize remainder = bit_position & 7u;
        if (!remainder) {
            return true;
        }
        usize missing = 8u - remainder;
        for (usize i = 0; i < missing; ++i) {
            if (!write_bit(0u)) {
                return false;
            }
        }
        return true;
    }

    const u8* data() const {
        return buffer.data;
    }

    usize bit_size() const {
        return bit_position;
    }

    usize byte_size() const {
        return (bit_position + 7u) >> 3u;
    }
};

struct BitReader {
    const u8* data;
    usize bit_count;
    usize cursor;
    bool failed;

    BitReader() : data(0), bit_count(0u), cursor(0u), failed(false) {}

    void reset(const u8* source, usize bits) {
        data = source;
        bit_count = bits;
        cursor = 0u;
        failed = false;
    }

    u8 read_bit() {
        if (!data || cursor >= bit_count) {
            failed = true;
            return 0u;
        }
        usize byte_index = cursor >> 3u;
        usize bit_offset = cursor & 7u;
        ++cursor;
        return (u8)((data[byte_index] >> bit_offset) & 1u);
    }

    u64 read_bits(usize count) {
        if (count > 64u) {
            count = 64u;
        }
        u64 result = 0u;
        for (usize i = 0; i < count; ++i) {
            u8 bit = read_bit();
            result |= ((u64)bit) << i;
        }
        return result;
    }

    bool align_to_byte() {
        usize remainder = cursor & 7u;
        if (!remainder) {
            return true;
        }
        if ((cursor + (8u - remainder)) > bit_count) {
            failed = true;
            return false;
        }
        cursor += (8u - remainder);
        return true;
    }
};

static const usize LZMA_HEADER_BYTES = (usize)LZMA_PROPS_SIZE + 8u;

static bool lzma_compress(const u8* input, usize length, ByteBuffer& output) {
    output.release();
    if (!input && length > 0u) {
        return false;
    }
    if (length > (usize)SIZE_MAX) {
        return false;
    }
    const u8 zero = 0u;
    const u8* source = (length > 0u) ? input : &zero;
    usize header = LZMA_HEADER_BYTES;
    usize extra = (length / 16u) + 65536u + 64u;
    usize baseline = header;
    if (USIZE_MAX_VALUE - baseline < length) {
        return false;
    }
    baseline += length;
    if (USIZE_MAX_VALUE - baseline < extra) {
        baseline = USIZE_MAX_VALUE;
    } else {
        baseline += extra;
    }
    if (baseline < header + 1024u) {
        baseline = header + 1024u;
    }
    if (!output.ensure(baseline)) {
        return false;
    }
    size_t props_size = LZMA_PROPS_SIZE;
    u8 props[LZMA_PROPS_SIZE];
    while (true) {
        if (output.capacity < header + 1u) {
            if (!output.ensure(header + 1u)) {
                return false;
            }
        }
        if (output.capacity < header) {
            return false;
        }
        usize avail_usize = output.capacity - header;
        if (avail_usize > (usize)SIZE_MAX) {
            return false;
        }
        size_t available = (size_t)avail_usize;
        if (available == 0u) {
            usize grow = output.capacity + 1024u;
            if (grow <= output.capacity || grow > USIZE_MAX_VALUE) {
                grow = USIZE_MAX_VALUE;
            }
            if (!output.ensure(grow)) {
                return false;
            }
            continue;
        }
        size_t dest_len = available;
        size_t src_len = (size_t)length;
        props_size = LZMA_PROPS_SIZE;
        int status = LzmaCompress(output.data + header,
                                  &dest_len,
                                  source,
                                  src_len,
                                  props,
                                  &props_size,
                                  9,
                                  (1u << 27),
                                  3,
                                  0,
                                  2,
                                  273,
                                  2);
        if (status == SZ_OK) {
            for (usize i = 0u; i < (usize)LZMA_PROPS_SIZE; ++i) {
                output.data[i] = props[i];
            }
            write_le_u64(output.data + LZMA_PROPS_SIZE, (u64)length);
            output.size = header + dest_len;
            return true;
        }
        if (status != SZ_ERROR_OUTPUT_EOF) {
            return false;
        }
        usize new_capacity = output.capacity ? (output.capacity * 2u) : (header + 1024u);
        if (new_capacity <= output.capacity || new_capacity > USIZE_MAX_VALUE) {
            if (output.capacity >= USIZE_MAX_VALUE) {
                return false;
            }
            usize delta = (output.capacity / 2u) + 1024u;
            if (USIZE_MAX_VALUE - output.capacity < delta) {
                new_capacity = USIZE_MAX_VALUE;
            } else {
                new_capacity = output.capacity + delta;
            }
        }
        if (!output.reserve(new_capacity)) {
            return false;
        }
    }
    return false;
}

static bool lzma_decompress(const u8* input,
                            usize bit_count,
                            ByteBuffer& output) {
    output.release();
    if (!input) {
        return (bit_count == 0u);
    }
    if (bit_count == 0u) {
        return true;
    }
    if (bit_count & 7u) {
        return false;
    }
    usize byte_count = bit_count >> 3u;
    if (byte_count < LZMA_HEADER_BYTES) {
        return false;
    }
    u64 original = read_le_u64(input + LZMA_PROPS_SIZE);
    if (original > (u64)USIZE_MAX_VALUE) {
        return false;
    }
    usize output_size = (usize)original;
    usize required = output_size ? output_size : 1u;
    if (required > (usize)SIZE_MAX) {
        return false;
    }
    if (!output.ensure(required)) {
        return false;
    }
    size_t dest_len = (size_t)output_size;
    usize payload_bytes = byte_count - LZMA_HEADER_BYTES;
    if (payload_bytes > (usize)SIZE_MAX) {
        return false;
    }
    SizeT src_len = (SizeT)payload_bytes;
    const u8* src = input + LZMA_HEADER_BYTES;
    if (!output.data && required > 0u) {
        return false;
    }
    SRes status = LzmaUncompress(output.data,
                                 &dest_len,
                                 src,
                                 &src_len,
                                 input,
                                 LZMA_PROPS_SIZE);
    if (status != SZ_OK) {
        return false;
    }
    if (dest_len != (size_t)output_size) {
        return false;
    }
    output.size = output_size;
    return true;
}


struct EncoderConfig {
    u32 metadata_key_count;
    u32 fiducial_density;
    double ecc_redundancy;
    u32 max_parallelism;

    EncoderConfig()
        : metadata_key_count(0u),
          fiducial_density(0u),
          ecc_redundancy(0.0),
          max_parallelism(1u) {}
};

struct EccSummary {
    bool enabled;
    u16 block_data_symbols;
    u16 parity_symbols;
    double redundancy;
    u64 original_bytes;
    u64 block_count;

    EccSummary()
        : enabled(false),
          block_data_symbols(0u),
          parity_symbols(0u),
          redundancy(0.0),
          original_bytes(0u),
          block_count(0u) {}
};

struct EccDecodeStats {
    u64 corrected_symbols;
    u64 total_parity_symbols;
    u64 total_blocks;
    u64 blocks_with_errors;
    u64 header_copy_repairs;

    EccDecodeStats()
        : corrected_symbols(0u),
          total_parity_symbols(0u),
          total_blocks(0u),
          blocks_with_errors(0u),
          header_copy_repairs(0u) {}
};

static bool encode_payload_with_ecc(const ByteBuffer& compressed,
                                    double redundancy,
                                    BitWriter& writer,
                                    EccSummary& summary);

struct EncoderContext {
    EncoderConfig config;
    ByteBuffer payload_bytes;
    BitWriter bit_writer;
    ByteBuffer encryption_password;
    bool configured;
    bool encryption_enabled;

    EccSummary ecc_summary;

    EncoderContext()
        : config(),
          payload_bytes(),
          bit_writer(),
          encryption_password(),
          configured(false),
          encryption_enabled(false),
          ecc_summary() {}

    ~EncoderContext() {
        reset();
    }

    void reset() {
        payload_bytes.release();
        bit_writer.reset();
        encryption_password.release();
        configured = false;
        encryption_enabled = false;
        ecc_summary = EccSummary();
    }

    bool set_payload(const u8* data, usize size) {
        payload_bytes.release();
        if (!payload_bytes.ensure(size)) {
            return false;
        }
        for (usize i = 0; i < size; ++i) {
            payload_bytes.data[i] = data[i];
        }
        payload_bytes.size = size;
        return true;
    }

    bool set_password(const char* password, usize length) {
        encryption_password.release();
        encryption_enabled = false;
        if (!password || length == 0u) {
            return true;
        }
        if (!encryption_password.ensure(length)) {
            return false;
        }
        for (usize i = 0u; i < length; ++i) {
            encryption_password.data[i] = (u8)password[i];
        }
        encryption_password.size = length;
        encryption_enabled = true;
        return true;
    }

    bool encode_payload(ByteBuffer& output) {
        output.release();
        return lzma_compress(payload_bytes.data, payload_bytes.size, output);
    }

    bool build() {
        bit_writer.reset();
        ecc_summary = EccSummary();
        ByteBuffer compressed;
        if (!encode_payload(compressed)) {
            return false;
        }
        const ByteBuffer* payload_source = &compressed;
        ByteBuffer encrypted;
        if (encryption_enabled && encryption_password.size > 0u) {
            if (!encrypt_payload_buffer(compressed, (const char*)encryption_password.data, encryption_password.size, encrypted)) {
                return false;
            }
            payload_source = &encrypted;
        }
        double redundancy = (config.ecc_redundancy > 0.0) ? config.ecc_redundancy : 0.0;
        if (redundancy > 0.0) {
            if (payload_source->size > 0u) {
                if (!encode_payload_with_ecc(*payload_source, redundancy, bit_writer, ecc_summary)) {
                    return false;
                }
            } else {
                ecc_summary = EccSummary();
            }
        } else {
            for (usize i = 0u; i < payload_source->size; ++i) {
                u8 byte = payload_source->data ? payload_source->data[i] : 0u;
                if (!bit_writer.write_bits((u64)byte, 8u)) {
                    return false;
                }
            }
            if (payload_source->size == 0u) {
                ecc_summary = EccSummary();
            }
            ecc_summary.original_bytes = payload_source->size;
            ecc_summary.redundancy = 0.0;
            ecc_summary.block_count = 0u;
            ecc_summary.block_data_symbols = 0u;
            ecc_summary.parity_symbols = 0u;
            ecc_summary.enabled = false;
        }
        if (!bit_writer.align_to_byte()) {
            return false;
        }
        usize total_bytes = bit_writer.byte_size();
        if (total_bytes > 0u) {
            u8* stream = bit_writer.buffer.data;
            if (!stream) {
                return false;
            }
            if (!shuffle_encoded_stream(stream, total_bytes, ecc_summary.enabled)) {
                return false;
            }
        }
        configured = true;
        return true;
    }

    const EccSummary& ecc_info() const {
        return ecc_summary;
    }
};

static const u16 RS_FIELD_PRIMITIVE = 0x11d;
static const u16 RS_FIELD_SIZE = 255u;
static const usize RS_POLY_CAPACITY = 256u;

static const u16 ECC_HEADER_MAGIC = 0x4543u;
static const u8  ECC_HEADER_VERSION = 1u;
static const usize ECC_HEADER_BITS = 208u;
static const usize ECC_HEADER_BYTES = ECC_HEADER_BITS / 8u;
static const usize ECC_HEADER_COPY_COUNT = 3u;
static const usize ECC_HEADER_COPY_DATA_BYTES = ECC_HEADER_BYTES;
static const usize ECC_HEADER_COPY_PARITY_BYTES = 6u;
static const usize ECC_HEADER_COPY_TOTAL_BYTES = ECC_HEADER_COPY_DATA_BYTES + ECC_HEADER_COPY_PARITY_BYTES;
static const usize ECC_HEADER_COPY_TOTAL_BITS = ECC_HEADER_COPY_TOTAL_BYTES * 8u;
static const usize ECC_HEADER_TOTAL_BITS = ECC_HEADER_COPY_TOTAL_BITS * ECC_HEADER_COPY_COUNT;
static const usize ECC_HEADER_TOTAL_BYTES = ECC_HEADER_COPY_TOTAL_BYTES * ECC_HEADER_COPY_COUNT;
static const u16 ECC_HEADER_COPY_DATA_SYMBOLS = (u16)ECC_HEADER_COPY_DATA_BYTES;
static const u16 ECC_HEADER_COPY_PARITY_SYMBOLS = (u16)ECC_HEADER_COPY_PARITY_BYTES;

struct EccHeader {
    u16 magic;
    u8 version;
    u8 flags;
    u16 block_data;
    u16 parity;
    u16 reserved;
    u64 block_count;
    u64 original_bytes;

    EccHeader()
        : magic(ECC_HEADER_MAGIC),
          version(ECC_HEADER_VERSION),
          flags(0x01u),
          block_data(0u),
          parity(0u),
          reserved(0u),
          block_count(0u),
          original_bytes(0u) {}

    bool serialize(u8* dest) const {
        if (!dest) {
            return false;
        }
        dest[0] = (u8)(magic & 0xFFu);
        dest[1] = (u8)((magic >> 8u) & 0xFFu);
        dest[2] = version;
        dest[3] = flags;
        write_le_u16(dest + 4u, block_data);
        write_le_u16(dest + 6u, parity);
        write_le_u16(dest + 8u, reserved);
        write_le_u64(dest + 10u, block_count);
        write_le_u64(dest + 18u, original_bytes);
        return true;
    }

    bool write(BitWriter& writer) const {
        if (!writer.write_bits((u64)magic, 16u)) {
            return false;
        }
        if (!writer.write_bits((u64)version, 8u)) {
            return false;
        }
        if (!writer.write_bits((u64)flags, 8u)) {
            return false;
        }
        if (!writer.write_bits((u64)block_data, 16u)) {
            return false;
        }
        if (!writer.write_bits((u64)parity, 16u)) {
            return false;
        }
        if (!writer.write_bits((u64)reserved, 16u)) {
            return false;
        }
        if (!writer.write_bits(block_count, 64u)) {
            return false;
        }
        if (!writer.write_bits(original_bytes, 64u)) {
            return false;
        }
        return true;
    }

    static bool parse(const u8* bytes, usize length, EccHeader& header) {
        if (!bytes || length < ECC_HEADER_BYTES) {
            return false;
        }
        header.magic = read_le_u16(bytes);
        header.version = bytes[2];
        header.flags = bytes[3];
        header.block_data = read_le_u16(bytes + 4u);
        header.parity = read_le_u16(bytes + 6u);
        header.reserved = read_le_u16(bytes + 8u);
        header.block_count = read_le_u64(bytes + 10u);
        header.original_bytes = read_le_u64(bytes + 18u);
        if (header.magic != ECC_HEADER_MAGIC) {
            return false;
        }
        if (header.version != ECC_HEADER_VERSION) {
            return false;
        }
        if (!(header.flags & 0x01u)) {
            return false;
        }
        if (header.block_data == 0u || header.parity == 0u) {
            return false;
        }
        if (header.block_data >= RS_FIELD_SIZE || header.parity >= RS_FIELD_SIZE) {
            return false;
        }
        if ((u32)header.block_data + header.parity > RS_FIELD_SIZE) {
            return false;
        }
        if (header.block_count == 0u) {
            return false;
        }
        if (header.original_bytes > (u64)USIZE_MAX_VALUE) {
            return false;
        }
        return true;
    }
};

static bool header_copy_data_equal(const u8* left, const u8* right) {
    if (!left || !right) {
        return false;
    }
    for (usize i = 0u; i < ECC_HEADER_COPY_DATA_BYTES; ++i) {
        if (left[i] != right[i]) {
            return false;
        }
    }
    return true;
}

static bool build_protected_header_copy(const EccHeader& header, u8* out_copy);
static bool rs_decode_block(u8* block,
                            u16 data_symbols,
                            u16 parity_symbols,
                            u16* corrected_errors);

static bool reconstruct_ecc_header_copies(const u8* bytes,
                                          usize byte_count,
                                          EccHeader& header,
                                          u32& repaired_copies,
                                          u32& success_count) {
    if (!bytes || byte_count < ECC_HEADER_TOTAL_BYTES) {
        return false;
    }
    repaired_copies = 0u;
    success_count = 0u;
    u8 decoded[ECC_HEADER_COPY_COUNT][ECC_HEADER_COPY_DATA_BYTES];
    bool valid[ECC_HEADER_COPY_COUNT] = {false, false, false};
    u8 buffer[RS_POLY_CAPACITY];
    for (usize copy_index = 0u; copy_index < ECC_HEADER_COPY_COUNT; ++copy_index) {
        usize offset = copy_index * ECC_HEADER_COPY_TOTAL_BYTES;
        if (offset + ECC_HEADER_COPY_TOTAL_BYTES > byte_count) {
            continue;
        }
        for (usize i = 0u; i < ECC_HEADER_COPY_TOTAL_BYTES; ++i) {
            buffer[i] = bytes[offset + i];
        }
        u16 corrections = 0u;
        if (!rs_decode_block(buffer,
                             ECC_HEADER_COPY_DATA_SYMBOLS,
                             ECC_HEADER_COPY_PARITY_SYMBOLS,
                             &corrections)) {
            continue;
        }
        valid[copy_index] = true;
        ++success_count;
        if (corrections > 0u) {
            ++repaired_copies;
            if (debug_logging_enabled()) {
                char index_buffer[32];
                char corrected_buffer[32];
                u64_to_ascii((u64)copy_index + 1u, index_buffer, sizeof(index_buffer));
                u64_to_ascii((u64)corrections, corrected_buffer, sizeof(corrected_buffer));
                console_write(2, "debug parse: ECC header copy ");
                console_write(2, index_buffer);
                console_write(2, " repaired ");
                console_write(2, corrected_buffer);
                console_line(2, " symbol(s)");
            }
        }
        for (usize i = 0u; i < ECC_HEADER_COPY_DATA_BYTES; ++i) {
            decoded[copy_index][i] = buffer[i];
        }
    }
    if (debug_logging_enabled() && success_count > 0u) {
        char success_buffer[32];
        char repaired_buffer[32];
        char copy_buffer[32];
        u64_to_ascii((u64)success_count, success_buffer, sizeof(success_buffer));
        u64_to_ascii((u64)repaired_copies, repaired_buffer, sizeof(repaired_buffer));
        console_write(2, "debug parse: header copies validity=");
        for (usize copy_index = 0u; copy_index < ECC_HEADER_COPY_COUNT; ++copy_index) {
            u64_to_ascii(valid[copy_index] ? 1u : 0u, copy_buffer, sizeof(copy_buffer));
            console_write(2, copy_buffer);
            if (copy_index + 1u < ECC_HEADER_COPY_COUNT) {
                console_write(2, "/");
            }
        }
        console_write(2, " successes=");
        console_write(2, success_buffer);
        console_write(2, " repairs=");
        console_write(2, repaired_buffer);
        console_line(2, "");
    }
    int chosen_index = -1;
    auto copies_equal = [&](usize a, usize b) -> bool {
        if (!valid[a] || !valid[b]) {
            return false;
        }
        return header_copy_data_equal(decoded[a], decoded[b]);
    };
    if (copies_equal(0u, 1u)) {
        chosen_index = 0;
    } else if (copies_equal(0u, 2u)) {
        chosen_index = 0;
    } else if (copies_equal(1u, 2u)) {
        chosen_index = 1;
    } else if (valid[0u]) {
        chosen_index = 0;
    } else if (valid[1u]) {
        chosen_index = 1;
    } else if (valid[2u]) {
        chosen_index = 2;
    } else {
        return false;
    }
    if (success_count > 1u && debug_logging_enabled()) {
        bool discrepancy = false;
        for (usize i = 0u; i < ECC_HEADER_COPY_COUNT; ++i) {
            if ((int)i == chosen_index) {
                continue;
            }
            if (valid[i] && !copies_equal((usize)chosen_index, i)) {
                discrepancy = true;
                break;
            }
        }
        if (discrepancy) {
            char index_buffer[32];
            u64_to_ascii((u64)chosen_index + 1u, index_buffer, sizeof(index_buffer));
            console_write(2, "debug parse: ECC header copies disagree; using copy ");
            console_write(2, index_buffer);
            console_line(2, "");
        }
    }
    if (debug_logging_enabled()) {
        char success_buffer[32];
        char repaired_buffer[32];
        u64_to_ascii((u64)success_count, success_buffer, sizeof(success_buffer));
        u64_to_ascii((u64)repaired_copies, repaired_buffer, sizeof(repaired_buffer));
        console_write(2, "debug parse: header reconstruction successes=");
        console_write(2, success_buffer);
        console_write(2, " repairs=");
        console_write(2, repaired_buffer);
        console_line(2, "");
    }
    return EccHeader::parse(decoded[chosen_index], ECC_HEADER_COPY_DATA_BYTES, header);
}

struct ReedSolomonTables {
    bool initialized;
    u8 exp_table[512];
    u8 log_table[256];
};

static ReedSolomonTables g_rs_tables;

static void rs_ensure_tables() {
    if (g_rs_tables.initialized) {
        return;
    }
    u16 value = 1u;
    for (u16 i = 0u; i < RS_FIELD_SIZE; ++i) {
        u8 element = (u8)(value & 0xFFu);
        g_rs_tables.exp_table[i] = element;
        g_rs_tables.log_table[element] = (u8)i;
        value <<= 1u;
        if (value & 0x100u) {
            value ^= (u16)RS_FIELD_PRIMITIVE;
        }
    }
    for (u16 i = RS_FIELD_SIZE; i < 512u; ++i) {
        g_rs_tables.exp_table[i] = g_rs_tables.exp_table[i - RS_FIELD_SIZE];
    }
    g_rs_tables.log_table[0] = 0u;
    g_rs_tables.initialized = true;
}

static inline u8 gf_mul(u8 a, u8 b) {
    if (!a || !b) {
        return 0u;
    }
    rs_ensure_tables();
    u16 log_sum = (u16)g_rs_tables.log_table[a] + (u16)g_rs_tables.log_table[b];
    return g_rs_tables.exp_table[log_sum % RS_FIELD_SIZE];
}

static inline u8 gf_div(u8 a, u8 b) {
    if (!b) {
        return 0u;
    }
    if (!a) {
        return 0u;
    }
    rs_ensure_tables();
    u16 log_a = g_rs_tables.log_table[a];
    u16 log_b = g_rs_tables.log_table[b];
    u16 diff = (u16)((log_a + RS_FIELD_SIZE - log_b) % RS_FIELD_SIZE);
    return g_rs_tables.exp_table[diff];
}



static inline u8 gf_pow_alpha(u32 power) {
    rs_ensure_tables();
    power %= RS_FIELD_SIZE;
    return g_rs_tables.exp_table[power];
}

static u16 poly_trim(u8* poly, u16 length) {
    while (length > 0u && poly[length - 1u] == 0u) {
        --length;
    }
    return length;
}

static u16 poly_scale_shift_add(u8* target,
                                u16 target_size,
                                const u8* source,
                                u16 source_size,
                                u8 scale,
                                u16 shift) {
    if (!scale || !source || source_size == 0u) {
        return target_size;
    }
    u16 required = (u16)(source_size + shift);
    if (required > RS_POLY_CAPACITY) {
        required = (u16)RS_POLY_CAPACITY;
    }
    if (target_size < required) {
        for (u16 i = target_size; i < required; ++i) {
            target[i] = 0u;
        }
        target_size = required;
    }
    for (u16 i = 0u; i < source_size; ++i) {
        u16 index = (u16)(i + shift);
        if (index >= RS_POLY_CAPACITY) {
            break;
        }
        target[index] ^= gf_mul(source[i], scale);
    }
    return target_size;
}

static bool rs_build_generator(u16 parity_symbols, u8* generator, u16& out_length) {
    if (!generator || parity_symbols == 0u || parity_symbols >= RS_FIELD_SIZE) {
        return false;
    }
    rs_ensure_tables();
    for (usize i = 0u; i < RS_POLY_CAPACITY; ++i) {
        generator[i] = 0u;
    }
    generator[0] = 1u;
    u16 length = 1u;
    for (u16 i = 0u; i < parity_symbols; ++i) {
        u8 root = gf_pow_alpha((u32)(i + 1u));
        u8 temp[RS_POLY_CAPACITY];
        for (u16 j = 0u; j < RS_POLY_CAPACITY; ++j) {
            temp[j] = 0u;
        }
        for (u16 j = 0u; j < length; ++j) {
            u8 coeff = generator[j];
            temp[j] ^= coeff;
            u16 index = (u16)(j + 1u);
            if (index < RS_POLY_CAPACITY) {
                temp[index] ^= gf_mul(coeff, root);
            }
        }
        ++length;
        if (length > RS_POLY_CAPACITY) {
            return false;
        }
        for (u16 j = 0u; j < length; ++j) {
            generator[j] = temp[j];
        }
    }
    out_length = length;
    return true;
}

static void rs_compute_parity(const u8* generator,
                              u16 parity_symbols,
                              const u8* data_symbols,
                              u16 data_length,
                              u8* parity_out) {
    if (!generator || !parity_out || parity_symbols == 0u) {
        return;
    }
    for (u16 i = 0u; i < parity_symbols; ++i) {
        parity_out[i] = 0u;
    }
    for (u16 i = 0u; i < data_length; ++i) {
        u8 feedback = data_symbols ? data_symbols[i] : 0u;
        feedback ^= parity_out[0];
        if (parity_symbols > 1u) {
            for (u16 j = 0u; j < (parity_symbols - 1u); ++j) {
                parity_out[j] = parity_out[j + 1u];
            }
        }
        parity_out[parity_symbols - 1u] = 0u;
        if (!feedback) {
            continue;
        }
        for (u16 j = 0u; j < parity_symbols; ++j) {
            u8 coeff = generator[j + 1u];
            if (coeff) {
                parity_out[j] ^= gf_mul(coeff, feedback);
            }
        }
    }
}

static bool build_protected_header_copy(const EccHeader& header, u8* out_copy) {
    if (!out_copy) {
        return false;
    }
    if (!header.serialize(out_copy)) {
        return false;
    }
    u8 generator[RS_POLY_CAPACITY];
    u16 generator_size = 0u;
    if (!rs_build_generator(ECC_HEADER_COPY_PARITY_SYMBOLS, generator, generator_size)) {
        return false;
    }
    (void)generator_size;
    rs_compute_parity(generator,
                      ECC_HEADER_COPY_PARITY_SYMBOLS,
                      out_copy,
                      (u16)ECC_HEADER_COPY_DATA_BYTES,
                      out_copy + ECC_HEADER_COPY_DATA_BYTES);
    return true;
}

static usize ecc_header_span_for_bytes(usize byte_count) {
    if (byte_count >= ECC_HEADER_TOTAL_BYTES) {
        return ECC_HEADER_TOTAL_BYTES;
    }
    return byte_count;
}

static bool rs_compute_syndromes(const u8* codeword,
                                 u16 codeword_length,
                                 u16 parity_symbols,
                                 u8* syndromes,
                                 bool& all_zero) {
    if (!codeword || !syndromes || parity_symbols == 0u || codeword_length == 0u) {
        return false;
    }
    all_zero = true;
    for (u16 i = 0u; i < parity_symbols; ++i) {
        u8 evaluation = 0u;
        u8 root = gf_pow_alpha(i + 1u);
        for (u16 j = 0u; j < codeword_length; ++j) {
            evaluation = gf_mul(evaluation, root) ^ codeword[j];
        }
        syndromes[i] = evaluation;
        if (evaluation) {
            all_zero = false;
        }
    }
    return true;
}

static bool rs_berlekamp_massey(const u8* syndromes,
                                u16 parity_symbols,
                                u8* locator,
                                u16& locator_size) {
    if (!syndromes || !locator) {
        return false;
    }
    u8 C[RS_POLY_CAPACITY];
    u8 B[RS_POLY_CAPACITY];
    for (u16 i = 0u; i < RS_POLY_CAPACITY; ++i) {
        C[i] = 0u;
        B[i] = 0u;
    }
    C[0] = 1u;
    B[0] = 1u;
    u16 C_size = 1u;
    u16 B_size = 1u;
    u16 L = 0u;
    u16 m = 1u;
    u8 b = 1u;
    for (u16 n = 0u; n < parity_symbols; ++n) {
        u8 delta = syndromes[n];
        for (u16 i = 1u; i <= L; ++i) {
            if (i >= C_size) {
                break;
            }
            u8 c = C[i];
            u8 s = syndromes[n - i];
            if (c && s) {
                delta ^= gf_mul(c, s);
            }
        }
        if (delta) {
            u8 T[RS_POLY_CAPACITY];
            u16 T_size = C_size;
            for (u16 i = 0u; i < RS_POLY_CAPACITY; ++i) {
                T[i] = C[i];
            }
            u8 factor = gf_div(delta, b);
            C_size = poly_scale_shift_add(C, C_size, B, B_size, factor, m);
            if ((2u * L) <= n) {
                L = (u16)(n + 1u - L);
                for (u16 i = 0u; i < RS_POLY_CAPACITY; ++i) {
                    B[i] = T[i];
                }
                B_size = T_size;
                b = delta;
                m = 1u;
            } else {
                ++m;
            }
        } else {
            ++m;
        }
    }
    for (u16 i = 0u; i < C_size; ++i) {
        locator[i] = C[i];
    }
    locator_size = poly_trim(locator, C_size);
    return (locator_size > 0u);
}

static u8 poly_eval(const u8* poly, u16 length, u8 x) {
    if (!poly || length == 0u) {
        return 0u;
    }
    u8 result = 0u;
    for (u16 i = length; i > 0u; --i) {
        result = gf_mul(result, x) ^ poly[i - 1u];
    }
    return result;
}


static i64 g_rs_debug_block_index = -1;

static void rs_debug_failure(const char* reason,
                             u16 data_symbols,
                             u16 parity_symbols) {
    if (!reason || !debug_logging_enabled() || g_rs_debug_block_index < 0) {
        return;
    }
    char block_buffer[32];
    char data_buffer[32];
    char parity_buffer[32];
    u64_to_ascii((u64)g_rs_debug_block_index, block_buffer, sizeof(block_buffer));
    u64_to_ascii((u64)data_symbols, data_buffer, sizeof(data_buffer));
    u64_to_ascii((u64)parity_symbols, parity_buffer, sizeof(parity_buffer));
    console_write(2, "debug rs: block=");
    console_write(2, block_buffer);
    console_write(2, " data=");
    console_write(2, data_buffer);
    console_write(2, " parity=");
    console_write(2, parity_buffer);
    console_write(2, " reason=");
    console_line(2, reason);
}

static bool rs_find_error_locations(const u8* locator,
                                    u16 locator_size,
                                    u16 codeword_length,
                                    u16 exponent_offset,
                                    u16* positions,
                                    u16& position_count,
                                    u16 data_symbols,
                                    u16 parity_symbols) {
    if (!locator || !positions || locator_size <= 1u) {
        return false;
    }
    position_count = 0u;
    for (u16 pos = 0u; pos < codeword_length; ++pos) {
        u32 exponent = (u32)pos + 1u + (u32)exponent_offset;
        u8 x = gf_pow_alpha(exponent);
        if (poly_eval(locator, locator_size, x) == 0u) {
            if (position_count >= (locator_size - 1u)) {
                rs_debug_failure("locations-overflow", data_symbols, parity_symbols);
                return false;
            }
            positions[position_count++] = pos;
        }
    }
    if (position_count != (locator_size - 1u)) {
        rs_debug_failure("locations-mismatch", data_symbols, parity_symbols);
        // When we discover a plausible subset of roots, continue with the located
        // positions instead of bailing out. This salvages heavily corrupted blocks
        // where the locator polynomial has repeated roots but we still have room
        // to correct within the available parity budget.
        if (position_count == 0u || position_count > parity_symbols) {
            return false;
        }
    }
    return true;
}

static u16 rs_compute_error_evaluator(const u8* locator,
                                      u16 locator_size,
                                      const u8* syndromes,
                                      u16 parity_symbols,
                                      u8* evaluator) {
    for (u16 i = 0u; i < parity_symbols; ++i) {
        evaluator[i] = 0u;
    }
    for (u16 i = 0u; i < locator_size; ++i) {
        u8 coeff = locator[i];
        if (!coeff) {
            continue;
        }
        for (u16 j = 0u; j < parity_symbols; ++j) {
            u16 index = (u16)(i + j);
            if (index >= parity_symbols) {
                break;
            }
            evaluator[index] ^= gf_mul(coeff, syndromes[j]);
        }
    }
    return poly_trim(evaluator, parity_symbols);
}

static u16 rs_compute_locator_derivative(const u8* locator,
                                         u16 locator_size,
                                         u8* derivative) {
    if (!locator || !derivative || locator_size <= 1u) {
        return 0u;
    }
    u16 size = locator_size - 1u;
    for (u16 i = 0u; i < size; ++i) {
        derivative[i] = 0u;
    }
    for (u16 i = 1u; i < locator_size; ++i) {
        if (i & 1u) {
            derivative[i - 1u] = locator[i];
        }
    }
    return poly_trim(derivative, size);
}

static bool rs_correct_errors(u8* codeword,
                              u16 codeword_length,
                              u16 exponent_offset,
                              const u8* omega,
                              u16 omega_size,
                              const u8* locator_derivative,
                              u16 derivative_size,
                              const u16* positions,
                              u16 position_count) {
    if (!codeword || !omega || !locator_derivative || !positions) {
        return false;
    }
    if (debug_logging_enabled() && g_rs_debug_block_index >= 0 && position_count > 0u) {
        console_write(2, "debug rs: correcting block=");
        char block_buffer[32];
        u64_to_ascii((u64)g_rs_debug_block_index, block_buffer, sizeof(block_buffer));
        console_write(2, block_buffer);
        console_write(2, " positions=");
        for (u16 i = 0u; i < position_count; ++i) {
            char pos_buffer[32];
            u64_to_ascii((u64)positions[i], pos_buffer, sizeof(pos_buffer));
            console_write(2, pos_buffer);
            if ((i + 1u) < position_count) {
                console_write(2, ",");
            }
        }
        console_line(2, "");
    }
    for (u16 i = 0u; i < position_count; ++i) {
        u16 pos = positions[i];
        if (pos >= codeword_length) {
            return false;
        }
        u16 exponent = (u16)((pos + 1u + exponent_offset) % RS_FIELD_SIZE);
        u8 root = gf_pow_alpha(exponent);
        u8 numerator = poly_eval(omega, omega_size, root);
        u8 denominator = poly_eval(locator_derivative, derivative_size, root);
        if (!denominator) {
            return false;
        }
        u8 magnitude = gf_div(numerator, denominator);
        codeword[pos] ^= magnitude;
    }
    return true;
}



static bool rs_decode_block(u8* block,
                            u16 data_symbols,
                            u16 parity_symbols,
                            u16* corrected_errors) {
    if (corrected_errors) {
        *corrected_errors = 0u;
    }
    if (!block || parity_symbols == 0u || data_symbols == 0u) {
        rs_debug_failure("invalid-params", data_symbols, parity_symbols);
        return false;
    }
    u16 codeword_length = (u16)(data_symbols + parity_symbols);
    if (codeword_length > RS_FIELD_SIZE) {
        rs_debug_failure("codeword-length", data_symbols, parity_symbols);
        return false;
    }
    u8 syndromes[RS_POLY_CAPACITY];
    bool all_zero = false;
    if (!rs_compute_syndromes(block, codeword_length, parity_symbols, syndromes, all_zero)) {
        rs_debug_failure("syndromes", data_symbols, parity_symbols);
        return false;
    }
    if (all_zero) {
        return true;
    }
    u8 locator[RS_POLY_CAPACITY];
    for (u16 i = 0u; i < RS_POLY_CAPACITY; ++i) {
        locator[i] = 0u;
    }
    u16 locator_size = 0u;
    if (!rs_berlekamp_massey(syndromes, parity_symbols, locator, locator_size)) {
        rs_debug_failure("berlekamp", data_symbols, parity_symbols);
        return false;
    }
    if (locator_size <= 1u) {
        rs_debug_failure("locator-size", data_symbols, parity_symbols);
        return false;
    }
    u16 error_positions[RS_POLY_CAPACITY];
    u16 error_count = 0u;
    u16 exponent_offset = (u16)(RS_FIELD_SIZE - codeword_length);
    if (!rs_find_error_locations(locator,
                                 locator_size,
                                 codeword_length,
                                 exponent_offset,
                                 error_positions,
                                 error_count,
                                 data_symbols,
                                 parity_symbols)) {
        rs_debug_failure("locations", data_symbols, parity_symbols);
        return false;
    }
    if ((error_count * 2u) > parity_symbols) {
        rs_debug_failure("too-many-errors", data_symbols, parity_symbols);
        return false;
    }
    u8 evaluator[RS_POLY_CAPACITY];
    u16 evaluator_size = rs_compute_error_evaluator(locator, locator_size, syndromes, parity_symbols, evaluator);
    u8 locator_derivative[RS_POLY_CAPACITY];
    u16 derivative_size = rs_compute_locator_derivative(locator, locator_size, locator_derivative);
    if (derivative_size == 0u) {
        rs_debug_failure("derivative", data_symbols, parity_symbols);
        return false;
    }
    if (!rs_correct_errors(block,
                           codeword_length,
                           exponent_offset,
                           evaluator,
                           evaluator_size,
                           locator_derivative,
                           derivative_size,
                           error_positions,
                           error_count)) {
        rs_debug_failure("correct", data_symbols, parity_symbols);
        return false;
    }
    if (corrected_errors) {
        *corrected_errors = error_count;
    }
    return true;
}



static bool compute_ecc_layout(usize data_bytes,
                               double requested_redundancy,
                               u16& block_data,
                               u16& parity_symbols,
                               u64& block_count) {
    block_data = 0u;
    parity_symbols = 0u;
    block_count = 0u;
    if (data_bytes == 0u || requested_redundancy <= 0.0) {
        return true;
    }
    double ratio = requested_redundancy;
    if (ratio < 0.000001) {
        ratio = 0.000001;
    }
    double max_data = (double)RS_FIELD_SIZE / (1.0 + ratio);
    if (max_data < 1.0) {
        max_data = 1.0;
    }
    u16 candidate = (u16)max_data;
    if (candidate == 0u) {
        candidate = 1u;
    }
    for (; candidate >= 1u; --candidate) {
        double predicted = ratio * (double)candidate;
        u16 parity = (u16)(predicted + 0.999999);
        if (parity < 2u) {
            parity = 2u;
        }
        while ((u32)candidate + parity > RS_FIELD_SIZE) {
            if (parity <= 2u) {
                break;
            }
            --parity;
        }
        if ((u32)candidate + parity <= RS_FIELD_SIZE) {
            block_data = candidate;
            parity_symbols = parity;
            break;
        }
    }
    if (block_data == 0u || parity_symbols == 0u) {
        return false;
    }
    block_count = (u64)((data_bytes + (usize)block_data - 1u) / (usize)block_data);
    if (block_count == 0u) {
        block_count = 1u;
    }
    u64 total_symbols = (u64)(block_data + parity_symbols) * block_count;
    if (total_symbols > (u64)USIZE_MAX_VALUE) {
        return false;
    }
    return true;
}

static bool encode_payload_with_ecc(const ByteBuffer& compressed,
                                    double redundancy,
                                    BitWriter& writer,
                                    EccSummary& summary) {
    if (!compressed.data || compressed.size == 0u) {
        return false;
    }
    u16 block_data = 0u;
    u16 parity_symbols = 0u;
    u64 block_count = 0u;
    if (!compute_ecc_layout(compressed.size, redundancy, block_data, parity_symbols, block_count)) {
        return false;
    }
    u64 total_symbols = (u64)(block_data + parity_symbols) * block_count;
    if (total_symbols == 0u || total_symbols > (u64)USIZE_MAX_VALUE) {
        return false;
    }
    ByteBuffer encoded;
    if (!encoded.ensure((usize)total_symbols)) {
        return false;
    }
    encoded.size = (usize)total_symbols;
    u8 generator[RS_POLY_CAPACITY];
    u16 generator_size = 0u;
    if (!rs_build_generator(parity_symbols, generator, generator_size)) {
        return false;
    }
    (void)generator_size;
    u8 parity_buffer[RS_POLY_CAPACITY];
    u8 data_buffer[RS_POLY_CAPACITY];
    usize payload_offset = 0u;
    u16 block_symbols = (u16)(block_data + parity_symbols);
    for (u64 block_index = 0u; block_index < block_count; ++block_index) {
        for (u16 i = 0u; i < block_data; ++i) {
            usize src_index = payload_offset + (usize)i;
            data_buffer[i] = (src_index < compressed.size) ? compressed.data[src_index] : 0u;
        }
        rs_compute_parity(generator, parity_symbols, data_buffer, block_data, parity_buffer);
        usize base = (usize)block_index * (usize)block_symbols;
        for (u16 i = 0u; i < block_data; ++i) {
            encoded.data[base + i] = data_buffer[i];
        }
        for (u16 j = 0u; j < parity_symbols; ++j) {
            encoded.data[base + block_data + j] = parity_buffer[j];
        }
        payload_offset += (usize)block_data;
    }
    EccHeader header;
    header.block_data = block_data;
    header.parity = parity_symbols;
    header.block_count = block_count;
    header.original_bytes = (u64)compressed.size;
    if (!header.write(writer)) {
        return false;
    }
    u8 header_copy[ECC_HEADER_COPY_TOTAL_BYTES];
    if (!build_protected_header_copy(header, header_copy)) {
        return false;
    }
    for (usize i = ECC_HEADER_COPY_DATA_BYTES; i < ECC_HEADER_COPY_TOTAL_BYTES; ++i) {
        if (!writer.write_bits((u64)header_copy[i], 8u)) {
            return false;
        }
    }
    for (usize copy_index = 1u; copy_index < ECC_HEADER_COPY_COUNT; ++copy_index) {
        for (usize i = 0u; i < ECC_HEADER_COPY_TOTAL_BYTES; ++i) {
            if (!writer.write_bits((u64)header_copy[i], 8u)) {
                return false;
            }
        }
    }
    for (usize i = 0u; i < encoded.size; ++i) {
        if (!writer.write_bits((u64)encoded.data[i], 8u)) {
            return false;
        }
    }
    summary.enabled = true;
    summary.block_data_symbols = block_data;
    summary.parity_symbols = parity_symbols;
    summary.block_count = block_count;
    summary.original_bytes = compressed.size;
    summary.redundancy = (block_data ? ((double)parity_symbols) / (double)block_data : 0.0);
    return true;
}

struct EccHeaderInfo {
    bool detected;
    bool valid;
    bool enabled;
    u16 block_data;
    u16 parity;
    u64 block_count;
    u64 original_bytes;
    u32 header_copies_repaired;

    EccHeaderInfo()
        : detected(false),
          valid(false),
          enabled(false),
          block_data(0u),
          parity(0u),
          block_count(0u),
          original_bytes(0u),
          header_copies_repaired(0u) {}
};

static bool build_ecc_header_bytes(u8* dest,
                                   usize dest_capacity,
                                   u16 block_data,
                                   u16 parity,
                                   u64 block_count,
                                   u64 original_bytes) {
    if (!dest || dest_capacity < ECC_HEADER_TOTAL_BYTES) {
        return false;
    }
    if (block_data == 0u || parity == 0u || block_count == 0u) {
        return false;
    }
    if (block_data >= RS_FIELD_SIZE || parity >= RS_FIELD_SIZE) {
        return false;
    }
    if ((u32)block_data + parity > RS_FIELD_SIZE) {
        return false;
    }
    EccHeader header;
    header.block_data = block_data;
    header.parity = parity;
    header.block_count = block_count;
    header.original_bytes = original_bytes;
    header.reserved = 0u;
    u8 header_copy[ECC_HEADER_COPY_TOTAL_BYTES];
    if (!build_protected_header_copy(header, header_copy)) {
        return false;
    }
    for (usize copy_index = 0u; copy_index < ECC_HEADER_COPY_COUNT; ++copy_index) {
        usize base = copy_index * ECC_HEADER_COPY_TOTAL_BYTES;
        for (usize i = 0u; i < ECC_HEADER_COPY_TOTAL_BYTES; ++i) {
            dest[base + i] = header_copy[i];
        }
    }
    return true;
}

static bool parse_ecc_header(const u8* bytes,
                             usize byte_count,
                             EccHeaderInfo& header) {
    header = EccHeaderInfo();
    if (!bytes || byte_count < ECC_HEADER_BYTES) {
        return false;
    }
    u16 magic = read_le_u16(bytes);
    if (magic != ECC_HEADER_MAGIC) {
        return false;
    }
    header.detected = true;
    if (byte_count < ECC_HEADER_TOTAL_BYTES) {
        return false;
    }
    EccHeader parsed;
    u32 repaired_copies = 0u;
    u32 success_count = 0u;
    if (!reconstruct_ecc_header_copies(bytes, byte_count, parsed, repaired_copies, success_count)) {
        header.header_copies_repaired = repaired_copies;
        return false;
    }
    header.valid = true;
    header.enabled = ((parsed.flags & 0x01u) != 0u);
    header.block_data = parsed.block_data;
    header.parity = parsed.parity;
    header.block_count = parsed.block_count;
    header.original_bytes = parsed.original_bytes;
    header.header_copies_repaired = repaired_copies;
    return true;
}

static bool decode_ecc_payload(const u8* bytes,
                               const EccHeaderInfo& header,
                               ByteBuffer& output,
                               EccDecodeStats* stats) {
    if (!bytes || !header.valid || !header.enabled) {
        return false;
    }
    u16 block_total = (u16)(header.block_data + header.parity);
    u64 expected_bytes = (u64)block_total * header.block_count;
    if (expected_bytes > (u64)USIZE_MAX_VALUE) {
        return false;
    }
    if (!output.ensure((usize)header.original_bytes)) {
        return false;
    }
    output.size = (usize)header.original_bytes;
    u64 written = 0u;
    if (stats) {
        stats->corrected_symbols = 0u;
        stats->blocks_with_errors = 0u;
        stats->total_blocks = header.block_count;
        stats->total_parity_symbols = (u64)header.parity * header.block_count;
        stats->header_copy_repairs = 0u;
    }
    u8 block_buffer[RS_POLY_CAPACITY];
    for (u64 block_index = 0u; block_index < header.block_count; ++block_index) {
        usize offset = (usize)block_index * (usize)block_total;
        for (u16 i = 0u; i < block_total; ++i) {
            block_buffer[i] = bytes[offset + i];
        }
        u16 block_errors = 0u;
        g_rs_debug_block_index = (i64)block_index;
        if (!rs_decode_block(block_buffer, header.block_data, header.parity, &block_errors)) {
            return false;
        }
        g_rs_debug_block_index = -1;
        if (stats && block_errors > 0u) {
            stats->corrected_symbols += (u64)block_errors;
            stats->blocks_with_errors += 1u;
        }
        if (debug_logging_enabled() && block_errors > 0u) {
            char block_buffer[32];
            char error_buffer[32];
            u64_to_ascii(block_index, block_buffer, sizeof(block_buffer));
            u64_to_ascii((u64)block_errors, error_buffer, sizeof(error_buffer));
            console_write(2, "debug rs: corrected block=");
            console_write(2, block_buffer);
            console_write(2, " symbols=");
            console_line(2, error_buffer);
        }
        u16 copy = header.block_data;
        if (written + copy > header.original_bytes) {
            copy = (u16)(header.original_bytes - written);
        }
        for (u16 i = 0u; i < copy; ++i) {
            output.data[(usize)written + i] = block_buffer[i];
        }
        written += copy;
        if (written >= header.original_bytes) {
            break;
        }
    }
    return (written == header.original_bytes);
}

static bool shuffle_encoded_stream(u8* data, usize byte_count, bool ecc_enabled) {
    if (!data || byte_count <= 1u) {
        return true;
    }
    if (!ecc_enabled) {
        return fisher_yates_shuffle(data, byte_count);
    }
    usize header_span = ecc_header_span_for_bytes(byte_count);
    if (byte_count <= header_span) {
        return true;
    }
    return fisher_yates_shuffle(data + header_span, byte_count - header_span);
}

static bool unshuffle_encoded_stream(u8* data, usize byte_count) {
    if (!data || byte_count <= 1u) {
        return true;
    }
    bool treat_as_ecc = false;
    if (byte_count >= ECC_HEADER_BYTES) {
        u16 magic = read_le_u16(data);
        if (magic == ECC_HEADER_MAGIC) {
            treat_as_ecc = true;
        }
    }
    EccHeaderInfo header_probe;
    if (parse_ecc_header(data, byte_count, header_probe) && header_probe.valid && header_probe.enabled) {
        treat_as_ecc = true;
    }
    if (!treat_as_ecc) {
        return fisher_yates_unshuffle(data, byte_count);
    }
    usize header_span = ecc_header_span_for_bytes(byte_count);
    if (byte_count <= header_span) {
        return true;
    }
    return fisher_yates_unshuffle(data + header_span, byte_count - header_span);
}

struct DecoderContext {
    ByteBuffer payload;
    bool has_payload;
    bool ecc_failed;
    bool password_attempted;
    bool password_failed;
    bool password_not_encrypted;
    EccDecodeStats ecc_stats;

    DecoderContext()
        : payload(),
          has_payload(false),
          ecc_failed(false),
          password_attempted(false),
          password_failed(false),
          password_not_encrypted(false),
          ecc_stats() {}

    ~DecoderContext() {
        reset();
    }

    void reset() {
        payload.release();
        has_payload = false;
        ecc_failed = false;
        password_attempted = false;
        password_failed = false;
        password_not_encrypted = false;
        ecc_stats = EccDecodeStats();
    }

    bool parse(u8* data, usize size_in_bits, const char* password, usize password_length) {
        payload.release();
        has_payload = false;
        ecc_failed = false;
        password_attempted = false;
        password_failed = false;
        password_not_encrypted = false;
        ecc_stats = EccDecodeStats();
        if (size_in_bits == 0u) {
            has_payload = true;
            return true;
        }
        if (!data) {
        return false;
    }
    usize byte_count = (size_in_bits + 7u) >> 3u;
    if (byte_count > 0u && !unshuffle_encoded_stream(data, byte_count)) {
        return false;
    }
    const char* ecc_input_dump = getenv("MAKOCODE_DEBUG_ECC_INPUT");
    if (ecc_input_dump && *ecc_input_dump && data && byte_count > 0u) {
        int dump_fd = open(ecc_input_dump, O_WRONLY | O_CREAT | O_TRUNC, 0644);
        if (dump_fd >= 0) {
            usize remaining = byte_count;
            const u8* ptr = data;
            while (remaining > 0u) {
                usize chunk = remaining;
                if (chunk > 1u << 20) {
                    chunk = 1u << 20;
                }
                ssize_t write_result = write(dump_fd, ptr, chunk);
                if (write_result < 0) {
                    if (debug_logging_enabled()) {
                        console_line(2, "debug parse: ECC input dump write failed");
                    }
                    break;
                }
                if (write_result == 0) {
                    break;
                }
                ptr += (usize)write_result;
                remaining -= (usize)write_result;
            }
            close(dump_fd);
        } else if (debug_logging_enabled()) {
            console_write(2, "debug parse: failed to open ECC input dump ");
            console_line(2, ecc_input_dump);
        }
    }
    EccHeaderInfo header;
    bool header_ok = parse_ecc_header(data, byte_count, header);
        bool have_password = (password && password_length > 0u);
        if (header_ok && header.valid && header.enabled) {
            ecc_stats.header_copy_repairs = header.header_copies_repaired;
            u16 block_total = (u16)(header.block_data + header.parity);
            u64 expected_bytes = (u64)block_total * header.block_count;
            u64 available_bytes = (u64)byte_count;
            usize header_span = ecc_header_span_for_bytes(byte_count);
            if (header_span < ECC_HEADER_COPY_TOTAL_BYTES) {
                ecc_failed = true;
                return false;
            }
            if (available_bytes < (u64)header_span + expected_bytes) {
                ecc_failed = true;
                return false;
            }
            const u8* encoded = data + header_span;
            ByteBuffer compressed;
            if (!decode_ecc_payload(encoded, header, compressed, &ecc_stats)) {
                if (debug_logging_enabled()) {
                    char debug_buffer[128];
                    console_line(2, "debug parse: decode_ecc_payload failure");
                    if (header.block_data || header.parity || header.block_count) {
                        console_write(2, "debug parse: block_data=");
                        u64_to_ascii((u64)header.block_data, debug_buffer, sizeof(debug_buffer));
                        console_line(2, debug_buffer);
                        console_write(2, "debug parse: parity=");
                        u64_to_ascii((u64)header.parity, debug_buffer, sizeof(debug_buffer));
                        console_line(2, debug_buffer);
                        console_write(2, "debug parse: block_count=");
                        u64_to_ascii(header.block_count, debug_buffer, sizeof(debug_buffer));
                        console_line(2, debug_buffer);
                        console_write(2, "debug parse: original_bytes=");
                        u64_to_ascii(header.original_bytes, debug_buffer, sizeof(debug_buffer));
                        console_line(2, debug_buffer);
                        console_write(2, "debug parse: byte_count=");
                        u64_to_ascii((u64)byte_count, debug_buffer, sizeof(debug_buffer));
                        console_line(2, debug_buffer);
                        console_write(2, "debug parse: expected_bytes=");
                        u64_to_ascii((u64)((u64)(header.block_data + header.parity) * header.block_count), debug_buffer, sizeof(debug_buffer));
                        console_line(2, debug_buffer);
                    }
                }
                ecc_failed = true;
                return false;
            }
            const ByteBuffer* working = &compressed;
            ByteBuffer decrypted;
            if (have_password) {
                password_attempted = true;
                DecryptStatus status = decrypt_payload_buffer(compressed.data,
                                                              compressed.size,
                                                              password,
                                                              password_length,
                                                              decrypted);
                if (status == DecryptStatus_NotEncrypted) {
                    password_not_encrypted = true;
                } else if (status == DecryptStatus_Success) {
                    working = &decrypted;
                } else {
                    password_failed = true;
                    return false;
                }
            }
            if (!working->size) {
                has_payload = true;
                return true;
            }
            u64 bit_total = (u64)working->size * 8u;
            if (bit_total > (u64)USIZE_MAX_VALUE) {
                ecc_failed = true;
                return false;
            }
            const char* ecc_output_dump = getenv("MAKOCODE_DEBUG_ECC_OUTPUT");
            if (ecc_output_dump && *ecc_output_dump && working->data && working->size > 0u) {
                int dump_fd = open(ecc_output_dump, O_WRONLY | O_CREAT | O_TRUNC, 0644);
                if (dump_fd >= 0) {
                    const u8* dump_ptr = working->data;
                    usize dump_remaining = working->size;
                    while (dump_remaining > 0u) {
                        usize chunk = dump_remaining;
                        if (chunk > 1u << 20) {
                            chunk = 1u << 20;
                        }
                        ssize_t write_result = write(dump_fd, dump_ptr, chunk);
                        if (write_result < 0) {
                            if (debug_logging_enabled()) {
                                console_line(2, "debug parse: ECC output dump write failed");
                            }
                            break;
                        }
                        if (write_result == 0) {
                            break;
                        }
                        dump_ptr += (usize)write_result;
                        dump_remaining -= (usize)write_result;
                    }
                    close(dump_fd);
                } else if (debug_logging_enabled()) {
                    console_write(2, "debug parse: failed to open ECC output dump ");
                    console_line(2, ecc_output_dump);
                }
            }
            if (!lzma_decompress(working->data, (usize)bit_total, payload)) {
                if (debug_logging_enabled()) {
                    char size_buffer[32];
                    char bits_buffer[32];
                    u64_to_ascii((u64)working->size, size_buffer, sizeof(size_buffer));
                    u64_to_ascii(bit_total, bits_buffer, sizeof(bits_buffer));
                    console_write(2, "debug parse: lzma decompress failure (bytes=");
                    console_write(2, size_buffer);
                    console_write(2, ", bits=");
                    console_write(2, bits_buffer);
                    console_line(2, ")");
                }
                ecc_failed = true;
                return false;
            }
            has_payload = true;
            return true;
        }
        if (header.detected && !header.valid) {
            ecc_failed = true;
            return false;
        }
        const u8* decode_data = data;
        usize decode_bits = size_in_bits;
        ByteBuffer decrypted;
        if (have_password) {
            password_attempted = true;
            DecryptStatus status = decrypt_payload_buffer(data,
                                                          byte_count,
                                                          password,
                                                          password_length,
                                                          decrypted);
            if (status == DecryptStatus_NotEncrypted) {
                password_not_encrypted = true;
            } else if (status == DecryptStatus_Success) {
                decode_data = decrypted.data;
                decode_bits = decrypted.size * 8u;
            } else {
                password_failed = true;
                return false;
            }
        }
        if (decode_bits == 0u) {
            has_payload = true;
            return true;
        }
        if (!lzma_decompress(decode_data, decode_bits, payload)) {
            return false;
        }
        has_payload = true;
        return true;
    }

    bool ecc_correction_failed() const {
        return ecc_failed;
    }

    bool password_attempt_made() const {
        return password_attempted;
    }

    bool password_auth_failed() const {
        return password_failed;
    }

    bool password_was_ignored() const {
        return password_not_encrypted;
    }

    const EccDecodeStats& ecc_statistics() const {
        return ecc_stats;
    }
};

} // namespace makocode

static const u32 DEFAULT_PAGE_WIDTH_PIXELS  = 2480u; // matches prior A4 default
static const u32 DEFAULT_PAGE_HEIGHT_PIXELS = 3508u; // matches prior A4 default

static void byte_buffer_move(makocode::ByteBuffer& dest, makocode::ByteBuffer& src) {
    dest.release();
    dest.data = src.data;
    dest.size = src.size;
    dest.capacity = src.capacity;
    src.data = 0;
    src.size = 0;
    src.capacity = 0;
}

struct PaletteColor {
    u8 r;
    u8 g;
    u8 b;
};

static bool palette_colors_equal(const PaletteColor& a, const PaletteColor& b) {
    return a.r == b.r && a.g == b.g && a.b == b.b;
}

static const u32 MAX_CUSTOM_PALETTE_COLORS = 16u;
static const usize MAX_CUSTOM_PALETTE_TEXT = 256u;
static const u8 CUSTOM_PALETTE_SYNTHETIC_COLOR_MODE = 3u;

struct ImageMappingConfig {
    u8  color_channels;
    u32 page_width_pixels;
    bool page_width_set;
    u32 page_height_pixels;
    bool page_height_set;
    char palette_text[MAX_CUSTOM_PALETTE_TEXT];
    usize palette_text_length;
    bool palette_set;
    PaletteColor custom_palette[MAX_CUSTOM_PALETTE_COLORS];
    u8 custom_palette_ids[MAX_CUSTOM_PALETTE_COLORS];
    u32 custom_palette_count;
    u32 custom_palette_base;
    bool custom_palette_valid;

    ImageMappingConfig()
        : color_channels(1u),
          page_width_pixels(DEFAULT_PAGE_WIDTH_PIXELS),
          page_width_set(false),
          page_height_pixels(DEFAULT_PAGE_HEIGHT_PIXELS),
          page_height_set(false),
          palette_text_length(0u),
          palette_set(false),
          custom_palette_count(0u),
          custom_palette_base(0u),
          custom_palette_valid(false) {
        palette_text[0] = '\0';
        for (u32 i = 0u; i < MAX_CUSTOM_PALETTE_COLORS; ++i) {
            custom_palette[i].r = 0u;
            custom_palette[i].g = 0u;
            custom_palette[i].b = 0u;
            custom_palette_ids[i] = 0u;
        }
    }
};

static bool compute_page_dimensions(const ImageMappingConfig& config,
                                    u32& out_width_pixels,
                                    u32& out_height_pixels) {
    u64 width_pixels = (u64)config.page_width_pixels;
    u64 height_pixels = (u64)config.page_height_pixels;
    if (width_pixels == 0u || height_pixels == 0u) {
        return false;
    }
    if (width_pixels > 0xFFFFFFFFu || height_pixels > 0xFFFFFFFFu) {
        return false;
    }
    out_width_pixels = config.page_width_pixels;
    out_height_pixels = config.page_height_pixels;
    return true;
}

static u64 estimate_square_page_from_image(u64 image_width, u64 image_height) {
    if (image_width == 0u || image_height == 0u) {
        return 0u;
    }
    double best_score = 1e9;
    u64 best_guess = 0u;
    for (u64 candidate = 400u; candidate <= 3200u; candidate += 10u) {
        double sx = (double)image_width / (double)candidate;
        double sy = (double)image_height / (double)candidate;
        if (sx < 1.5 || sy < 1.5 || sx > 6.0 || sy > 6.0) {
            continue;
        }
        double diff = sx - sy;
        if (diff < 0.0) diff = -diff;
        if (diff > 0.6) {
            continue;
        }
        double frac_x = sx - (double)((u64)sx);
        if (frac_x < 0.0) frac_x = -frac_x;
        double frac_y = sy - (double)((u64)sy);
        if (frac_y < 0.0) frac_y = -frac_y;
        double scale_avg = 0.5 * (sx + sy);
        // Slightly penalize very large integer scale factors so moderate scales (e.g., 2x-3x)
        // are preferred over extreme shrink/expand guesses.
        double scale_bias = (sx + sy) * 0.02;
        double low_scale_penalty = 0.0;
        double min_scale = (sx < sy) ? sx : sy;
        if (min_scale < 1.8) {
            low_scale_penalty = (1.8 - min_scale) * 0.6;
        }
        double scale_center_penalty = fabs(scale_avg - 2.5) * 0.08;
        double score = diff + (frac_x + frac_y) * 0.05 + scale_bias + low_scale_penalty + scale_center_penalty;
        if (score < best_score) {
            best_score = score;
            best_guess = candidate;
        }
    }
    return best_guess;
}

static const u32 FOOTER_BASE_GLYPH_WIDTH  = 5u;
static const u32 FOOTER_BASE_GLYPH_HEIGHT = 8u;

struct PageFooterConfig {
    const char* title_text;
    usize title_length;
    const char* filename_text;
    usize filename_length;
    u32 font_size;
    usize max_text_length;
    bool has_title;
    bool has_filename;
    bool display_page_info;
    bool display_filename;
    // Optional stripe sizing hints (used by variable-length footer stripes).
    u32 stripe_rows_hint;          // 0 means use default
    u32 stripe_module_count_hint;  // 0 means use default
    u32 stripe_module_pitch_hint;  // 0 means use default

    PageFooterConfig()
        : title_text(0),
          title_length(0u),
          filename_text(0),
          filename_length(0u),
          font_size(1u),
          max_text_length(0u),
          has_title(false),
          has_filename(false),
          display_page_info(true),
          display_filename(true),
          stripe_rows_hint(0u),
          stripe_module_count_hint(0u),
          stripe_module_pitch_hint(0u) {}
};

struct FiducialGridDefaults {
    u32 marker_size_pixels = 4u;
    u32 spacing_pixels = 24u;
    u32 margin_pixels = 12u;
};

static FiducialGridDefaults g_fiducial_defaults;

static bool compute_fiducial_reservation(u32 width_pixels,
                                         u32 height_pixels,
                                         u32 data_height_pixels,
                                         u64& reserved_data_pixels,
                                         makocode::ByteBuffer* mask_out = 0,
                                         bool reserve_metadata_tile = true);

static bool compute_bits_per_page(u32 width_pixels,
                                  u32 height_pixels,
                                  u32 data_height_pixels,
                                  double bits_per_pixel,
                                  u64& bits_per_page,
                                  u64* reserved_pixels_out = 0);

struct FooterLayout {
    bool has_text;
    u32 font_size;
    u32 glyph_width_pixels;
    u32 glyph_height_pixels;
    u32 char_spacing_pixels;
    u32 footer_height_pixels;
    u32 data_height_pixels;
    u32 text_top_row;
    u32 text_left_column;
    u32 text_pixel_width;
    u32 stripe_module_pitch;
    u32 stripe_rows;
    u32 stripe_gap_pixels;
    u32 stripe_height_pixels;
    u32 stripe_top_row;
    u32 stripe_module_count;
    u32 stripe_data_bits;
    u32 stripe_pixel_width;
    u32 stripe_quiet_modules;
    u32 stripe_sentinel_modules;

    FooterLayout()
        : has_text(false),
          font_size(0u),
          glyph_width_pixels(0u),
          glyph_height_pixels(0u),
          char_spacing_pixels(0u),
          footer_height_pixels(0u),
          data_height_pixels(0u),
          text_top_row(0u),
          text_left_column(0u),
          text_pixel_width(0u),
          stripe_module_pitch(0u),
          stripe_rows(0u),
          stripe_gap_pixels(0u),
          stripe_height_pixels(0u),
          stripe_top_row(0u),
          stripe_module_count(0u),
          stripe_data_bits(0u),
          stripe_pixel_width(0u),
          stripe_quiet_modules(0u),
          stripe_sentinel_modules(0u) {}
};

struct AffineTransform {
    // 2x2 matrix (row-major) and translation
    double a00, a01, a10, a11, tx, ty;

    AffineTransform()
        : a00(1.0), a01(0.0), a10(0.0), a11(1.0), tx(0.0), ty(0.0) {}
};

namespace FooterStripe {
    using namespace makocode;
    struct StripeSpec {
        u32 module_pitch;
        u32 rows;
        u32 quiet_modules;
        u32 barker_modules;
        u32 timing_modules;
        u32 parity_symbols;
        u32 metadata_bytes;
        u32 palette_bytes;
        u8  schema_version;
    };

    static const StripeSpec SPEC_V2 = {
        2u,   // module_pitch
        33u,  // rows
        2u,   // quiet_modules
        11u,  // barker_modules
        6u,   // timing_modules
        15u,  // parity_symbols (RS(255,240) corrects up to 7 symbol errors)
        240u, // metadata_bytes (includes CRC byte)
        219u, // palette_bytes written into metadata
        2u    // schema version
    };

    static const StripeSpec SPEC_V1 = {
        2u,  // module_pitch
        4u,  // rows
        2u,  // quiet_modules
        11u, // barker_modules
        6u,  // timing_modules
        8u,  // parity_symbols
        20u, // metadata_bytes (includes CRC byte)
        0u,  // palette bytes not present
        1u   // schema version
    };

    // Variable-length footer stripe (schema V3)
    static const u32 V3_SCHEMA_VERSION = 3u;
    static const u32 V3_MODULE_PITCH = 2u;
    static const u32 V3_QUIET_MODULES = 2u;
    static const u32 V3_BARKER_MODULES = 11u;
    static const u32 V3_TIMING_MODULES = 6u;
    static const u32 V3_GUARD_MODULES = V3_BARKER_MODULES + V3_TIMING_MODULES; // 17 per side
    static const u32 V3_MODULE_COUNT = 100u;                                    // same visual width as V2
    static const u32 V3_DATA_MODULES = V3_MODULE_COUNT - (V3_QUIET_MODULES * 2u) - (V3_GUARD_MODULES * 2u); // 62 data bits per row
    static const u32 V3_HEADER_BYTES = 10u;                                     // 80-bit layout header (74 bits rounded to bytes)
    static const u32 V3_MIN_PARITY_BYTES = 8u;
    static const u32 V3_MAX_PARITY_BYTES = 32u;
    static const u32 V3_MAX_ROWS = 63u;                                         // keeps height <=126px at 2px pitch

    static const u32 MAX_STRIPE_ROWS = V3_MAX_ROWS;
    static const u32 MAX_STRIPE_PALETTE_BYTES = 512u;
    static const u32 MAX_STRIPE_MODULES = 128u;

    // Forward declarations for sampling helpers.
    static bool capture_module_row(const StripeSpec& spec,
                                   const u8* pixels,
                                   u32 width,
                                   u32 height,
                                   u32 stripe_top,
                                   u32 start_column,
                                   u32 row_index,
                                   u8* row_storage);
    struct V3Params {
        u32 rows;
        u32 parity_bytes;
        u32 metadata_bytes; // header + payload + crc
        u32 payload_bytes;
        u32 total_bytes;   // metadata + parity
    };

    static u32 footer_v3_payload_bytes(u32 palette_length, bool has_palette) {
        // Payload fields only (page/ecc/palette data). Header size is fixed separately.
        // Fields: page_bits(24) + page_count(20) + page_index(20) + footer_rows(8) +
        //         ecc_flag(1) + ecc_block_data(10) + ecc_parity(10) +
        //         ecc_block_count(20) + ecc_original_bytes(28) +
        //         page_width_px(16) + page_height_px(16) +
        //         fiducial_marker_size_px(8) +
        //         palette bytes (optional, length * 8)
        const u32 fixed_payload_bits = 24u + 20u + 20u + 8u + 1u + 10u + 10u + 20u + 28u + 16u + 16u + 8u; // 181 bits
        u64 bits = (u64)fixed_payload_bits;
        if (has_palette) {
            bits += (u64)palette_length * 8ull;
        }
        return (u32)((bits + 7u) >> 3u);
    }

    // Compute V3 sizing based on payload length in bytes. Width is fixed; height varies by rows.
    [[maybe_unused]] static bool compute_v3_parameters(u32 payload_bytes, V3Params& out) {
        out = {};
        const u32 header_bytes = V3_HEADER_BYTES; // fixed 10-byte layout header
        const u32 crc_bytes = 1u;                 // CRC over header+payload
        u32 metadata_bytes = header_bytes + payload_bytes + crc_bytes;
        // Choose parity 10% of metadata within bounds.
        u32 parity_bytes = (metadata_bytes + 9u) / 10u;
        if (parity_bytes < V3_MIN_PARITY_BYTES) parity_bytes = V3_MIN_PARITY_BYTES;
        if (parity_bytes > V3_MAX_PARITY_BYTES) parity_bytes = V3_MAX_PARITY_BYTES;
        u32 total_bytes = metadata_bytes + parity_bytes;
        if (total_bytes > RS_POLY_CAPACITY) {
            return false;
        }
        const u32 bits_per_row = 62u; // fixed data modules per row for V3
        u32 total_bits = total_bytes * 8u;
        u32 rows = (total_bits + bits_per_row - 1u) / bits_per_row;
        if (rows == 0u) rows = 1u;
        if (rows > V3_MAX_ROWS) {
            return false;
        }
        out.rows = rows;
        out.parity_bytes = parity_bytes;
        out.metadata_bytes = metadata_bytes;
        out.payload_bytes = payload_bytes;
        out.total_bytes = total_bytes;
        return true;
    }

    static u32 guard_modules(const StripeSpec& spec) {
        return spec.barker_modules + spec.timing_modules;
    }

    static u32 data_bits(const StripeSpec& spec) {
        return (spec.metadata_bytes + spec.parity_symbols) * 8u;
    }

    static u32 max_row_data_bits(const StripeSpec& spec) {
        u32 bits = data_bits(spec);
        return (bits + spec.rows - 1u) / spec.rows;
    }

    static u32 module_count(const StripeSpec& spec) {
        return spec.quiet_modules * 2u + guard_modules(spec) * 2u + max_row_data_bits(spec);
    }

    static u32 pixel_width(const StripeSpec& spec) {
        return module_count(spec) * spec.module_pitch;
    }

    static u32 stripe_height(const StripeSpec& spec) {
        return spec.rows * spec.module_pitch;
    }

    static const u8 Barker11[11u] = {1u,1u,1u,0u,0u,1u,1u,0u,1u,0u,1u};
    static const u8 TimingPattern[6u] = {1u,0u,1u,0u,1u,0u};

    struct Values {
        u64 page_bits;
        u64 page_count;
        u64 page_index;
        u32 page_width_pixels;
        u32 page_height_pixels;
	        u64 footer_rows;
	        u32 fiducial_marker_size_pixels;
	        bool ecc_enabled;
        u16 ecc_block_data;
        u16 ecc_parity;
        u64 ecc_block_count;
        u64 ecc_original_bytes;
        bool has_palette;
        u8  palette_base;
        u16 palette_length;
        u8  palette_bytes[MAX_STRIPE_PALETTE_BYTES];
        // V3 dynamic layout fields
        u32 v3_rows;
        u32 v3_modules_per_row;
        u32 v3_module_pitch;
        u32 v3_parity_bytes;
        u32 v3_metadata_bytes;
        u32 v3_payload_bytes;
    };

    struct Pattern {
        ByteBuffer rows[MAX_STRIPE_ROWS];
    };

    static u32 row_data_bits(const StripeSpec& spec, u32 row_index) {
        if (row_index >= spec.rows) {
            return 0u;
        }
        u32 base = data_bits(spec) / spec.rows;
        u32 remainder = data_bits(spec) % spec.rows;
        return base + ((row_index < remainder) ? 1u : 0u);
    }

    static u8 compute_crc8(const u8* data, usize length) {
        u8 crc = 0u;
        for (usize i = 0u; i < length; ++i) {
            crc ^= data[i];
            for (u32 bit = 0u; bit < 8u; ++bit) {
                if (crc & 0x80u) {
                    crc = (u8)((crc << 1u) ^ 0x07u);
                } else {
                    crc <<= 1u;
                }
            }
        }
        return crc;
    }

    static void log_metadata_limit(const char* label, u64 value) {
        if (!debug_logging_enabled()) {
            return;
        }
        char buffer[32];
        u64_to_ascii(value, buffer, sizeof(buffer));
        console_write(2, "debug footer stripe metadata limit ");
        console_write(2, label);
        console_write(2, "=");
        console_line(2, buffer);
    }

    static bool encode_metadata_v3(const Values& values, const V3Params& v3, ByteBuffer& output) {
        output.release();
        BitWriter writer;
        // Layout header (10 bytes):
        // schema_version(4) | row_count(6) | modules_per_row(7) | module_pitch(8)
        // parity_bytes(8) | payload_bytes(16) | flags(8) | palette_base(5) | palette_length(12)
        u32 schema = V3_SCHEMA_VERSION & 0x0Fu;
        u32 modules_per_row = V3_MODULE_COUNT;
        u32 module_pitch = V3_MODULE_PITCH;
        u32 flags = 0u;
        if (values.has_palette && values.palette_length > 0u) {
            flags |= 1u; // palette_present
        }
        if (!writer.write_bits((u64)schema, 4u)) return false;
        if (!writer.write_bits((u64)v3.rows, 6u)) return false;
        if (!writer.write_bits((u64)modules_per_row, 7u)) return false;
        if (!writer.write_bits((u64)module_pitch, 8u)) return false;
        if (!writer.write_bits((u64)v3.parity_bytes, 8u)) return false;
        if (!writer.write_bits((u64)v3.payload_bytes, 16u)) return false;
        if (!writer.write_bits((u64)flags, 8u)) return false;
        u32 palette_base = (u32)values.palette_base;
        u32 palette_length = (u32)values.palette_length;
        if (palette_length > 0u && palette_length > MAX_STRIPE_PALETTE_BYTES) {
            return false;
        }
        if (!writer.write_bits((u64)palette_base, 5u)) return false;
        if (!writer.write_bits((u64)palette_length, 12u)) return false;
        if (!writer.align_to_byte()) return false;
        if (writer.byte_size() != V3_HEADER_BYTES) {
            // Keep header length in sync with sizing math.
            return false;
        }

        // Payload: existing metadata fields.
        auto write_limited = [&](u64 value, u32 bits, const char* label) -> bool {
            u64 limit = (bits >= 64u) ? ~0ull : ((1ull << bits) - 1ull);
            if (value > limit) {
                log_metadata_limit(label, value);
                return false;
            }
            return writer.write_bits(value, bits);
        };
        if (!write_limited(values.page_bits, 24u, "page_bits")) return false;
        if (!write_limited(values.page_count, 20u, "page_count")) return false;
        if (!write_limited(values.page_index, 20u, "page_index")) return false;
        if (!write_limited(values.footer_rows, 8u, "footer_rows")) return false;
        if (!writer.write_bits(values.ecc_enabled ? 1ull : 0ull, 1u)) return false;
        if (!write_limited(values.ecc_block_data, 10u, "ecc_block_data")) return false;
        if (!write_limited(values.ecc_parity, 10u, "ecc_parity")) return false;
        if (!write_limited(values.ecc_block_count, 20u, "ecc_block_count")) return false;
        if (!write_limited(values.ecc_original_bytes, 28u, "ecc_original_bytes")) return false;
        if (!write_limited(values.page_width_pixels, 16u, "page_width_px")) return false;
        if (!write_limited(values.page_height_pixels, 16u, "page_height_px")) return false;
        if (!write_limited(values.fiducial_marker_size_pixels, 8u, "fiducial_marker_size_px")) return false;
        // Palette bytes inline
        if (values.has_palette && values.palette_length > 0u) {
            for (u32 i = 0u; i < values.palette_length; ++i) {
                if (!writer.write_bits((u64)values.palette_bytes[i], 8u)) return false;
            }
        }
        if (!writer.align_to_byte()) return false;

        // CRC over header+payload bytes.
        ByteBuffer header_copy;
        usize header_bytes = writer.byte_size();
        if (header_bytes == 0u) return false;
        if (!header_copy.ensure(header_bytes)) return false;
        for (usize i = 0u; i < header_bytes; ++i) {
            const u8* writer_data = writer.data();
            header_copy.data[i] = writer_data ? writer_data[i] : 0u;
        }
        header_copy.size = header_bytes;
        u8 crc = compute_crc8(header_copy.data, header_copy.size);
        if (!writer.write_bits(crc, 8u)) return false;
        if (!writer.align_to_byte()) return false;

        // Output metadata buffer (header+payload+crc)
        usize total_bytes = writer.byte_size();
        if (!output.ensure(total_bytes)) return false;
        output.size = total_bytes;
        const u8* final_data = writer.data();
        for (usize i = 0u; i < total_bytes; ++i) {
            output.data[i] = final_data ? final_data[i] : 0u;
        }
        return true;
    }

    static bool encode_metadata(const StripeSpec& spec, const Values& values, ByteBuffer& output) {
        output.release();
        if (values.page_bits >= (1ull << 24u)) {
            log_metadata_limit("page_bits", values.page_bits);
            return false;
        }
        if (values.page_count >= (1ull << 20u)) {
            log_metadata_limit("page_count", values.page_count);
            return false;
        }
        if (values.page_index >= (1ull << 20u)) {
            log_metadata_limit("page_index", values.page_index);
            return false;
        }
        if (values.footer_rows >= (1ull << 8u)) {
            log_metadata_limit("footer_rows", values.footer_rows);
            return false;
        }
        if (values.ecc_block_data >= (1u << 10u)) {
            log_metadata_limit("ecc_block_data", values.ecc_block_data);
            return false;
        }
        if (values.ecc_parity >= (1u << 10u)) {
            log_metadata_limit("ecc_parity", values.ecc_parity);
            return false;
        }
        if (values.ecc_block_count >= (1ull << 20u)) {
            log_metadata_limit("ecc_block_count", values.ecc_block_count);
            return false;
        }
        if (values.ecc_original_bytes >= (1ull << 28u)) {
            log_metadata_limit("ecc_original_bytes", values.ecc_original_bytes);
            return false;
        }
        if (values.has_palette && spec.palette_bytes == 0u) {
            return false;
        }
        if (values.has_palette && values.palette_length > spec.palette_bytes) {
            log_metadata_limit("palette_length", values.palette_length);
            return false;
        }
        BitWriter writer;
        if (!writer.write_bits((u64)spec.schema_version, 4u)) {
            return false;
        }
        if (!writer.write_bits(values.page_bits, 24u)) {
            return false;
        }
        if (!writer.write_bits(values.page_count, 20u)) {
            return false;
        }
        if (!writer.write_bits(values.page_index, 20u)) {
            return false;
        }
        if (!writer.write_bits(values.footer_rows, 8u)) {
            return false;
        }
        if (!writer.write_bits(values.ecc_enabled ? 1ull : 0ull, 1u)) {
            return false;
        }
        if (!writer.write_bits(values.ecc_block_data, 10u)) {
            return false;
        }
        if (!writer.write_bits(values.ecc_parity, 10u)) {
            return false;
        }
        if (!writer.write_bits(values.ecc_block_count, 20u)) {
            return false;
        }
        if (!writer.write_bits(values.ecc_original_bytes, 28u)) {
            return false;
        }
        if (spec.palette_bytes) {
            u64 palette_flag = values.has_palette ? 1ull : 0ull;
            if (!writer.write_bits(palette_flag, 1u)) {
                return false;
            }
            if (!writer.write_bits((u64)values.palette_base, 5u)) {
                return false;
            }
            if (!writer.write_bits((u64)values.palette_length, 8u)) {
                return false;
            }
            for (u32 i = 0u; i < spec.palette_bytes; ++i) {
                u8 byte_value = (i < values.palette_length) ? values.palette_bytes[i] : 0u;
                if (!writer.write_bits((u64)byte_value, 8u)) {
                    return false;
                }
            }
            u32 header_bits_target = (spec.metadata_bytes > 0u) ? ((spec.metadata_bytes - 1u) * 8u) : 0u;
            if (writer.bit_size() < header_bits_target) {
                u32 pad_bits = header_bits_target - writer.bit_size();
                if (!writer.write_bits(0u, pad_bits)) {
                    return false;
                }
            }
        }
        if (!writer.align_to_byte()) {
            return false;
        }
        ByteBuffer header_copy;
        usize header_bytes = writer.byte_size();
        if (header_bytes == 0u) {
            return false;
        }
        if (!header_copy.ensure(header_bytes)) {
            return false;
        }
        for (usize i = 0u; i < header_bytes; ++i) {
            const u8* writer_data = writer.data();
            header_copy.data[i] = writer_data ? writer_data[i] : 0u;
        }
        header_copy.size = header_bytes;
        u8 crc = compute_crc8(header_copy.data, header_copy.size);
        if (!writer.write_bits(crc, 8u)) {
            return false;
        }
        if (!writer.align_to_byte()) {
            return false;
        }
        usize total_bytes = writer.byte_size();
        if (!output.ensure(total_bytes)) {
            return false;
        }
        output.size = total_bytes;
        const u8* final_data = writer.data();
        for (usize i = 0u; i < total_bytes; ++i) {
            output.data[i] = final_data ? final_data[i] : 0u;
        }
        return true;
    }

    [[maybe_unused]] static bool build_pattern(const StripeSpec& spec, const Values& values, Pattern& pattern) {
        ByteBuffer metadata;
        if (!encode_metadata(spec, values, metadata)) {
            if (debug_logging_enabled()) {
                console_line(2, "debug footer stripe encode_metadata failed");
            }
            return false;
        }
        if (metadata.size != spec.metadata_bytes) {
            if (debug_logging_enabled()) {
                char num_buf[32];
                u64_to_ascii((u64)metadata.size, num_buf, sizeof(num_buf));
                console_write(2, "debug footer stripe metadata size=");
                console_line(2, num_buf);
            }
            return false;
        }
        ByteBuffer codeword;
        if (!codeword.ensure(metadata.size + spec.parity_symbols)) {
            return false;
        }
        codeword.size = metadata.size + spec.parity_symbols;
        for (usize i = 0u; i < metadata.size; ++i) {
            codeword.data[i] = metadata.data[i];
        }
        u8 generator[RS_POLY_CAPACITY];
        u16 generator_size = 0u;
        if (!rs_build_generator((u16)spec.parity_symbols, generator, generator_size)) {
            return false;
        }
        u8 parity[RS_POLY_CAPACITY];
        rs_compute_parity(generator,
                          (u16)spec.parity_symbols,
                          metadata.data,
                          (u16)metadata.size,
                          parity);
        for (u32 i = 0u; i < spec.parity_symbols; ++i) {
            codeword.data[metadata.size + i] = parity[i];
        }
        ByteBuffer bit_sequence;
        usize total_bits = codeword.size * 8u;
        if (!bit_sequence.ensure(total_bits)) {
            return false;
        }
        bit_sequence.size = 0u;
        for (usize byte_index = 0u; byte_index < codeword.size; ++byte_index) {
            u8 byte = codeword.data[byte_index];
            for (u32 bit = 0u; bit < 8u; ++bit) {
                bit_sequence.data[bit_sequence.size++] = (u8)((byte >> bit) & 1u);
            }
        }
        if ((usize)data_bits(spec) != bit_sequence.size) {
            return false;
        }
        usize bit_cursor = 0u;
        for (u32 row = 0u; row < spec.rows; ++row) {
            ByteBuffer& row_buffer = pattern.rows[row];
            if (!row_buffer.ensure(module_count(spec))) {
                return false;
            }
            row_buffer.size = module_count(spec);
            u32 module_index = 0u;
            // Quiet zone
            for (u32 i = 0u; i < spec.quiet_modules; ++i) {
                row_buffer.data[module_index++] = 0u;
            }
            // Left guard: Barker-11 then timing 1010..
            for (u32 i = 0u; i < spec.barker_modules; ++i) {
                row_buffer.data[module_index++] = Barker11[i];
            }
            for (u32 i = 0u; i < spec.timing_modules; ++i) {
                row_buffer.data[module_index++] = TimingPattern[i];
            }
            // Data payload bits
            u32 bits_in_row = row_data_bits(spec, row);
            u32 max_bits_row = max_row_data_bits(spec);
            for (u32 i = 0u; i < max_bits_row; ++i) {
                u8 module_bit = 0u;
                if (i < bits_in_row) {
                    if (bit_cursor >= bit_sequence.size) {
                        return false;
                    }
                    module_bit = bit_sequence.data[bit_cursor++];
                }
                row_buffer.data[module_index++] = module_bit;
            }
            // Right guard: timing then Barker-11
            for (u32 i = 0u; i < spec.timing_modules; ++i) {
                row_buffer.data[module_index++] = TimingPattern[i];
            }
            for (u32 i = 0u; i < spec.barker_modules; ++i) {
                row_buffer.data[module_index++] = Barker11[i];
            }
            // Trailing quiet zone
            for (u32 i = 0u; i < spec.quiet_modules; ++i) {
                row_buffer.data[module_index++] = 0u;
            }
            if (module_index != module_count(spec)) {
                return false;
            }
        }
        if (bit_cursor != bit_sequence.size) {
            return false;
        }
        return true;
    }

    [[maybe_unused]] static bool build_pattern_v3(const V3Params& v3, const Values& values, Pattern& pattern) {
        ByteBuffer metadata;
        if (!encode_metadata_v3(values, v3, metadata)) {
            if (debug_logging_enabled()) {
                console_line(2, "debug footer stripe encode_metadata_v3 failed");
            }
            return false;
        }
        if (metadata.size != v3.metadata_bytes) {
            return false;
        }
        ByteBuffer codeword;
        if (!codeword.ensure(v3.total_bytes)) {
            return false;
        }
        codeword.size = v3.total_bytes;
        // metadata bytes then parity
        for (usize i = 0u; i < metadata.size; ++i) {
            codeword.data[i] = metadata.data[i];
        }
        u8 generator[RS_POLY_CAPACITY];
        u16 generator_size = 0u;
        if (!rs_build_generator((u16)v3.parity_bytes, generator, generator_size)) {
            return false;
        }
        u8 parity[RS_POLY_CAPACITY];
        rs_compute_parity(generator,
                          (u16)v3.parity_bytes,
                          metadata.data,
                          (u16)metadata.size,
                          parity);
        for (u32 i = 0u; i < v3.parity_bytes; ++i) {
            codeword.data[metadata.size + i] = parity[i];
        }
        usize total_bits = (usize)v3.total_bytes * 8u;
        ByteBuffer bit_sequence;
        if (!bit_sequence.ensure(total_bits)) {
            return false;
        }
        bit_sequence.size = 0u;
        for (usize byte_index = 0u; byte_index < codeword.size; ++byte_index) {
            u8 byte = codeword.data[byte_index];
            for (u32 bit = 0u; bit < 8u; ++bit) {
                bit_sequence.data[bit_sequence.size++] = (u8)((byte >> bit) & 1u);
            }
        }
        usize bit_cursor = 0u;
        u32 bits_per_row_base = (u32)(total_bits / v3.rows);
        u32 bits_remainder = (u32)(total_bits % v3.rows);
        for (u32 row = 0u; row < v3.rows; ++row) {
            ByteBuffer& row_buffer = pattern.rows[row];
            if (!row_buffer.ensure(V3_MODULE_COUNT)) {
                return false;
            }
            row_buffer.size = V3_MODULE_COUNT;
            u32 module_index = 0u;
            for (u32 i = 0u; i < V3_QUIET_MODULES; ++i) {
                row_buffer.data[module_index++] = 0u;
            }
            for (u32 i = 0u; i < V3_BARKER_MODULES; ++i) {
                row_buffer.data[module_index++] = Barker11[i];
            }
            for (u32 i = 0u; i < V3_TIMING_MODULES; ++i) {
                row_buffer.data[module_index++] = TimingPattern[i];
            }
            u32 bits_in_row = bits_per_row_base + ((row < bits_remainder) ? 1u : 0u);
            for (u32 i = 0u; i < V3_DATA_MODULES; ++i) {
                u8 module_bit = 0u;
                if (i < bits_in_row) {
                    if (bit_cursor < bit_sequence.size) {
                        module_bit = bit_sequence.data[bit_cursor++];
                    }
                }
                row_buffer.data[module_index++] = module_bit;
            }
            for (u32 i = 0u; i < V3_TIMING_MODULES; ++i) {
                row_buffer.data[module_index++] = TimingPattern[i];
            }
            for (u32 i = 0u; i < V3_BARKER_MODULES; ++i) {
                row_buffer.data[module_index++] = Barker11[i];
            }
            for (u32 i = 0u; i < V3_QUIET_MODULES; ++i) {
                row_buffer.data[module_index++] = 0u;
            }
            if (module_index != V3_MODULE_COUNT) {
                return false;
            }
        }
        return true;
    }

    static bool decode_from_bits(const StripeSpec& spec, const ByteBuffer& module_bits, Values& values) {
        u32 modules_per_row = module_count(spec);
        u32 expected_size = modules_per_row * spec.rows;
        if (module_bits.size < expected_size) {
            if (debug_logging_enabled()) {
                console_line(2, "debug stripe: insufficient module bits");
            }
            return false;
        }
        u32 data_start = spec.quiet_modules + guard_modules(spec);
        u32 max_data = max_row_data_bits(spec);
        u32 trailing_start = data_start + max_data;
        u32 guard_errors = 0u;
        for (u32 row = 0u; row < spec.rows; ++row) {
            u32 row_offset = row * modules_per_row;
            // Validate Barker + timing on both sides for framing and pitch sanity.
            for (u32 i = 0u; i < spec.barker_modules; ++i) {
                if (module_bits.data[row_offset + spec.quiet_modules + i] != Barker11[i]) {
                    ++guard_errors;
                }
            }
            for (u32 i = 0u; i < spec.timing_modules; ++i) {
                if (module_bits.data[row_offset + spec.quiet_modules + spec.barker_modules + i] != TimingPattern[i]) {
                    ++guard_errors;
                }
            }
            for (u32 i = 0u; i < spec.timing_modules; ++i) {
                if (module_bits.data[row_offset + trailing_start + i] != TimingPattern[i]) {
                    ++guard_errors;
                }
            }
            for (u32 i = 0u; i < spec.barker_modules; ++i) {
                if (module_bits.data[row_offset + trailing_start + spec.timing_modules + i] != Barker11[i]) {
                    ++guard_errors;
                }
            }
        }
        if (guard_errors > spec.rows * 2u) {
            if (debug_logging_enabled()) {
                console_line(2, "debug stripe: guard mismatch budget exceeded");
            }
            return false;
        }
        u8 codeword[255u];
        usize codeword_limit = (usize)spec.metadata_bytes + (usize)spec.parity_symbols;
        if (codeword_limit > sizeof(codeword)) {
            return false;
        }
        memset(codeword, 0, sizeof(codeword));
        u32 bit_cursor = 0u;
        for (u32 row = 0u; row < spec.rows; ++row) {
            u32 row_bits = row_data_bits(spec, row);
            u32 row_offset = row * modules_per_row;
            for (u32 bit_index = 0u; bit_index < row_bits; ++bit_index) {
                if (module_bits.data[row_offset + data_start + bit_index]) {
                    u32 byte_index = bit_cursor >> 3u;
                    u32 bit_offset = bit_cursor & 7u;
                    codeword[byte_index] = (u8)(codeword[byte_index] | (1u << bit_offset));
                }
                ++bit_cursor;
            }
        }
        if (bit_cursor != data_bits(spec)) {
            if (debug_logging_enabled()) {
                console_line(2, "debug stripe: unexpected bit cursor");
            }
            return false;
        }
        u8 pre_crc = compute_crc8(codeword, spec.metadata_bytes - 1u);
        u8 stored_crc = codeword[spec.metadata_bytes - 1u];
        u16 corrections = 0u;
        if (!rs_decode_block(codeword, (u16)spec.metadata_bytes, (u16)spec.parity_symbols, &corrections)) {
            if (debug_logging_enabled()) {
                console_write(2, "debug stripe: RS decode failed corrections=");
                char corr_buf[32];
                u64_to_ascii((u64)corrections, corr_buf, sizeof(corr_buf));
                console_write(2, corr_buf);
                console_write(2, " crc_before=");
                char crc_buf[4];
                u64_to_ascii((u64)pre_crc, crc_buf, sizeof(crc_buf));
                console_write(2, crc_buf);
                console_write(2, " stored_crc=");
                char stored_buf[4];
                u64_to_ascii((u64)stored_crc, stored_buf, sizeof(stored_buf));
                console_line(2, stored_buf);
            }
            return false;
        }
        u8 computed_crc = compute_crc8(codeword, spec.metadata_bytes - 1u);
        if (computed_crc != stored_crc) {
            if (debug_logging_enabled()) {
                console_line(2, "debug stripe: CRC mismatch");
            }
            return false;
        }
        BitReader reader;
        reader.reset(codeword, (spec.metadata_bytes - 1u) * 8u);
        u64 schema = reader.read_bits(4u);
        if (reader.failed || (schema != 1ull && schema != (u64)SPEC_V2.schema_version)) {
            return false;
        }
        u64 page_bits = reader.read_bits(24u);
        u64 page_count = reader.read_bits(20u);
        u64 page_index = reader.read_bits(20u);
        u64 footer_rows = reader.read_bits(8u);
        u64 ecc_flag = reader.read_bits(1u);
        u64 ecc_block_data = reader.read_bits(10u);
        u64 ecc_parity = reader.read_bits(10u);
        u64 ecc_block_count = reader.read_bits(20u);
        u64 ecc_original_bytes = reader.read_bits(28u);
        u16 palette_length = 0u;
        u8 palette_base = 0u;
        bool palette_flag = false;
        if (!reader.failed && schema == SPEC_V2.schema_version && spec.palette_bytes) {
            palette_flag = reader.read_bits(1u) != 0u;
            palette_base = (u8)reader.read_bits(5u);
            palette_length = (u16)reader.read_bits(8u);
            if (palette_length > spec.palette_bytes) {
                return false;
            }
            for (u32 i = 0u; i < spec.palette_bytes; ++i) {
                u64 byte_val = reader.read_bits(8u);
                if (reader.failed) {
                    return false;
                }
                if (i < (u32)sizeof(values.palette_bytes)) {
                    values.palette_bytes[i] = (u8)byte_val;
                }
            }
            u64 consumed_bits = (u64)reader.cursor;
            u64 target_bits = ((u64)spec.metadata_bytes - 1ull) * 8ull;
            if (consumed_bits > target_bits) {
                return false;
            }
            if (target_bits > consumed_bits) {
                reader.read_bits((u32)(target_bits - consumed_bits));
            }
        }
        if (reader.failed) {
            return false;
        }
        values.page_bits = page_bits;
        values.page_count = page_count;
        values.page_index = page_index;
        values.footer_rows = footer_rows;
        values.ecc_enabled = (ecc_flag != 0ull);
        values.ecc_block_data = (u16)ecc_block_data;
        values.ecc_parity = (u16)ecc_parity;
        values.ecc_block_count = ecc_block_count;
        values.ecc_original_bytes = ecc_original_bytes;
        values.has_palette = palette_flag && spec.palette_bytes && (palette_length > 0u);
        values.palette_base = palette_base;
        values.palette_length = palette_length;
        return true;
    }

    static bool decode_from_bits_v3(const ByteBuffer& module_bits,
                                    u32 rows,
                                    Values& values) {
        if (rows == 0u || rows > V3_MAX_ROWS) {
            return false;
        }
        const u32 modules_per_row = V3_MODULE_COUNT;
        const u32 expected_size = modules_per_row * rows;
        if (module_bits.size < expected_size) {
            return false;
        }

        const u32 data_start = V3_QUIET_MODULES + V3_GUARD_MODULES;
        const u32 trailing_start = data_start + V3_DATA_MODULES;
        u32 guard_errors = 0u;
        for (u32 row = 0u; row < rows; ++row) {
            u32 row_offset = row * modules_per_row;
            for (u32 i = 0u; i < V3_BARKER_MODULES; ++i) {
                if (module_bits.data[row_offset + V3_QUIET_MODULES + i] != Barker11[i]) {
                    ++guard_errors;
                }
            }
            for (u32 i = 0u; i < V3_TIMING_MODULES; ++i) {
                if (module_bits.data[row_offset + V3_QUIET_MODULES + V3_BARKER_MODULES + i] != TimingPattern[i]) {
                    ++guard_errors;
                }
            }
            for (u32 i = 0u; i < V3_TIMING_MODULES; ++i) {
                if (module_bits.data[row_offset + trailing_start + i] != TimingPattern[i]) {
                    ++guard_errors;
                }
            }
            for (u32 i = 0u; i < V3_BARKER_MODULES; ++i) {
                if (module_bits.data[row_offset + trailing_start + V3_TIMING_MODULES + i] != Barker11[i]) {
                    ++guard_errors;
                }
            }
        }
        const bool guard_strong = (guard_errors <= rows * 2u);
        // Guard has 34 checks per row (11+6 left, 6+11 right). If we can't match at least
        // ~5/6 of these, we are almost certainly not aligned to the stripe, and brute-forcing
        // layouts below becomes prohibitively expensive.
        if (guard_errors > rows * 6u) {
            if (debug_logging_enabled()) {
                static u32 guard_error_log_budget = 0u;
                if (guard_error_log_budget < 64u) {
                    ++guard_error_log_budget;
                    console_write(2, "debug v3 stripe: guard errors rows=");
                    char row_buf[8];
                    u64_to_ascii(rows, row_buf, sizeof(row_buf));
                    console_write(2, row_buf);
                    console_write(2, " errors=");
                    char buf[16];
                    u64_to_ascii(guard_errors, buf, sizeof(buf));
                    console_line(2, buf);
                }
            }
            return false;
        }

        const u32 available_bits = rows * V3_DATA_MODULES;
        ByteBuffer data_bits;
        if (!data_bits.ensure(available_bits)) {
            return false;
        }
        data_bits.size = available_bits;
        usize bit_cursor = 0u;
        for (u32 row = 0u; row < rows; ++row) {
            u32 row_offset = row * modules_per_row + data_start;
            for (u32 i = 0u; i < V3_DATA_MODULES; ++i) {
                data_bits.data[bit_cursor++] = module_bits.data[row_offset + i];
            }
        }
        if (bit_cursor != available_bits) {
            return false;
        }
        if (available_bits < V3_HEADER_BYTES * 8u) {
            return false;
        }

        const u32 max_bits_supported = (u32)RS_POLY_CAPACITY * 8u;
        u32 preview_bits = (available_bits < max_bits_supported) ? available_bits : max_bits_supported;
        u8 preview_bytes[RS_POLY_CAPACITY];
        memset(preview_bytes, 0, sizeof(preview_bytes));
        for (u32 i = 0u; i < preview_bits; ++i) {
            if (data_bits.data[i]) {
                preview_bytes[i >> 3u] = (u8)(preview_bytes[i >> 3u] | (1u << (i & 7u)));
            }
        }

        makocode::BitReader header_reader;
        header_reader.reset(preview_bytes, preview_bits);
        u64 schema = header_reader.read_bits(4u);
        u64 row_count = header_reader.read_bits(6u);
        u64 modules_per_row_hdr = header_reader.read_bits(7u);
        u64 module_pitch = header_reader.read_bits(8u);
        u64 parity_bytes = header_reader.read_bits(8u);
        u64 payload_bytes = header_reader.read_bits(16u);
        u64 flags = header_reader.read_bits(8u);
        u64 palette_base = header_reader.read_bits(5u);
        u64 palette_length = header_reader.read_bits(12u);
        if (!header_reader.align_to_byte() || header_reader.failed) {
            return false;
        }
        // Use preview purely as a hint; allow RS to correct small header corruption.
        if (schema != (u64)V3_SCHEMA_VERSION && debug_logging_enabled()) {
            console_write(2, "debug v3 stripe: schema preview mismatch rows=");
            char buf[8];
            u64_to_ascii(rows, buf, sizeof(buf));
            console_line(2, buf);
        }
        if (row_count != rows && debug_logging_enabled()) {
            console_write(2, "debug v3 stripe: row_count preview mismatch rows=");
            char buf[8];
            u64_to_ascii(rows, buf, sizeof(buf));
            console_line(2, buf);
        }
        if (modules_per_row_hdr != V3_MODULE_COUNT && debug_logging_enabled()) {
            console_line(2, "debug v3 stripe: module_count preview mismatch");
        }
	        if (module_pitch != V3_MODULE_PITCH && debug_logging_enabled()) {
	            console_line(2, "debug v3 stripe: module_pitch preview mismatch");
	        }
	        (void)flags; // preview-only
	        (void)palette_base; // preview-only
	        (void)palette_length; // preview-only (validated after RS decode)
	        const u32 header_bytes = V3_HEADER_BYTES;
	        const u32 crc_bytes = 1u;
	        auto decode_corrected_codeword = [&](u8* codeword_buf,
	                                            u32 metadata_bytes_local,
	                                            u32 parity_bytes_local,
	                                            u32 payload_bytes_local) -> bool {
	            if (!codeword_buf || metadata_bytes_local == 0u || parity_bytes_local == 0u) {
	                return false;
	            }
	            BitReader reader;
	            reader.reset(codeword_buf, (metadata_bytes_local - 1u) * 8u);
	            u64 schema_fixed = reader.read_bits(4u);
	            u64 row_count_fixed = reader.read_bits(6u);
	            u64 modules_fixed = reader.read_bits(7u);
	            u64 pitch_fixed = reader.read_bits(8u);
	            u64 parity_fixed = reader.read_bits(8u);
	            u64 payload_fixed = reader.read_bits(16u);
	            u64 corrected_flags = reader.read_bits(8u);
	            u64 pal_base = reader.read_bits(5u);
	            u64 pal_length = reader.read_bits(12u);
	            if (!reader.align_to_byte()) {
	                return false;
	            }
	            if (schema_fixed != (u64)V3_SCHEMA_VERSION) {
	                return false;
	            }
	            if (row_count_fixed != (u64)rows) {
	                return false;
	            }
	            if (modules_fixed != (u64)V3_MODULE_COUNT) {
	                return false;
	            }
	            if (pitch_fixed != (u64)V3_MODULE_PITCH) {
	                return false;
	            }
	            if (parity_fixed != (u64)parity_bytes_local) {
	                return false;
	            }
	            if (payload_fixed != (u64)payload_bytes_local) {
	                return false;
	            }
	            u64 page_bits = reader.read_bits(24u);
	            u64 page_count = reader.read_bits(20u);
	            u64 page_index = reader.read_bits(20u);
	            u64 footer_rows = reader.read_bits(8u);
	            u64 ecc_flag = reader.read_bits(1u);
	            u64 ecc_block_data = reader.read_bits(10u);
	            u64 ecc_parity = reader.read_bits(10u);
	            u64 ecc_block_count = reader.read_bits(20u);
	            u64 ecc_original_bytes = reader.read_bits(28u);
	            u64 page_width_px = reader.read_bits(16u);
	            u64 page_height_px = reader.read_bits(16u);
	            u64 fiducial_marker_size_px = reader.read_bits(8u);
	            if (reader.failed) {
	                return false;
	            }
	            bool has_palette = ((corrected_flags & 1u) != 0u) && pal_length > 0u;
	            if (has_palette) {
	                if (pal_length > MAX_STRIPE_PALETTE_BYTES) {
	                    return false;
	                }
	                u32 pal_len_u32 = (u32)pal_length;
	                for (u32 i = 0u; i < pal_len_u32; ++i) {
	                    u64 byte_val = reader.read_bits(8u);
	                    if (reader.failed) {
	                        return false;
	                    }
	                    values.palette_bytes[i] = (u8)byte_val;
	                }
	            }
	            values.page_bits = page_bits;
	            values.page_count = page_count;
	            values.page_index = page_index;
	            values.footer_rows = footer_rows;
	            values.fiducial_marker_size_pixels = (u32)fiducial_marker_size_px;
	            values.ecc_enabled = (ecc_flag != 0u);
	            values.ecc_block_data = (u16)ecc_block_data;
	            values.ecc_parity = (u16)ecc_parity;
	            values.ecc_block_count = ecc_block_count;
	            values.ecc_original_bytes = ecc_original_bytes;
	            values.page_width_pixels = (u32)page_width_px;
	            values.page_height_pixels = (u32)page_height_px;
	            values.has_palette = has_palette;
	            values.palette_base = (u8)pal_base;
	            values.palette_length = (u16)pal_length;
	            values.v3_rows = rows;
	            values.v3_modules_per_row = V3_MODULE_COUNT;
	            values.v3_module_pitch = V3_MODULE_PITCH;
	            values.v3_parity_bytes = parity_bytes_local;
	            values.v3_metadata_bytes = metadata_bytes_local;
	            values.v3_payload_bytes = payload_bytes_local;
	            return true;
	        };
	        auto try_decode_with_layout = [&](u32 payload_bytes_local, u32 parity_bytes_local) -> bool {
	            if (parity_bytes_local < V3_MIN_PARITY_BYTES || parity_bytes_local > V3_MAX_PARITY_BYTES) {
	                return false;
	            }
	            u32 metadata_bytes_local = header_bytes + payload_bytes_local + crc_bytes;
	            u32 codeword_bytes_local = metadata_bytes_local + parity_bytes_local;
	            if (codeword_bytes_local == 0u || codeword_bytes_local > RS_POLY_CAPACITY) {
	                return false;
	            }
	            u32 required_bits_local = codeword_bytes_local * 8u;
	            if (required_bits_local > available_bits) {
	                return false;
	            }
	            u8 codeword_buf[RS_POLY_CAPACITY];
	            memset(codeword_buf, 0, sizeof(codeword_buf));
	            u32 bits_per_row_base_local = required_bits_local / rows;
	            u32 bits_remainder_local = required_bits_local % rows;
	            u32 codeword_cursor_local = 0u;
	            for (u32 row = 0u; row < rows; ++row) {
	                u32 bits_in_row = bits_per_row_base_local + ((row < bits_remainder_local) ? 1u : 0u);
	                if (bits_in_row > V3_DATA_MODULES) {
	                    return false;
	                }
	                u32 row_offset = row * V3_DATA_MODULES;
	                for (u32 i = 0u; i < bits_in_row; ++i) {
	                    if (data_bits.data[row_offset + i]) {
	                        codeword_buf[codeword_cursor_local >> 3u] =
	                            (u8)(codeword_buf[codeword_cursor_local >> 3u] | (1u << (codeword_cursor_local & 7u)));
	                    }
	                    ++codeword_cursor_local;
	                }
	            }
	            if (codeword_cursor_local != required_bits_local) {
	                return false;
	            }
	            u16 corrections = 0u;
	            if (!rs_decode_block(codeword_buf, (u16)metadata_bytes_local, (u16)parity_bytes_local, &corrections)) {
	                return false;
	            }
	            u8 stored_crc = codeword_buf[metadata_bytes_local - 1u];
	            u8 computed_crc = compute_crc8(codeword_buf, metadata_bytes_local - 1u);
	            if (computed_crc != stored_crc) {
	                return false;
	            }
	            return decode_corrected_codeword(codeword_buf, metadata_bytes_local, parity_bytes_local, payload_bytes_local);
	        };
	        auto fast_fallback_decode = [&]() -> bool {
	            // This path is hit very frequently during stripe search. Keep it tight:
	            // try only the most likely layouts first (fixed payload, small neighborhood).
	            const u32 parity = V3_MIN_PARITY_BYTES;
	            u32 max_payload = RS_POLY_CAPACITY - header_bytes - crc_bytes - parity;
	            if (max_payload > 128u) {
	                max_payload = 128u;
	            }
	            const u32 likely_payload = footer_v3_payload_bytes(0u, false);
	            const u32 candidates[] = {
	                likely_payload,
	                likely_payload + 1u,
	                (likely_payload > 0u) ? (likely_payload - 1u) : 0u,
	                likely_payload + 2u,
	                likely_payload + 4u,
	                likely_payload + 8u,
	                likely_payload + 16u,
	            };
	            for (u32 i = 0u; i < (u32)(sizeof(candidates) / sizeof(candidates[0])); ++i) {
	                u32 payload = candidates[i];
	                if (payload <= max_payload && try_decode_with_layout(payload, parity)) {
	                    return true;
	                }
	            }
	            return false;
	        };

	        auto brute_force_decode_full = [&]() -> bool {
	            // Full search: only use when we're reasonably sure we're aligned and just
	            // need to recover header/payload sizing via RS+CRC.
	            const u32 parity = V3_MIN_PARITY_BYTES;
	            u32 max_payload = RS_POLY_CAPACITY - header_bytes - crc_bytes - parity;
	            if (max_payload > 128u) {
	                max_payload = 128u;
	            }
	            for (u32 payload = 0u; payload <= max_payload; ++payload) {
	                if (try_decode_with_layout(payload, parity)) {
	                    return true;
	                }
	            }
	            return false;
	        };

	        bool preview_parity_ok = (parity_bytes >= V3_MIN_PARITY_BYTES && parity_bytes <= V3_MAX_PARITY_BYTES);
	        u32 metadata_bytes = header_bytes + (u32)payload_bytes + crc_bytes;
	        u32 codeword_bytes = metadata_bytes + (u32)parity_bytes;
	        bool preview_layout_ok = preview_parity_ok && (codeword_bytes > 0u && codeword_bytes <= RS_POLY_CAPACITY);
	        u32 required_bits = preview_layout_ok ? (codeword_bytes * 8u) : 0u;
	        bool preview_header_plausible =
	            (schema == (u64)V3_SCHEMA_VERSION) &&
	            (row_count == (u64)rows) &&
	            (modules_per_row_hdr == (u64)V3_MODULE_COUNT) &&
	            (module_pitch == (u64)V3_MODULE_PITCH);
	        if (!preview_layout_ok || required_bits > available_bits) {
	            if (guard_strong) {
	                if (preview_header_plausible) {
	                    if (brute_force_decode_full()) {
	                        return true;
	                    }
	                } else {
	                    if (fast_fallback_decode()) {
	                        return true;
	                    }
	                }
	            }
	            if (debug_logging_enabled()) {
	                static u32 brute_force_log_budget = 0u;
	                if (brute_force_log_budget < 64u) {
	                    ++brute_force_log_budget;
	                    console_write(2, "debug v3 stripe: brute force decode failed rows=");
	                    char buf[8];
	                    u64_to_ascii(rows, buf, sizeof(buf));
	                    console_line(2, buf);
	                }
	            }
	            return false;
	        }

        u8 codeword[RS_POLY_CAPACITY];
        memset(codeword, 0, sizeof(codeword));
        u32 bits_per_row_base = required_bits / rows;
        u32 bits_remainder = required_bits % rows;
        u32 codeword_cursor = 0u;
        for (u32 row = 0u; row < rows; ++row) {
            u32 bits_in_row = bits_per_row_base + ((row < bits_remainder) ? 1u : 0u);
            if (bits_in_row > V3_DATA_MODULES) {
                return false;
            }
            u32 row_offset = row * V3_DATA_MODULES;
            for (u32 i = 0u; i < bits_in_row; ++i) {
                if (data_bits.data[row_offset + i]) {
                    codeword[codeword_cursor >> 3u] = (u8)(codeword[codeword_cursor >> 3u] | (1u << (codeword_cursor & 7u)));
                }
                ++codeword_cursor;
            }
        }
        if (codeword_cursor != required_bits) {
            return false;
        }

        u16 corrections = 0u;
        if (!rs_decode_block(codeword, (u16)metadata_bytes, (u16)parity_bytes, &corrections)) {
            if (guard_strong) {
                if (preview_header_plausible) {
                    if (brute_force_decode_full()) {
                        return true;
                    }
                } else if (fast_fallback_decode()) {
                    return true;
                }
            }
            if (debug_logging_enabled()) {
                console_write(2, "debug v3 stripe: RS decode failed rows=");
                char buf[8];
                u64_to_ascii(rows, buf, sizeof(buf));
                console_line(2, buf);
            }
            return false;
        }
        u8 stored_crc = codeword[metadata_bytes - 1u];
        u8 computed_crc = compute_crc8(codeword, metadata_bytes - 1u);
        if (computed_crc != stored_crc) {
            if (guard_strong) {
                if (preview_header_plausible) {
                    if (brute_force_decode_full()) {
                        return true;
                    }
                } else if (fast_fallback_decode()) {
                    return true;
                }
            }
            if (debug_logging_enabled()) {
                console_write(2, "debug v3 stripe: CRC mismatch rows=");
                char buf[8];
                u64_to_ascii(rows, buf, sizeof(buf));
                console_line(2, buf);
            }
            return false;
        }

        BitReader reader;
        reader.reset(codeword, (metadata_bytes - 1u) * 8u);
        reader.read_bits(4u);  // schema
        reader.read_bits(6u);  // rows
        reader.read_bits(7u);  // modules
        reader.read_bits(8u);  // pitch
        reader.read_bits(8u);  // parity
        reader.read_bits(16u); // payload
        u64 corrected_flags = reader.read_bits(8u);
        u64 pal_base = reader.read_bits(5u);
        u64 pal_length = reader.read_bits(12u);
        if (!reader.align_to_byte()) {
            return false;
        }
        u64 page_bits = reader.read_bits(24u);
        u64 page_count = reader.read_bits(20u);
        u64 page_index = reader.read_bits(20u);
        u64 footer_rows = reader.read_bits(8u);
        u64 ecc_flag = reader.read_bits(1u);
        u64 ecc_block_data = reader.read_bits(10u);
        u64 ecc_parity = reader.read_bits(10u);
        u64 ecc_block_count = reader.read_bits(20u);
	        u64 ecc_original_bytes = reader.read_bits(28u);
	        u64 page_width_px = reader.read_bits(16u);
	        u64 page_height_px = reader.read_bits(16u);
	        u64 fiducial_marker_size_px = reader.read_bits(8u);
	        if (reader.failed) {
	            if (guard_strong) {
	                if (preview_header_plausible) {
	                    if (brute_force_decode_full()) {
	                        return true;
	                    }
	                } else if (fast_fallback_decode()) {
	                    return true;
	                }
	            }
	            return false;
	        }

        bool has_palette = ((corrected_flags & 1u) != 0u) && pal_length > 0u;
        if (has_palette) {
            if (pal_length > MAX_STRIPE_PALETTE_BYTES) {
                return false;
            }
            u32 pal_len_u32 = (u32)pal_length;
            for (u32 i = 0u; i < pal_len_u32; ++i) {
                u64 byte_val = reader.read_bits(8u);
                if (reader.failed) {
                    return false;
                }
                values.palette_bytes[i] = (u8)byte_val;
            }
        }

	        values.page_bits = page_bits;
	        values.page_count = page_count;
	        values.page_index = page_index;
	        values.footer_rows = footer_rows;
	        values.fiducial_marker_size_pixels = (u32)fiducial_marker_size_px;
	        values.ecc_enabled = (ecc_flag != 0u);
        values.ecc_block_data = (u16)ecc_block_data;
        values.ecc_parity = (u16)ecc_parity;
        values.ecc_block_count = ecc_block_count;
        values.ecc_original_bytes = ecc_original_bytes;
        values.page_width_pixels = (u32)page_width_px;
        values.page_height_pixels = (u32)page_height_px;
        values.has_palette = has_palette;
        values.palette_base = (u8)pal_base;
        values.palette_length = (u16)pal_length;
        values.v3_rows = rows;
        values.v3_modules_per_row = V3_MODULE_COUNT;
        values.v3_module_pitch = V3_MODULE_PITCH;
        values.v3_parity_bytes = (u32)parity_bytes;
        values.v3_metadata_bytes = metadata_bytes;
        values.v3_payload_bytes = (u32)payload_bytes;
        return true;
    }

    static bool capture_module_row(const StripeSpec& spec,
                                   const u8* pixels,
                                   u32 width,
                                   u32 height,
                                   u32 stripe_top,
                                   u32 start_column,
                                   u32 row_index,
                                   u8* row_storage) {
        u32 module_pitch = spec.module_pitch;
        if (module_count(spec) > MAX_STRIPE_MODULES) {
            return false;
        }
        u32 sample_row = stripe_top + row_index * module_pitch + (module_pitch / 2u);
        if (sample_row >= height) {
            return false;
        }
        if (!row_storage) {
            return false;
        }
        u16 brightness[MAX_STRIPE_MODULES];
        for (u32 index = 0u; index < module_count(spec); ++index) {
            u32 sample_column = start_column + index * module_pitch + (module_pitch / 2u);
            if (sample_column >= width) {
                return false;
            }
            usize pixel_index = ((usize)sample_row * (usize)width + (usize)sample_column) * 3u;
            u32 value = (u32)pixels[pixel_index] + (u32)pixels[pixel_index + 1u] + (u32)pixels[pixel_index + 2u];
            brightness[index] = (u16)((value > 0xFFFFu) ? 0xFFFFu : value);
        }
        u32 background_sum = 0u;
        u32 background_count = 0u;
        auto add_background = [&](u32 module_idx) {
            if (module_idx < module_count(spec)) {
                background_sum += brightness[module_idx];
                ++background_count;
            }
        };
        for (u32 i = 0u; i < spec.quiet_modules; ++i) {
            add_background(i);
        }
        u32 trailing_start = spec.quiet_modules + guard_modules(spec) + max_row_data_bits(spec) + guard_modules(spec);
        for (u32 i = 0u; i < spec.quiet_modules; ++i) {
            add_background(trailing_start + i);
        }
        auto guard_bit = [&](u32 idx) -> u8 {
            if (idx < spec.barker_modules) return Barker11[idx];
            idx -= spec.barker_modules;
            if (idx < spec.timing_modules) return TimingPattern[idx];
            return 0u;
        };
        u32 guard_sum = 0u;
        u32 guard_count = 0u;
        u32 guard_start_left = spec.quiet_modules;
        u32 guard_start_right = spec.quiet_modules + guard_modules(spec) + max_row_data_bits(spec);
        for (u32 i = 0u; i < guard_modules(spec); ++i) {
            if (guard_bit(i)) {
                u32 pos_left = guard_start_left + i;
                u32 pos_right = guard_start_right + i;
                if (pos_left < module_count(spec)) {
                    guard_sum += brightness[pos_left];
                    ++guard_count;
                }
                if (pos_right < module_count(spec)) {
                    guard_sum += brightness[pos_right];
                    ++guard_count;
                }
            }
        }
        u32 threshold = 384u;
        if (background_count > 0u && guard_count > 0u) {
            u32 background_avg = background_sum / background_count;
            u32 guard_avg = guard_sum / guard_count;
            if (guard_avg < background_avg) {
                threshold = (background_avg + guard_avg) / 2u;
            } else if (background_avg > 0u) {
                threshold = background_avg / 2u;
            }
        }
        for (u32 index = 0u; index < module_count(spec); ++index) {
            row_storage[index] = (brightness[index] < threshold) ? 1u : 0u;
        }
        return true;
    }

    static bool capture_module_row_affine(const StripeSpec& spec,
                                          const u8* pixels,
                                          u32 width,
                                          u32 height,
                                          const AffineTransform& affine,
                                          double skew_y_pixels,
                                          double skew_span,
                                          double stripe_top_logical,
                                          u32 start_column,
                                          u32 row_index,
                                          u8* row_storage) {
        u32 module_pitch = spec.module_pitch;
        if (module_count(spec) > MAX_STRIPE_MODULES) {
            return false;
        }
        double logical_y = stripe_top_logical + (double)row_index * (double)module_pitch + ((double)module_pitch * 0.5);
        if (!row_storage) {
            return false;
        }
        u16 brightness[MAX_STRIPE_MODULES];
        for (u32 index = 0u; index < module_count(spec); ++index) {
            double logical_x = (double)start_column + (double)index * (double)module_pitch + ((double)module_pitch * 0.5);
            double sample_x = affine.a00 * logical_x + affine.a01 * logical_y + affine.tx;
            double sample_y = affine.a10 * logical_x + affine.a11 * logical_y + affine.ty;
            if (skew_span > 0.0 && skew_y_pixels != 0.0) {
                double norm_col = sample_x / skew_span;
                if (norm_col < 0.0) norm_col = 0.0;
                if (norm_col > 1.0) norm_col = 1.0;
                sample_y += skew_y_pixels * norm_col;
            }
            if (sample_x < 0.0) sample_x = 0.0;
            if (sample_y < 0.0) sample_y = 0.0;
            double max_x = (width > 0u) ? (double)(width - 1u) : 0.0;
            double max_y = (height > 0u) ? (double)(height - 1u) : 0.0;
            if (sample_x > max_x) sample_x = max_x;
            if (sample_y > max_y) sample_y = max_y;
            unsigned x0 = (unsigned)floor(sample_x);
            unsigned y0 = (unsigned)floor(sample_y);
            unsigned x1 = (x0 + 1u < width) ? (x0 + 1u) : x0;
            unsigned y1 = (y0 + 1u < height) ? (y0 + 1u) : y0;
            double fx = sample_x - (double)x0;
            double fy = sample_y - (double)y0;
            usize idx00 = ((usize)y0 * (usize)width + (usize)x0) * 3u;
            usize idx10 = ((usize)y0 * (usize)width + (usize)x1) * 3u;
            usize idx01 = ((usize)y1 * (usize)width + (usize)x0) * 3u;
            usize idx11 = ((usize)y1 * (usize)width + (usize)x1) * 3u;
            double rgb00 = (double)pixels[idx00] + (double)pixels[idx00 + 1u] + (double)pixels[idx00 + 2u];
            double rgb10 = (double)pixels[idx10] + (double)pixels[idx10 + 1u] + (double)pixels[idx10 + 2u];
            double rgb01 = (double)pixels[idx01] + (double)pixels[idx01 + 1u] + (double)pixels[idx01 + 2u];
            double rgb11 = (double)pixels[idx11] + (double)pixels[idx11 + 1u] + (double)pixels[idx11 + 2u];
            double top = rgb00 + (rgb10 - rgb00) * fx;
            double bottom = rgb01 + (rgb11 - rgb01) * fx;
            double value = top + (bottom - top) * fy;
            if (value < 0.0) value = 0.0;
            if (value > 765.0) value = 765.0;
            brightness[index] = (u16)(value + 0.5);
        }
        u32 background_sum = 0u;
        u32 background_count = 0u;
        auto add_background = [&](u32 module_idx) {
            if (module_idx < module_count(spec)) {
                background_sum += brightness[module_idx];
                ++background_count;
            }
        };
        for (u32 i = 0u; i < spec.quiet_modules; ++i) {
            add_background(i);
        }
        u32 trailing_start = spec.quiet_modules + guard_modules(spec) + max_row_data_bits(spec) + guard_modules(spec);
        for (u32 i = 0u; i < spec.quiet_modules; ++i) {
            add_background(trailing_start + i);
        }
        auto guard_bit = [&](u32 idx) -> u8 {
            if (idx < spec.barker_modules) return Barker11[idx];
            idx -= spec.barker_modules;
            if (idx < spec.timing_modules) return TimingPattern[idx];
            return 0u;
        };
        u32 guard_sum = 0u;
        u32 guard_count = 0u;
        u32 guard_start_left = spec.quiet_modules;
        u32 guard_start_right = spec.quiet_modules + guard_modules(spec) + max_row_data_bits(spec);
        for (u32 i = 0u; i < guard_modules(spec); ++i) {
            if (guard_bit(i)) {
                u32 pos_left = guard_start_left + i;
                u32 pos_right = guard_start_right + i;
                if (pos_left < module_count(spec)) {
                    guard_sum += brightness[pos_left];
                    ++guard_count;
                }
                if (pos_right < module_count(spec)) {
                    guard_sum += brightness[pos_right];
                    ++guard_count;
                }
            }
        }
        u32 threshold = 384u;
        if (background_count > 0u && guard_count > 0u) {
            u32 background_avg = background_sum / background_count;
            u32 guard_avg = guard_sum / guard_count;
            if (guard_avg < background_avg) {
                threshold = (background_avg + guard_avg) / 2u;
            } else if (background_avg > 0u) {
                threshold = background_avg / 2u;
            }
        }
        for (u32 index = 0u; index < module_count(spec); ++index) {
            row_storage[index] = (brightness[index] < threshold) ? 1u : 0u;
        }
        return true;
    }

    static bool capture_stripe(const StripeSpec& spec,
                               const u8* pixels,
                               u32 width,
                               u32 height,
                               u32 stripe_top,
                               u32 start_column,
                               ByteBuffer& module_bits) {
        usize total = (usize)module_count(spec) * (usize)spec.rows;
        if (!module_bits.ensure(total)) {
            return false;
        }
        module_bits.size = total;
        for (u32 row = 0u; row < spec.rows; ++row) {
            if (!capture_module_row(spec, pixels, width, height, stripe_top, start_column, row, module_bits.data + (usize)row * module_count(spec))) {
                return false;
            }
        }
        return true;
    }

    static bool decode_at(const StripeSpec& spec,
                          const u8* pixels,
                          u32 width,
                          u32 height,
                          u32 start_column,
                          u32 stripe_top,
                          Values& values) {
        if (width < pixel_width(spec)) {
            return false;
        }
        if (height < spec.module_pitch + spec.rows * spec.module_pitch) {
            return false;
        }
        if (stripe_top + spec.rows * spec.module_pitch > height) {
            return false;
        }
        ByteBuffer module_bits;
        if (!capture_stripe(spec, pixels, width, height, stripe_top, start_column, module_bits)) {
            return false;
        }
        if (debug_logging_enabled()) {
            console_write(2, "debug stripe capture prefix=");
            char prefix[64];
            u32 prefix_len = 0u;
            u32 limit = module_count(spec);
            if (limit > 32u) {
                limit = 32u;
            }
            for (u32 i = 0u; i < limit && prefix_len < (u32)(sizeof(prefix) - 1u); ++i) {
                u8 bit = module_bits.data[i];
                prefix[prefix_len++] = bit ? '1' : '0';
            }
            prefix[prefix_len] = '\0';
            console_write(2, prefix);
            console_line(2, "");
        }
        if (!decode_from_bits(spec, module_bits, values)) {
            return false;
        }
        return true;
    }

    static bool decode(const StripeSpec& spec, const u8* pixels, u32 width, u32 height, Values& values) {
        u32 left_start = 0u;
        u32 right_start = (width >= pixel_width(spec)) ? (width - pixel_width(spec)) : 0u;
        u32 stripe_height_px = stripe_height(spec);
        u32 base_top = (height > stripe_height_px) ? (height - stripe_height_px) : 0u;
        u32 max_offset = base_top;
        if (max_offset > 256u) {
            max_offset = 256u;
        }
        for (u32 offset = 0u; offset <= max_offset; offset += spec.module_pitch) {
            if (base_top < offset) {
                break;
            }
            u32 stripe_top = base_top - offset;
            ByteBuffer left_bits;
            if (decode_at(spec, pixels, width, height, left_start, stripe_top, values)) {
                return true;
            }
            bool left_ok = capture_stripe(spec, pixels, width, height, stripe_top, left_start, left_bits);
            ByteBuffer right_bits;
            bool right_ok = false;
            if (right_start != left_start) {
                if (decode_at(spec, pixels, width, height, right_start, stripe_top, values)) {
                    return true;
                }
                right_ok = capture_stripe(spec, pixels, width, height, stripe_top, right_start, right_bits);
            }
            if (left_ok && right_ok && left_bits.size == right_bits.size && left_bits.size > 0u) {
                ByteBuffer combined;
                if (!combined.ensure(left_bits.size)) {
                    return false;
                }
                combined.size = left_bits.size;
                for (usize i = 0u; i < left_bits.size; ++i) {
                    u8 l = left_bits.data[i];
                    u8 r = right_bits.data[i];
                    combined.data[i] = (u8)((l | r) ? 1u : 0u);
                }
                if (decode_from_bits(spec, combined, values)) {
                    return true;
                }
            }
        }
        return false;
    }

	    static bool capture_stripe_v3(const u8* pixels,
	                                  u32 width,
	                                  u32 height,
	                                  u32 row_count,
	                                  u32 stripe_top,
	                                  u32 start_column,
	                                  u32 module_pitch_x,
	                                  u32 module_pitch_y,
	                                  ByteBuffer& module_bits) {
        usize total = (usize)V3_MODULE_COUNT * (usize)row_count;
        if (row_count == 0u || row_count > V3_MAX_ROWS) {
            return false;
        }
        if (!module_bits.ensure(total)) {
            return false;
        }
        module_bits.size = total;
        for (u32 row = 0u; row < row_count; ++row) {
            u32 sample_row = stripe_top + row * module_pitch_y + (module_pitch_y / 2u);
            if (sample_row >= height) {
                return false;
            }
            u16 brightness[MAX_STRIPE_MODULES];
            for (u32 index = 0u; index < V3_MODULE_COUNT; ++index) {
                u32 sample_column = start_column + index * module_pitch_x + (module_pitch_x / 2u);
                if (sample_column >= width) {
                    return false;
                }
                usize pixel_index = ((usize)sample_row * (usize)width + (usize)sample_column) * 3u;
                u32 value = (u32)pixels[pixel_index] + (u32)pixels[pixel_index + 1u] + (u32)pixels[pixel_index + 2u];
                brightness[index] = (u16)((value > 0xFFFFu) ? 0xFFFFu : value);
            }
            auto guard_bit = [&](u32 idx) -> u8 {
                if (idx < V3_BARKER_MODULES) return Barker11[idx];
                idx -= V3_BARKER_MODULES;
                if (idx < V3_TIMING_MODULES) return TimingPattern[idx];
                return 0u;
            };
            u32 background_sum = 0u;
            u32 background_count = 0u;
            auto add_background = [&](u32 module_idx) {
                if (module_idx < V3_MODULE_COUNT) {
                    background_sum += brightness[module_idx];
                    ++background_count;
                }
            };
            for (u32 i = 0u; i < V3_QUIET_MODULES; ++i) {
                add_background(i);
            }
            u32 trailing_start = V3_QUIET_MODULES + V3_GUARD_MODULES + V3_DATA_MODULES + V3_GUARD_MODULES;
            for (u32 i = 0u; i < V3_QUIET_MODULES; ++i) {
                add_background(trailing_start + i);
            }
            u32 guard_start_left = V3_QUIET_MODULES;
            u32 guard_start_right = V3_QUIET_MODULES + V3_GUARD_MODULES + V3_DATA_MODULES;
            u32 guard_sum = 0u;
            u32 guard_count = 0u;
            for (u32 i = 0u; i < V3_GUARD_MODULES; ++i) {
                if (guard_bit(i)) {
                    u32 pos_left = guard_start_left + i;
                    u32 pos_right = guard_start_right + i;
                    if (pos_left < V3_MODULE_COUNT) {
                        guard_sum += brightness[pos_left];
                        ++guard_count;
                    }
                    if (pos_right < V3_MODULE_COUNT) {
                        guard_sum += brightness[pos_right];
                        ++guard_count;
                    }
                }
            }
            u32 threshold = 384u;
            if (background_count > 0u && guard_count > 0u) {
                u32 background_avg = background_sum / background_count;
                u32 guard_avg = guard_sum / guard_count;
                if (guard_avg < background_avg) {
                    threshold = (background_avg + guard_avg) / 2u;
                } else if (background_avg > 0u) {
                    threshold = background_avg / 2u;
                }
            }
            u8* row_storage = module_bits.data + (usize)row * V3_MODULE_COUNT;
            for (u32 index = 0u; index < V3_MODULE_COUNT; ++index) {
                row_storage[index] = (brightness[index] < threshold) ? 1u : 0u;
            }
        }
	        return true;
	    }

	    static bool capture_stripe_v3_float(const u8* pixels,
	                                        u32 width,
	                                        u32 height,
	                                        u32 row_count,
	                                        double stripe_top,
	                                        double start_column,
	                                        double module_pitch_x,
	                                        double module_pitch_y,
	                                        ByteBuffer& module_bits) {
	        if (!pixels || width == 0u || height == 0u) {
	            return false;
	        }
	        if (row_count == 0u || row_count > V3_MAX_ROWS) {
	            return false;
	        }
	        if (!(module_pitch_x > 0.0) || !(module_pitch_y > 0.0)) {
	            return false;
	        }
	        usize total = (usize)V3_MODULE_COUNT * (usize)row_count;
	        if (!module_bits.ensure(total)) {
	            return false;
	        }
	        module_bits.size = total;
	        double max_x = (width > 0u) ? (double)(width - 1u) : 0.0;
	        double max_y = (height > 0u) ? (double)(height - 1u) : 0.0;
	        // Avoid sampling near module edges: nearest-neighbor resampling at non-integer
	        // scale factors (e.g. 2.6x) causes uneven module widths, and edge taps can
	        // spill into adjacent modules.
	        const double taps[] = {0.40, 0.50, 0.60};
	        for (u32 row = 0u; row < row_count; ++row) {
	            u16 brightness[MAX_STRIPE_MODULES];
	            for (u32 index = 0u; index < V3_MODULE_COUNT; ++index) {
	                double y0 = stripe_top + (double)row * module_pitch_y;
	                double x0 = start_column + (double)index * module_pitch_x;
	                u32 value_sum = 0u;
	                u32 sample_count = 0u;
	                for (u32 ty = 0u; ty < 3u; ++ty) {
	                    double sample_row = y0 + module_pitch_y * taps[ty];
	                    if (sample_row < 0.0) sample_row = 0.0;
	                    if (sample_row > max_y) sample_row = max_y;
	                    u32 sample_row_i = (u32)(sample_row + 0.5);
	                    if (sample_row_i >= height) {
	                        continue;
	                    }
	                    for (u32 tx = 0u; tx < 3u; ++tx) {
	                        double sample_col = x0 + module_pitch_x * taps[tx];
	                        if (sample_col < 0.0) sample_col = 0.0;
	                        if (sample_col > max_x) sample_col = max_x;
	                        u32 sample_col_i = (u32)(sample_col + 0.5);
	                        if (sample_col_i >= width) {
	                            continue;
	                        }
	                        usize pixel_index = ((usize)sample_row_i * (usize)width + (usize)sample_col_i) * 3u;
	                        value_sum += (u32)pixels[pixel_index] + (u32)pixels[pixel_index + 1u] + (u32)pixels[pixel_index + 2u];
	                        ++sample_count;
	                    }
	                }
	                if (sample_count == 0u) {
	                    return false;
	                }
	                u32 value = value_sum / sample_count;
	                brightness[index] = (u16)((value > 0xFFFFu) ? 0xFFFFu : value);
	            }
	            auto guard_bit = [&](u32 idx) -> u8 {
	                if (idx < V3_BARKER_MODULES) return Barker11[idx];
	                idx -= V3_BARKER_MODULES;
	                if (idx < V3_TIMING_MODULES) return TimingPattern[idx];
	                return 0u;
	            };
	            u32 background_sum = 0u;
	            u32 background_count = 0u;
	            auto add_background = [&](u32 module_idx) {
	                if (module_idx < V3_MODULE_COUNT) {
	                    background_sum += brightness[module_idx];
	                    ++background_count;
	                }
	            };
	            for (u32 i = 0u; i < V3_QUIET_MODULES; ++i) {
	                add_background(i);
	            }
	            u32 trailing_start = V3_QUIET_MODULES + V3_GUARD_MODULES + V3_DATA_MODULES + V3_GUARD_MODULES;
	            for (u32 i = 0u; i < V3_QUIET_MODULES; ++i) {
	                add_background(trailing_start + i);
	            }
	            u32 guard_start_left = V3_QUIET_MODULES;
	            u32 guard_start_right = V3_QUIET_MODULES + V3_GUARD_MODULES + V3_DATA_MODULES;
	            u32 guard_sum = 0u;
	            u32 guard_count = 0u;
	            for (u32 i = 0u; i < V3_GUARD_MODULES; ++i) {
	                if (guard_bit(i)) {
	                    u32 pos_left = guard_start_left + i;
	                    u32 pos_right = guard_start_right + i;
	                    if (pos_left < V3_MODULE_COUNT) {
	                        guard_sum += brightness[pos_left];
	                        ++guard_count;
	                    }
	                    if (pos_right < V3_MODULE_COUNT) {
	                        guard_sum += brightness[pos_right];
	                        ++guard_count;
	                    }
	                }
	            }
	            u32 threshold = 384u;
	            if (background_count > 0u && guard_count > 0u) {
	                u32 background_avg = background_sum / background_count;
	                u32 guard_avg = guard_sum / guard_count;
	                if (guard_avg < background_avg) {
	                    threshold = (background_avg + guard_avg) / 2u;
	                } else if (background_avg > 0u) {
	                    threshold = background_avg / 2u;
	                }
	            }
	            u8* row_storage = module_bits.data + (usize)row * V3_MODULE_COUNT;
	            for (u32 index = 0u; index < V3_MODULE_COUNT; ++index) {
	                row_storage[index] = (brightness[index] < threshold) ? 1u : 0u;
	            }
	        }
	        return true;
	    }

	    static bool capture_stripe_v3_affine(const u8* pixels,
	                                         u32 width,
	                                         u32 height,
	                                         u32 row_count,
	                                         const AffineTransform& affine,
                                         double skew_y_pixels,
                                         double skew_span,
                                         double stripe_top_logical,
                                         u32 start_column,
                                         ByteBuffer& module_bits) {
        usize total = (usize)V3_MODULE_COUNT * (usize)row_count;
        if (row_count == 0u || row_count > V3_MAX_ROWS) {
            return false;
        }
        if (!module_bits.ensure(total)) {
            return false;
        }
        module_bits.size = total;
        for (u32 row = 0u; row < row_count; ++row) {
            double logical_y = stripe_top_logical + (double)row * (double)V3_MODULE_PITCH + ((double)V3_MODULE_PITCH * 0.5);
            u16 brightness[MAX_STRIPE_MODULES];
            for (u32 index = 0u; index < V3_MODULE_COUNT; ++index) {
                double logical_x = (double)start_column + (double)index * (double)V3_MODULE_PITCH + ((double)V3_MODULE_PITCH * 0.5);
                double sample_x = affine.a00 * logical_x + affine.a01 * logical_y + affine.tx;
                double sample_y = affine.a10 * logical_x + affine.a11 * logical_y + affine.ty;
                if (skew_span > 0.0 && skew_y_pixels != 0.0) {
                    double norm_col = sample_x / skew_span;
                    if (norm_col < 0.0) norm_col = 0.0;
                    if (norm_col > 1.0) norm_col = 1.0;
                    sample_y += skew_y_pixels * norm_col;
                }
                if (sample_x < 0.0) sample_x = 0.0;
                if (sample_y < 0.0) sample_y = 0.0;
                double max_x = (width > 0u) ? (double)(width - 1u) : 0.0;
                double max_y = (height > 0u) ? (double)(height - 1u) : 0.0;
                if (sample_x > max_x) sample_x = max_x;
                if (sample_y > max_y) sample_y = max_y;
                unsigned x0 = (unsigned)floor(sample_x);
                unsigned y0 = (unsigned)floor(sample_y);
                unsigned x1 = (x0 + 1u < width) ? (x0 + 1u) : x0;
                unsigned y1 = (y0 + 1u < height) ? (y0 + 1u) : y0;
                double fx = sample_x - (double)x0;
                double fy = sample_y - (double)y0;
                usize idx00 = ((usize)y0 * (usize)width + (usize)x0) * 3u;
                usize idx10 = ((usize)y0 * (usize)width + (usize)x1) * 3u;
                usize idx01 = ((usize)y1 * (usize)width + (usize)x0) * 3u;
                usize idx11 = ((usize)y1 * (usize)width + (usize)x1) * 3u;
                double rgb00 = (double)pixels[idx00] + (double)pixels[idx00 + 1u] + (double)pixels[idx00 + 2u];
                double rgb10 = (double)pixels[idx10] + (double)pixels[idx10 + 1u] + (double)pixels[idx10 + 2u];
                double rgb01 = (double)pixels[idx01] + (double)pixels[idx01 + 1u] + (double)pixels[idx01 + 2u];
                double rgb11 = (double)pixels[idx11] + (double)pixels[idx11 + 1u] + (double)pixels[idx11 + 2u];
                double top = rgb00 + (rgb10 - rgb00) * fx;
                double bottom = rgb01 + (rgb11 - rgb01) * fx;
                double value = top + (bottom - top) * fy;
                if (value < 0.0) value = 0.0;
                if (value > 765.0) value = 765.0;
                brightness[index] = (u16)(value + 0.5);
            }
            u32 background_sum = 0u;
            u32 background_count = 0u;
            auto add_background = [&](u32 module_idx) {
                if (module_idx < V3_MODULE_COUNT) {
                    background_sum += brightness[module_idx];
                    ++background_count;
                }
            };
            for (u32 i = 0u; i < V3_QUIET_MODULES; ++i) {
                add_background(i);
            }
            u32 trailing_start = V3_QUIET_MODULES + V3_GUARD_MODULES + V3_DATA_MODULES + V3_GUARD_MODULES;
            for (u32 i = 0u; i < V3_QUIET_MODULES; ++i) {
                add_background(trailing_start + i);
            }
            auto guard_bit = [&](u32 idx) -> u8 {
                if (idx < V3_BARKER_MODULES) return Barker11[idx];
                idx -= V3_BARKER_MODULES;
                if (idx < V3_TIMING_MODULES) return TimingPattern[idx];
                return 0u;
            };
            u32 guard_sum = 0u;
            u32 guard_count = 0u;
            u32 guard_start_left = V3_QUIET_MODULES;
            u32 guard_start_right = V3_QUIET_MODULES + V3_GUARD_MODULES + V3_DATA_MODULES;
            for (u32 i = 0u; i < V3_GUARD_MODULES; ++i) {
                if (guard_bit(i)) {
                    u32 pos_left = guard_start_left + i;
                    u32 pos_right = guard_start_right + i;
                    if (pos_left < V3_MODULE_COUNT) {
                        guard_sum += brightness[pos_left];
                        ++guard_count;
                    }
                    if (pos_right < V3_MODULE_COUNT) {
                        guard_sum += brightness[pos_right];
                        ++guard_count;
                    }
                }
            }
            u32 threshold = 384u;
            if (background_count > 0u && guard_count > 0u) {
                u32 background_avg = background_sum / background_count;
                u32 guard_avg = guard_sum / guard_count;
                if (guard_avg < background_avg) {
                    threshold = (background_avg + guard_avg) / 2u;
                } else if (background_avg > 0u) {
                    threshold = background_avg / 2u;
                }
            }
            u8* row_storage = module_bits.data + (usize)row * V3_MODULE_COUNT;
            for (u32 index = 0u; index < V3_MODULE_COUNT; ++index) {
                row_storage[index] = (brightness[index] < threshold) ? 1u : 0u;
            }
        }
        return true;
    }

    static bool decode_v3(const u8* pixels, u32 width, u32 height, Values& values) {
        if (!pixels || width == 0u || height == 0u) {
            return false;
        }

        // Heuristic fast path for non-integer rescaling:
        // Try to detect the stripe bounds at the bottom edge (near left/right) and derive
        // pitch from the observed stripe width/height. This avoids the very large search
        // space of the generic float-pitch loop.
        auto try_decode_from_bottom_probe = [&](bool probe_right) -> bool {
            const bool dbg = debug_logging_enabled();
            static u32 probe_log_budget = 0u;
            const u32 probe_span = 512u;
            const u32 probe_width = (width < probe_span) ? width : probe_span;
            const u32 probe_x0 = probe_right ? ((width > probe_width) ? (width - probe_width) : 0u) : 0u;
            const u32 probe_x1 = probe_x0 + probe_width;

            auto pixel_sum = [&](u32 x, u32 y) -> u32 {
                usize idx = ((usize)y * (usize)width + (usize)x) * 3u;
                return (u32)pixels[idx] + (u32)pixels[idx + 1u] + (u32)pixels[idx + 2u];
            };

            auto row_has_ink = [&](u32 y) -> bool {
                // Count "ink" pixels in the probe window for this row.
                u32 ink = 0u;
                for (u32 x = probe_x0; x < probe_x1; ++x) {
                    if (pixel_sum(x, y) < 740u) {
                        ++ink;
                    }
                }
                // Require a small but non-trivial amount of ink to avoid confusing all-white
                // footer padding with a stripe.
                return ink > (probe_width / 64u);
            };

            // Find bottom-most contiguous band with ink.
            u32 y = height;
            while (y > 0u && !row_has_ink(y - 1u)) {
                --y;
            }
            if (y == 0u) {
                if (dbg && probe_log_budget < 8u) {
                    ++probe_log_budget;
                    console_line(2, "debug v3 stripe probe: no ink at bottom");
                }
                return false;
            }
            u32 stripe_bottom = y - 1u;
            while (y > 0u && row_has_ink(y - 1u)) {
                --y;
            }
            u32 stripe_top = y;
            u32 stripe_height_px = stripe_bottom - stripe_top + 1u;
            if (stripe_height_px < 4u || stripe_height_px > 1024u) {
                if (dbg && probe_log_budget < 8u) {
                    ++probe_log_budget;
                    console_line(2, "debug v3 stripe probe: stripe height out of range");
                }
                return false;
            }

            // Estimate stripe width by finding a long, near-all-white gap.
            u32 y_mid = stripe_top + stripe_height_px / 2u;
            const u32 gap_len = 64u;
            auto col_has_ink = [&](u32 x) -> bool {
                // Sample multiple taps across the stripe height so we don't accidentally
                // land on an all-white scanline for a long run of modules.
                (void)y_mid;
                const u32 taps = 9u;
                for (u32 t = 0u; t < taps; ++t) {
                    u32 yy = stripe_top + (u32)(((u64)(stripe_height_px - 1u) * (u64)(t + 1u)) / (u64)(taps + 1u));
                    if (yy >= height) {
                        continue;
                    }
                    if (pixel_sum(x, yy) < 740u) {
                        return true;
                    }
                }
                return false;
            };

            u32 stripe_width_px = 0u;
            if (!probe_right) {
                for (u32 x = 0u; x + gap_len < width; ++x) {
                    bool gap = true;
                    for (u32 k = 0u; k < gap_len; ++k) {
                        if (col_has_ink(x + k)) {
                            gap = false;
                            break;
                        }
                    }
                    if (gap) {
                        stripe_width_px = x;
                        break;
                    }
                }
            } else {
                for (u32 x = width; x > gap_len; --x) {
                    bool gap = true;
                    for (u32 k = 0u; k < gap_len; ++k) {
                        u32 xx = (x - 1u) - k;
                        if (col_has_ink(xx)) {
                            gap = false;
                            break;
                        }
                    }
                    if (gap) {
                        stripe_width_px = width - x;
                        break;
                    }
                }
            }
            if (stripe_width_px < 32u || stripe_width_px > width) {
                if (dbg && probe_log_budget < 8u) {
                    ++probe_log_budget;
                    console_line(2, "debug v3 stripe probe: stripe width not found");
                }
                return false;
            }

            // The V3 stripe ends with a 2-module quiet zone of all-white pixels. Our "gap"
            // detector tends to fire at the beginning of that quiet zone. Compensate by
            // adding ~2 modules worth of pixels using a quick self-consistent estimate.
            {
                double pitch_guess = (double)stripe_width_px / (double)V3_MODULE_COUNT;
                u32 quiet_px = (u32)(pitch_guess * (double)V3_QUIET_MODULES + 0.5);
                if (quiet_px > 0u && stripe_width_px + quiet_px <= width) {
                    stripe_width_px += quiet_px;
                }
            }

            double pitch_x = (double)stripe_width_px / (double)V3_MODULE_COUNT;
            if (!(pitch_x > 0.9) || pitch_x > 64.0) {
                if (dbg && probe_log_budget < 8u) {
                    ++probe_log_budget;
                    console_line(2, "debug v3 stripe probe: pitch_x out of range");
                }
                return false;
            }
            double start_base = probe_right ? ((double)width - (double)stripe_width_px) : 0.0;
            double stripe_top_f = (double)stripe_top;
            if (dbg && probe_log_budget < 8u) {
                ++probe_log_budget;
                console_write(2, "debug v3 stripe probe: side=");
                console_write(2, probe_right ? "right" : "left");
                console_write(2, " top=");
                char buf[32];
                u64_to_ascii((u64)stripe_top, buf, sizeof(buf));
                console_write(2, buf);
                console_write(2, " height=");
                u64_to_ascii((u64)stripe_height_px, buf, sizeof(buf));
                console_write(2, buf);
                console_write(2, " width=");
                u64_to_ascii((u64)stripe_width_px, buf, sizeof(buf));
                console_write(2, buf);
                console_write(2, " pitch_x_milli=");
                u64 pitch_x_milli = (u64)(pitch_x * 1000.0 + 0.5);
                u64_to_ascii(pitch_x_milli, buf, sizeof(buf));
                console_line(2, buf);
            }

            const double start_shifts[] = {0.0, 0.25, 0.5, 0.75};
            const double top_shifts[] = {0.0, -0.25, 0.25, -0.5, 0.5};
            for (u32 rows = 1u; rows <= 24u; ++rows) {
                double pitch_y = (double)stripe_height_px / (double)rows;
                if (!(pitch_y > 0.9) || pitch_y > 64.0) {
                    continue;
                }
                ByteBuffer module_bits;
                for (u32 ts = 0u; ts < (u32)(sizeof(top_shifts) / sizeof(top_shifts[0])); ++ts) {
                    double top_try = stripe_top_f + top_shifts[ts] * pitch_y;
                    if (top_try < 0.0) {
                        continue;
                    }
                    for (u32 sh = 0u; sh < (u32)(sizeof(start_shifts) / sizeof(start_shifts[0])); ++sh) {
                        double start_try = start_base + start_shifts[sh] * pitch_x;
                        if (start_try < 0.0) {
                            continue;
                        }
                        double pixel_width_f = pitch_x * (double)V3_MODULE_COUNT;
                        if (start_try + pixel_width_f > (double)width + 0.5) {
                            continue;
                        }
                        if (capture_stripe_v3_float(pixels, width, height, rows, top_try, start_try, pitch_x, pitch_y, module_bits) &&
                            decode_from_bits_v3(module_bits, rows, values)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };

        auto try_decode_at_pitch = [&](u32 module_pitch_x,
                                       u32 module_pitch_y,
                                       u32 max_offset,
                                       u32 offset_step,
                                       u32 max_starts,
                                       const u32* start_candidates) -> bool {
            if (module_pitch_x == 0u || module_pitch_y == 0u) {
                return false;
            }
            if (offset_step == 0u) {
                offset_step = 1u;
            }
            u32 pixel_width = V3_MODULE_COUNT * module_pitch_x;
            if (pixel_width == 0u || pixel_width > width) {
                return false;
            }
            ByteBuffer module_bits;
            for (u32 rows = 1u; rows <= V3_MAX_ROWS; ++rows) {
                u32 stripe_height_px = rows * module_pitch_y;
                if (stripe_height_px == 0u || stripe_height_px > height) {
                    continue;
                }
                u32 base_top = (height > stripe_height_px) ? (height - stripe_height_px) : 0u;
                for (u32 offset = 0u; offset <= max_offset; offset += offset_step) {
                    if (base_top < offset) {
                        break;
                    }
                    u32 stripe_top = base_top - offset;
                    for (u32 i = 0u; i < max_starts; ++i) {
                        u32 start = start_candidates[i];
                        if (start + pixel_width > width) {
                            continue;
                        }
                        if (capture_stripe_v3(pixels, width, height, rows, stripe_top, start, module_pitch_x, module_pitch_y, module_bits) &&
                            decode_from_bits_v3(module_bits, rows, values)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };

        // Fast path: assume unscaled V3 pitch and common left/center/right alignment.
        {
            const u32 module_pitch_x = V3_MODULE_PITCH;
            const u32 module_pitch_y = V3_MODULE_PITCH;
            const u32 pixel_width = V3_MODULE_COUNT * module_pitch_x;
            if (pixel_width > 0u && pixel_width <= width) {
                u32 starts[3];
                starts[0] = 0u;
                starts[1] = (width > pixel_width) ? (u32)((width - pixel_width) / 2u) : 0u;
                starts[2] = (width >= pixel_width) ? (width - pixel_width) : 0u;
                u32 max_offset = height;
                if (max_offset > 512u) max_offset = 512u;
                if (try_decode_at_pitch(module_pitch_x, module_pitch_y, max_offset, V3_MODULE_PITCH, 3u, starts)) {
                    return true;
                }
            }
        }

        // Heuristic: try decoding at the bottom-left/bottom-right based on observed stripe bounds.
        // This is especially important for nearest-neighbor scaled images with non-integer factors.
        if (try_decode_from_bottom_probe(false)) {
            return true;
        }
        if (try_decode_from_bottom_probe(true)) {
            return true;
        }

        // Slow path (budgeted): try a small set of integer pitch candidates with a small alignment neighborhood.
        // This is intentionally conservative to avoid pathological runtimes on images where the stripe is absent
        // or badly distorted. More robust recovery is expected to occur later via affine-based decoding.
        const u32 pitch_candidates[] = {3u, 4u, 5u, 6u, 8u, 10u, 12u};
        u32 max_offset = height;
        if (max_offset > 512u) max_offset = 512u;
        if (max_offset > 128u) max_offset = 128u;

	        for (u32 py_i = 0u; py_i < (u32)(sizeof(pitch_candidates) / sizeof(pitch_candidates[0])); ++py_i) {
	            u32 module_pitch_y = pitch_candidates[py_i];
	            for (u32 px_i = 0u; px_i < (u32)(sizeof(pitch_candidates) / sizeof(pitch_candidates[0])); ++px_i) {
	                u32 module_pitch_x = pitch_candidates[px_i];
                u32 pixel_width = V3_MODULE_COUNT * module_pitch_x;
                if (pixel_width == 0u || pixel_width > width) {
                    continue;
                }
                u32 center_start = (width > pixel_width) ? (u32)((width - pixel_width) / 2u) : 0u;
                u32 right_start = (width >= pixel_width) ? (width - pixel_width) : 0u;
                u32 starts[9];
                u32 start_count = 0u;
                auto add_start = [&](u32 start) {
                    for (u32 i = 0u; i < start_count; ++i) {
                        if (starts[i] == start) return;
                    }
                    if (start_count < (u32)(sizeof(starts) / sizeof(starts[0]))) {
                        starts[start_count++] = start;
                    }
                };
                add_start(0u);
                add_start(center_start);
                add_start(right_start);
                add_start((center_start > module_pitch_x) ? (center_start - module_pitch_x) : 0u);
                add_start(center_start + module_pitch_x);
                add_start((center_start > 2u * module_pitch_x) ? (center_start - 2u * module_pitch_x) : 0u);
                add_start(center_start + 2u * module_pitch_x);

                u32 offset_step = (module_pitch_y > 1u) ? (module_pitch_y / 2u) : 1u;
                if (try_decode_at_pitch(module_pitch_x, module_pitch_y, max_offset, offset_step, start_count, starts)) {
                    return true;
                }
	            }
	        }

		        // Float pitch path (budgeted): supports non-integer rescaling (e.g. 2.6x/2.4x).
		        // Keep this *very* conservative: the generic float search can easily become
		        // pathological on large images.
		        {
		            const double aspect = (width > 0u) ? ((double)height / (double)width) : 1.0;
		            const u32 rows_limit = 16u;
		            u32 max_offset_f = height;
		            if (max_offset_f > 256u) max_offset_f = 256u;
		            const u32 offset_step = 8u;
		            const double base_pitches[] = {2.0, 3.0, 4.0, 5.0, 6.0, 7.0};
		            const double deltas[] = {0.0};
		            const double y_ratios[] = {0.90, 1.00, 1.10};
		            const double start_shifts[] = {0.0, 0.5};
		            for (u32 b = 0u; b < (u32)(sizeof(base_pitches) / sizeof(base_pitches[0])); ++b) {
		                for (u32 d = 0u; d < (u32)(sizeof(deltas) / sizeof(deltas[0])); ++d) {
		                    double pitch_x = base_pitches[b] + deltas[d];
	                    if (!(pitch_x > 0.9)) {
	                        continue;
	                    }
	                    double pixel_width_f = pitch_x * (double)V3_MODULE_COUNT;
	                    if (!(pixel_width_f > 0.0) || pixel_width_f > (double)width) {
	                        continue;
	                    }
	                    double starts[3];
	                    starts[0] = 0.0;
	                    starts[1] = ((double)width > pixel_width_f) ? (((double)width - pixel_width_f) * 0.5) : 0.0;
	                    starts[2] = ((double)width >= pixel_width_f) ? ((double)width - pixel_width_f) : 0.0;
	                    for (u32 yr = 0u; yr < (u32)(sizeof(y_ratios) / sizeof(y_ratios[0])); ++yr) {
	                        double pitch_y = pitch_x * aspect * y_ratios[yr];
	                        if (!(pitch_y > 0.9)) {
	                            continue;
	                        }
	                        for (u32 rows = 1u; rows <= rows_limit; ++rows) {
	                            double stripe_height_f = (double)rows * pitch_y;
	                            if (!(stripe_height_f > 0.0) || stripe_height_f > (double)height) {
	                                continue;
	                            }
	                            double base_top_f = ((double)height > stripe_height_f) ? ((double)height - stripe_height_f) : 0.0;
	                            for (u32 offset = 0u; offset <= max_offset_f; offset += offset_step) {
	                                double stripe_top_f = base_top_f - (double)offset;
	                                if (stripe_top_f < 0.0) {
	                                    break;
	                                }
	                                for (u32 si = 0u; si < 3u; ++si) {
	                                    for (u32 sh = 0u; sh < (u32)(sizeof(start_shifts) / sizeof(start_shifts[0])); ++sh) {
	                                        double start_f = starts[si] + start_shifts[sh] * pitch_x;
	                                        if (start_f < 0.0) {
	                                            continue;
	                                        }
	                                        if (start_f + pixel_width_f > (double)width + 0.5) {
	                                            continue;
	                                        }
	                                        ByteBuffer module_bits;
	                                        if (capture_stripe_v3_float(pixels, width, height, rows, stripe_top_f, start_f, pitch_x, pitch_y, module_bits) &&
	                                            decode_from_bits_v3(module_bits, rows, values)) {
	                                            return true;
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }

	        return false;
	    }

    static bool decode_v3_affine(const u8* pixels,
                                 u32 width,
                                 u32 height,
                                 const AffineTransform& affine,
                                 double skew_y_pixels,
                                 double skew_span,
                                 u32 logical_width,
                                 u32 logical_height,
                                 u32 footer_rows,
                                 Values& values) {
        if (!pixels || width == 0u || height == 0u || logical_width == 0u || logical_height == 0u) {
            return false;
        }
        u32 pixel_width = V3_MODULE_COUNT * V3_MODULE_PITCH;
        u32 left_start = 0u;
        u32 right_start = (logical_width >= pixel_width) ? (logical_width - pixel_width) : 0u;
        u32 center_start = (logical_width > pixel_width) ? (u32)((logical_width - pixel_width) / 2u) : 0u;
        u32 rows_limit = V3_MAX_ROWS;
        u32 hint_rows = (footer_rows > 0u) ? (footer_rows / V3_MODULE_PITCH) : 0u;
        if (hint_rows > 0u && hint_rows < rows_limit) {
            rows_limit = hint_rows;
        }
        u32 max_offset = (logical_height > 512u) ? 512u : logical_height;
        for (u32 rows = 1u; rows <= rows_limit; ++rows) {
            u32 stripe_height_px = rows * V3_MODULE_PITCH;
            if (stripe_height_px == 0u || stripe_height_px > logical_height) {
                continue;
            }
            u32 stripe_top_logical = (logical_height > stripe_height_px) ? (logical_height - stripe_height_px) : 0u;
            if (footer_rows > stripe_height_px && footer_rows < logical_height) {
                stripe_top_logical = logical_height - footer_rows;
            }
            for (u32 offset = 0u; offset <= max_offset; offset += V3_MODULE_PITCH) {
                if (stripe_top_logical < offset) {
                    break;
                }
                double stripe_top = (double)stripe_top_logical - (double)offset;
                ByteBuffer module_bits;
                if (capture_stripe_v3_affine(pixels, width, height, rows, affine, skew_y_pixels, skew_span, stripe_top, left_start, module_bits)) {
                    if (decode_from_bits_v3(module_bits, rows, values)) {
                        return true;
                    }
                }
                if (right_start != left_start &&
                    capture_stripe_v3_affine(pixels, width, height, rows, affine, skew_y_pixels, skew_span, stripe_top, right_start, module_bits) &&
                    decode_from_bits_v3(module_bits, rows, values)) {
                    return true;
                }
                if (center_start != left_start && center_start != right_start &&
                    capture_stripe_v3_affine(pixels, width, height, rows, affine, skew_y_pixels, skew_span, stripe_top, center_start, module_bits) &&
                    decode_from_bits_v3(module_bits, rows, values)) {
                    return true;
                }
            }
        }
        return false;
    }

    static bool decode_affine(const StripeSpec& spec,
                              const u8* pixels,
                              u32 width,
                              u32 height,
                              const AffineTransform& affine,
                              double skew_y_pixels,
                              double skew_span,
                              u32 logical_width,
                              u32 logical_height,
                              u32 footer_rows,
                              Values& values) {
        if (!pixels || width == 0u || height == 0u || logical_width == 0u || logical_height == 0u) {
            return false;
        }
        u32 stripe_height_px = stripe_height(spec);
        u32 stripe_top_logical = (logical_height > stripe_height_px) ? (logical_height - stripe_height_px) : 0u;
        if (footer_rows > stripe_height_px && footer_rows < logical_height) {
            stripe_top_logical = logical_height - footer_rows;
        }
        u32 left_start = 0u;
        u32 right_start = (logical_width >= pixel_width(spec)) ? (logical_width - pixel_width(spec)) : 0u;
        auto decode_at_affine = [&](u32 start_column) -> bool {
            ByteBuffer module_bits;
            usize total = (usize)module_count(spec) * (usize)spec.rows;
            if (!module_bits.ensure(total)) {
                return false;
            }
            module_bits.size = total;
            for (u32 row = 0u; row < spec.rows; ++row) {
                if (!capture_module_row_affine(spec,
                                               pixels,
                                               width,
                                               height,
                                               affine,
                                               skew_y_pixels,
                                               skew_span,
                                               (double)stripe_top_logical,
                                               start_column,
                                               row,
                                               module_bits.data + (usize)row * module_count(spec))) {
                    return false;
                }
            }
            return decode_from_bits(spec, module_bits, values);
        };
        if (decode_at_affine(left_start)) {
            return true;
        }
        if (right_start != left_start) {
            if (decode_at_affine(right_start)) {
                return true;
            }
        }
        return false;
    }
}

namespace MetadataTile {
    using namespace makocode;

    static const u32 TILE_SIDE = 48u;
    static const u32 TILE_BORDER = 1u;
    [[maybe_unused]] static const u32 TILE_INNER_SIDE = TILE_SIDE - TILE_BORDER * 2u;
    static const u32 TILE_HEADER_BITS = 32u;
    static const u32 TILE_HEADER_REPETITIONS = 5u;
    static const u32 TILE_RS_PARITY_BYTES = 32u;
    static const u32 TILE_SCHEMA_VERSION = 1u;

    // Reserve a central hole to avoid high-risk collisions with fiducial pixels.
    static const u32 TILE_HOLE_SIDE = 20u;

    static double rgb_luminance_u8(u8 r, u8 g, u8 b) {
        // Approx Rec. 709 luma.
        return 0.2126 * (double)r + 0.7152 * (double)g + 0.0722 * (double)b;
    }

    static double sample_luminance_bilinear(const u8* pixel_data_rgb,
                                            u32 width_pixels,
                                            u32 height_pixels,
                                            double x,
                                            double y) {
        if (!pixel_data_rgb || width_pixels == 0u || height_pixels == 0u) {
            return 0.0;
        }
        x = clamp_double(x, 0.0, (double)(width_pixels - 1u));
        y = clamp_double(y, 0.0, (double)(height_pixels - 1u));
        u32 x0 = (u32)floor(x);
        u32 y0 = (u32)floor(y);
        u32 x1 = (x0 + 1u < width_pixels) ? (x0 + 1u) : x0;
        u32 y1 = (y0 + 1u < height_pixels) ? (y0 + 1u) : y0;
        double fx = x - (double)x0;
        double fy = y - (double)y0;

        auto lum_at = [&](u32 ix, u32 iy) -> double {
            usize idx = ((usize)iy * (usize)width_pixels + (usize)ix) * 3u;
            u8 r = pixel_data_rgb[idx + 0u];
            u8 g = pixel_data_rgb[idx + 1u];
            u8 b = pixel_data_rgb[idx + 2u];
            return rgb_luminance_u8(r, g, b);
        };

        double v00 = lum_at(x0, y0);
        double v10 = lum_at(x1, y0);
        double v01 = lum_at(x0, y1);
        double v11 = lum_at(x1, y1);
        double v0 = v00 * (1.0 - fx) + v10 * fx;
        double v1 = v01 * (1.0 - fx) + v11 * fx;
        return v0 * (1.0 - fy) + v1 * fy;
    }

    static bool palette_endpoints_have_contrast(const PaletteColor& light,
                                                const PaletteColor& dark,
                                                double min_luma_gap) {
        double l0 = rgb_luminance_u8(light.r, light.g, light.b);
        double l1 = rgb_luminance_u8(dark.r, dark.g, dark.b);
        double gap = l0 - l1;
        if (gap < 0.0) gap = -gap;
        return gap >= min_luma_gap;
    }

    static bool append_hex_color_token(ByteBuffer& out, const PaletteColor& c) {
        char token[16];
        // Format as #RRGGBB
        int n = snprintf(token, sizeof(token), "#%02X%02X%02X", (unsigned)c.r, (unsigned)c.g, (unsigned)c.b);
        if (n <= 0) {
            return false;
        }
        return out.append_ascii(token);
    }

    static bool build_palette_text_from_colors(const PaletteColor* colors,
                                               u32 count,
                                               ByteBuffer& out_text) {
        out_text.release();
        if (!colors || count < 2u || count > MAX_CUSTOM_PALETTE_COLORS) {
            return false;
        }
        for (u32 i = 0u; i < count; ++i) {
            if (i) {
                if (!out_text.append_char(' ')) return false;
            }
            if (!append_hex_color_token(out_text, colors[i])) return false;
        }
        if (!out_text.append_char('\0')) return false;
        return true;
    }

    struct Values {
        u64 page_bits;
        u64 page_count;
        u64 page_index;
        u32 page_width_pixels;
        u32 page_height_pixels;
        u32 footer_rows;
        u32 fiducial_marker_size_pixels;
        bool ecc_enabled;
        u16 ecc_block_data;
        u16 ecc_parity;
        u64 ecc_block_count;
        u64 ecc_original_bytes;
        u32 palette_count;
        PaletteColor palette[MAX_CUSTOM_PALETTE_COLORS];

        Values()
            : page_bits(0u),
              page_count(0u),
              page_index(0u),
              page_width_pixels(0u),
              page_height_pixels(0u),
              footer_rows(0u),
              fiducial_marker_size_pixels(0u),
              ecc_enabled(false),
              ecc_block_data(0u),
              ecc_parity(0u),
              ecc_block_count(0u),
              ecc_original_bytes(0u),
              palette_count(0u),
              palette() {}
    };

    static u8 compute_crc8(const u8* data, usize length) {
        // Same CRC-8 polynomial as FooterStripe uses (0x07).
        u8 crc = 0u;
        for (usize i = 0u; i < length; ++i) {
            crc ^= data[i];
            for (u32 bit = 0u; bit < 8u; ++bit) {
                if (crc & 0x80u) {
                    crc = (u8)((crc << 1u) ^ 0x07u);
                } else {
                    crc <<= 1u;
                }
            }
        }
        return crc;
    }

    static bool write_limited_u64(BitWriter& writer, u64 value, u32 bits) {
        u64 limit = (bits >= 64u) ? ~0ull : ((1ull << bits) - 1ull);
        if (value > limit) {
            return false;
        }
        return writer.write_bits(value, bits);
    }

    static bool encode_metadata_bytes(const Values& values, ByteBuffer& out) {
        out.release();
        BitWriter writer;
        // Fixed header (byte-aligned):
        // magic(32) "MKMD" | schema(8)
        if (!writer.write_bits((u64)0x4D4B4D44u, 32u)) return false; // 'M''K''M''D'
        if (!writer.write_bits((u64)TILE_SCHEMA_VERSION, 8u)) return false;

        // Palette block (always present as a sanity check):
        // palette_count(8) then RGB triples.
        if (values.palette_count < 2u || values.palette_count > MAX_CUSTOM_PALETTE_COLORS) return false;
        if (!writer.write_bits((u64)values.palette_count, 8u)) return false;
        for (u32 i = 0u; i < values.palette_count; ++i) {
            if (!writer.write_bits((u64)values.palette[i].r, 8u)) return false;
            if (!writer.write_bits((u64)values.palette[i].g, 8u)) return false;
            if (!writer.write_bits((u64)values.palette[i].b, 8u)) return false;
        }

        // Core decode fields (packed; keep stable for now):
        // page_bits(64), page_count(32), page_index(32)
        if (!writer.write_bits(values.page_bits, 64u)) return false;
        if (!write_limited_u64(writer, values.page_count, 32u)) return false;
        if (!write_limited_u64(writer, values.page_index, 32u)) return false;

        // Layout
        if (!write_limited_u64(writer, (u64)values.page_width_pixels, 32u)) return false;
        if (!write_limited_u64(writer, (u64)values.page_height_pixels, 32u)) return false;
        if (!write_limited_u64(writer, (u64)values.footer_rows, 16u)) return false;
        if (!write_limited_u64(writer, (u64)values.fiducial_marker_size_pixels, 8u)) return false;

        // ECC summary
        if (!writer.write_bits(values.ecc_enabled ? 1ull : 0ull, 1u)) return false;
        if (!write_limited_u64(writer, (u64)values.ecc_block_data, 16u)) return false;
        if (!write_limited_u64(writer, (u64)values.ecc_parity, 16u)) return false;
        if (!write_limited_u64(writer, values.ecc_block_count, 32u)) return false;
        if (!writer.write_bits(values.ecc_original_bytes, 64u)) return false;

        if (!writer.align_to_byte()) return false;
        usize bytes = writer.byte_size();
        if (bytes == 0u) return false;
        if (!out.ensure(bytes + 1u)) return false;
        const u8* raw = writer.data();
        for (usize i = 0u; i < bytes; ++i) {
            out.data[i] = raw ? raw[i] : 0u;
        }
        out.size = bytes;
        u8 crc = compute_crc8(out.data, out.size);
        out.data[out.size++] = crc;
        return true;
    }

    static bool rs_encode_with_parity_32(const ByteBuffer& metadata, ByteBuffer& codeword_out) {
        if (!metadata.data || metadata.size == 0u) return false;
        if (metadata.size + TILE_RS_PARITY_BYTES > 255u) return false;
        codeword_out.release();
        if (!codeword_out.ensure(metadata.size + TILE_RS_PARITY_BYTES)) return false;
        codeword_out.size = metadata.size + TILE_RS_PARITY_BYTES;
        for (usize i = 0u; i < metadata.size; ++i) codeword_out.data[i] = metadata.data[i];
        u8 generator[RS_POLY_CAPACITY];
        u16 generator_size = 0u;
        if (!rs_build_generator((u16)TILE_RS_PARITY_BYTES, generator, generator_size)) return false;
        u8 parity[RS_POLY_CAPACITY];
        rs_compute_parity(generator,
                          (u16)TILE_RS_PARITY_BYTES,
                          metadata.data,
                          (u16)metadata.size,
                          parity);
        for (u32 i = 0u; i < TILE_RS_PARITY_BYTES; ++i) {
            codeword_out.data[metadata.size + i] = parity[i];
        }
        return true;
    }

    static bool rs_decode_with_parity_32(ByteBuffer& codeword_in_out, usize metadata_bytes, u32& corrections_out) {
        corrections_out = 0u;
        if (!codeword_in_out.data || codeword_in_out.size != metadata_bytes + TILE_RS_PARITY_BYTES) return false;
        if (metadata_bytes == 0u || metadata_bytes + TILE_RS_PARITY_BYTES > 255u) return false;
        u16 corrected = 0u;
        if (!rs_decode_block(codeword_in_out.data,
                             (u16)metadata_bytes,
                             (u16)TILE_RS_PARITY_BYTES,
                             &corrected)) {
            corrections_out = (u32)corrected;
            return false;
        }
        corrections_out = (u32)corrected;
        return true;
    }

    struct Placement {
        bool valid;
        u32 x0;
        u32 y0;

        Placement() : valid(false), x0(0u), y0(0u) {}
    };

    static void compute_default_fiducial_grid(u32 width_pixels,
                                              u32 data_height_pixels,
                                              u32& out_columns,
                                              u32& out_rows) {
        u32 marker_size = g_fiducial_defaults.marker_size_pixels ? g_fiducial_defaults.marker_size_pixels : 1u;
        u32 spacing = g_fiducial_defaults.spacing_pixels ? g_fiducial_defaults.spacing_pixels : marker_size;
        u32 margin = g_fiducial_defaults.margin_pixels;
        double min_x = (margin < width_pixels) ? (double)margin : 0.0;
        double max_x = (width_pixels > margin)
                           ? (double)(width_pixels - 1u - margin)
                           : (width_pixels ? (double)(width_pixels - 1u) : 0.0);
        if (max_x < min_x) max_x = min_x;
        double min_y = (margin < data_height_pixels) ? (double)margin : 0.0;
        double max_y = (data_height_pixels > margin)
                           ? (double)(data_height_pixels - 1u - margin)
                           : (data_height_pixels ? (double)(data_height_pixels - 1u) : 0.0);
        if (max_y < min_y) max_y = min_y;
        double available_width = (max_x >= min_x) ? (max_x - min_x) : 0.0;
        double available_height = (max_y >= min_y) ? (max_y - min_y) : 0.0;
        u32 columns = 1u;
        if (spacing > 0u && available_width > 0.0) {
            u64 additional = (u64)(available_width / (double)spacing);
            columns = (u32)(additional + 1ull);
            if (columns == 0u) columns = 1u;
        }
        u32 rows = 1u;
        if (spacing > 0u && available_height > 0.0) {
            u64 additional = (u64)(available_height / (double)spacing);
            rows = (u32)(additional + 1ull);
            if (rows == 0u) rows = 1u;
        }
        out_columns = columns;
        out_rows = rows;
    }

    static Placement compute_tile_placement(u32 width_pixels,
                                            u32 data_height_pixels) {
        Placement placement;
        if (width_pixels < TILE_SIDE || data_height_pixels < TILE_SIDE) {
            return placement;
        }
        u32 columns = 1u, rows = 1u;
        compute_default_fiducial_grid(width_pixels, data_height_pixels, columns, rows);
        u32 mid_col = columns / 2u;
        u32 mid_row = rows / 2u;
        u32 margin = g_fiducial_defaults.margin_pixels;
        double min_x = (margin < width_pixels) ? (double)margin : 0.0;
        double max_x = (width_pixels > margin)
                           ? (double)(width_pixels - 1u - margin)
                           : (width_pixels ? (double)(width_pixels - 1u) : 0.0);
        if (max_x < min_x) max_x = min_x;
        double min_y = (margin < data_height_pixels) ? (double)margin : 0.0;
        double max_y = (data_height_pixels > margin)
                           ? (double)(data_height_pixels - 1u - margin)
                           : (data_height_pixels ? (double)(data_height_pixels - 1u) : 0.0);
        if (max_y < min_y) max_y = min_y;
        double t_x = (columns == 1u) ? 0.5 : ((double)mid_col / (double)(columns - 1u));
        double t_y = (rows == 1u) ? 0.5 : ((double)mid_row / (double)(rows - 1u));
        double center_x = min_x + (max_x - min_x) * t_x;
        double center_y = min_y + (max_y - min_y) * t_y;
        int x0 = (int)(center_x - ((double)TILE_SIDE - 1.0) * 0.5);
        int y0 = (int)(center_y - ((double)TILE_SIDE - 1.0) * 0.5);
        if (x0 < 0) x0 = 0;
        if (y0 < 0) y0 = 0;
        if (x0 + (int)TILE_SIDE > (int)width_pixels) x0 = (int)width_pixels - (int)TILE_SIDE;
        if (y0 + (int)TILE_SIDE > (int)data_height_pixels) y0 = (int)data_height_pixels - (int)TILE_SIDE;
        placement.valid = true;
        placement.x0 = (u32)x0;
        placement.y0 = (u32)y0;
        return placement;
    }

    [[maybe_unused]] static void mark_tile_mask(const Placement& placement,
                                                u32 width_pixels,
                                                u32 data_height_pixels,
                                                u8* mask_data) {
        if (!placement.valid || !mask_data) return;
        if (placement.x0 + TILE_SIDE > width_pixels) return;
        if (placement.y0 + TILE_SIDE > data_height_pixels) return;
        for (u32 dy = 0u; dy < TILE_SIDE; ++dy) {
            u32 y = placement.y0 + dy;
            for (u32 dx = 0u; dx < TILE_SIDE; ++dx) {
                u32 x = placement.x0 + dx;
                usize idx = (usize)y * (usize)width_pixels + (usize)x;
                mask_data[idx] = 1u;
            }
        }
    }

    [[maybe_unused]] static bool render_tile(const Values& values,
                                             const Placement& placement,
                                             u32 width_pixels,
                                             u32 height_pixels,
                                             u32 data_height_pixels,
                                             u8* pixel_data_rgb,
                                             const PaletteColor& light,
                                             const PaletteColor& dark) {
        if (!placement.valid) return false;
        if (!pixel_data_rgb) return false;
        if (placement.x0 + TILE_SIDE > width_pixels) return false;
        if (placement.y0 + TILE_SIDE > data_height_pixels) return false;
        // Build metadata bytes then RS codeword.
        ByteBuffer metadata;
        if (!encode_metadata_bytes(values, metadata)) return false;
        ByteBuffer codeword;
        if (!rs_encode_with_parity_32(metadata, codeword)) return false;
        if (metadata.size > 255u) return false;

        // Build 32-bit header: magic16 | schema4 | meta_len8 | palette_count4
        u32 meta_len = (u32)metadata.size;
        if (meta_len > 255u) return false;
        u32 header = 0u;
        header |= (u32)0x4D4Du << 16; // 'M''K' as 16-bit marker
        header |= (TILE_SCHEMA_VERSION & 0x0Fu) << 12;
        header |= (meta_len & 0xFFu) << 4;
        header |= (values.palette_count & 0x0Fu);

        auto set_module = [&](u32 x, u32 y, u8 bit) {
            if (x >= width_pixels || y >= height_pixels) return;
            usize idx = ((usize)y * (usize)width_pixels + (usize)x) * 3u;
            const PaletteColor& c = bit ? dark : light;
            pixel_data_rgb[idx + 0u] = c.r;
            pixel_data_rgb[idx + 1u] = c.g;
            pixel_data_rgb[idx + 2u] = c.b;
        };

        // Outer border: alternating pattern for sanity.
        for (u32 y = 0u; y < TILE_SIDE; ++y) {
            for (u32 x = 0u; x < TILE_SIDE; ++x) {
                bool border = (x < TILE_BORDER) || (y < TILE_BORDER) ||
                              (x >= TILE_SIDE - TILE_BORDER) || (y >= TILE_SIDE - TILE_BORDER);
                if (border) {
                    u8 bit = (u8)(((x + y) & 1u) ? 1u : 0u);
                    set_module(placement.x0 + x, placement.y0 + y, bit);
                } else {
                    // Initialize inner area to light.
                    set_module(placement.x0 + x, placement.y0 + y, 0u);
                }
            }
        }

        // Compute inner hole bounds (centered in tile).
        u32 hole_x0 = (TILE_SIDE - TILE_HOLE_SIDE) / 2u;
        u32 hole_y0 = (TILE_SIDE - TILE_HOLE_SIDE) / 2u;
        u32 hole_x1 = hole_x0 + TILE_HOLE_SIDE;
        u32 hole_y1 = hole_y0 + TILE_HOLE_SIDE;

        // Header: repeat across first TILE_HEADER_REPETITIONS inner rows.
        for (u32 rep = 0u; rep < TILE_HEADER_REPETITIONS; ++rep) {
            u32 inner_y = TILE_BORDER + rep;
            if (inner_y >= TILE_SIDE - TILE_BORDER) break;
            for (u32 bit = 0u; bit < TILE_HEADER_BITS; ++bit) {
                u32 inner_x = TILE_BORDER + bit;
                if (inner_x >= TILE_SIDE - TILE_BORDER) break;
                u8 value_bit = (u8)((header >> bit) & 1u);
                set_module(placement.x0 + inner_x, placement.y0 + inner_y, value_bit);
            }
        }

        // Payload bits: fill remaining inner modules (skipping header rows and hole).
        usize total_bits = codeword.size * 8u;
        usize bit_cursor = 0u;
        for (u32 inner_y = TILE_BORDER; inner_y < TILE_SIDE - TILE_BORDER; ++inner_y) {
            // skip header rows
            if (inner_y < TILE_BORDER + TILE_HEADER_REPETITIONS) {
                continue;
            }
            for (u32 inner_x = TILE_BORDER; inner_x < TILE_SIDE - TILE_BORDER; ++inner_x) {
                // Skip hole region.
                if (inner_x >= hole_x0 && inner_x < hole_x1 && inner_y >= hole_y0 && inner_y < hole_y1) {
                    continue;
                }
                if (bit_cursor >= total_bits) {
                    break;
                }
                usize byte_index = bit_cursor / 8u;
                u32 bit_index = (u32)(bit_cursor % 8u);
                u8 byte = codeword.data[byte_index];
                u8 bit = (u8)((byte >> bit_index) & 1u);
                set_module(placement.x0 + inner_x, placement.y0 + inner_y, bit);
                ++bit_cursor;
            }
            if (bit_cursor >= total_bits) break;
        }
        // Require full fit.
        if (bit_cursor != total_bits) {
            return false;
        }
        return true;
    }

    static bool build_tile_bits(const Values& values,
                                ByteBuffer& out_bits /* size TILE_SIDE*TILE_SIDE, 0/1 */) {
        out_bits.release();
        if (!out_bits.ensure((usize)TILE_SIDE * (usize)TILE_SIDE)) return false;
        out_bits.size = (usize)TILE_SIDE * (usize)TILE_SIDE;
        // Initialize to a checkerboard so unused regions do not create large flat bright patches
        // that can bias fiducial sampling.
        for (u32 y = 0u; y < TILE_SIDE; ++y) {
            for (u32 x = 0u; x < TILE_SIDE; ++x) {
                out_bits.data[(usize)y * (usize)TILE_SIDE + (usize)x] = (u8)(((x + y) & 1u) ? 1u : 0u);
            }
        }

        ByteBuffer metadata;
        if (!encode_metadata_bytes(values, metadata)) return false;
        ByteBuffer codeword;
        if (!rs_encode_with_parity_32(metadata, codeword)) return false;
        u32 meta_len = (u32)metadata.size;
        if (meta_len == 0u || meta_len > 255u) return false;

        u32 header = 0u;
        header |= (u32)0x4D4Du << 16; // 'M''K'
        header |= (TILE_SCHEMA_VERSION & 0x0Fu) << 12;
        header |= (meta_len & 0xFFu) << 4;
        header |= (values.palette_count & 0x0Fu);

        // Border is already checkerboard; keep fixed framing implicitly via header/payload layout.

        u32 hole_x0 = (TILE_SIDE - TILE_HOLE_SIDE) / 2u;
        u32 hole_y0 = (TILE_SIDE - TILE_HOLE_SIDE) / 2u;
        u32 hole_x1 = hole_x0 + TILE_HOLE_SIDE;
        u32 hole_y1 = hole_y0 + TILE_HOLE_SIDE;

        // Header repetitions.
        for (u32 rep = 0u; rep < TILE_HEADER_REPETITIONS; ++rep) {
            u32 y = TILE_BORDER + rep;
            if (y >= TILE_SIDE - TILE_BORDER) break;
            for (u32 bit = 0u; bit < TILE_HEADER_BITS; ++bit) {
                u32 x = TILE_BORDER + bit;
                if (x >= TILE_SIDE - TILE_BORDER) break;
                u8 b = (u8)((header >> bit) & 1u);
                out_bits.data[(usize)y * (usize)TILE_SIDE + (usize)x] = b;
            }
        }

        // Payload bits.
        usize total_bits = codeword.size * 8u;
        usize bit_cursor = 0u;
        for (u32 y = TILE_BORDER; y < TILE_SIDE - TILE_BORDER; ++y) {
            if (y < TILE_BORDER + TILE_HEADER_REPETITIONS) continue;
            for (u32 x = TILE_BORDER; x < TILE_SIDE - TILE_BORDER; ++x) {
                if (x >= hole_x0 && x < hole_x1 && y >= hole_y0 && y < hole_y1) continue;
                if (bit_cursor >= total_bits) break;
                usize byte_index = bit_cursor / 8u;
                u32 bit_index = (u32)(bit_cursor % 8u);
                u8 byte = codeword.data[byte_index];
                u8 bit = (u8)((byte >> bit_index) & 1u);
                out_bits.data[(usize)y * (usize)TILE_SIDE + (usize)x] = bit;
                ++bit_cursor;
            }
            if (bit_cursor >= total_bits) break;
        }
        return bit_cursor == total_bits;
    }

    static bool decode_tile(const u8* pixel_data_rgb,
                            u32 width_pixels,
                            u32 height_pixels,
                            u32 data_height_pixels,
                            const Placement& placement,
                            Values& out_values,
                            ByteBuffer& out_palette_text) {
        if (!pixel_data_rgb || !placement.valid) return false;
        (void)height_pixels;
        if (placement.x0 + TILE_SIDE > width_pixels) return false;
        if (placement.y0 + TILE_SIDE > data_height_pixels) return false;

        auto module_intensity = [&](u32 x, u32 y) -> double {
            usize idx = ((usize)y * (usize)width_pixels + (usize)x) * 3u;
            u8 r = pixel_data_rgb[idx + 0u];
            u8 g = pixel_data_rgb[idx + 1u];
            u8 b = pixel_data_rgb[idx + 2u];
            return rgb_luminance_u8(r, g, b);
        };

        // Estimate threshold from inner region statistics.
        double min_l = 255.0;
        double max_l = 0.0;
        for (u32 y = 0u; y < TILE_SIDE; ++y) {
            for (u32 x = 0u; x < TILE_SIDE; ++x) {
                // Ignore border; use inner only.
                if (x < TILE_BORDER || y < TILE_BORDER || x >= TILE_SIDE - TILE_BORDER || y >= TILE_SIDE - TILE_BORDER) {
                    continue;
                }
                double l = module_intensity(placement.x0 + x, placement.y0 + y);
                if (l < min_l) min_l = l;
                if (l > max_l) max_l = l;
            }
        }
        if (!(max_l > min_l + 1.0)) return false;
        double threshold = (min_l + max_l) * 0.5;

        auto read_bit = [&](u32 inner_x, u32 inner_y) -> u8 {
            double l = module_intensity(placement.x0 + inner_x, placement.y0 + inner_y);
            // Dark => 1
            return (l < threshold) ? 1u : 0u;
        };
        auto decode_header = [&](bool invert_bits, u32& header_out) -> bool {
            header_out = 0u;
            for (u32 bit = 0u; bit < TILE_HEADER_BITS; ++bit) {
                u32 ones = 0u;
                u32 samples = 0u;
                for (u32 rep = 0u; rep < TILE_HEADER_REPETITIONS; ++rep) {
                    u32 inner_y = TILE_BORDER + rep;
                    u32 inner_x = TILE_BORDER + bit;
                    if (inner_x >= TILE_SIDE - TILE_BORDER) continue;
                    if (inner_y >= TILE_SIDE - TILE_BORDER) continue;
                    u8 b = invert_bits ? (read_bit(inner_x, inner_y) ^ 1u)
                                       : read_bit(inner_x, inner_y);
                    ones += b ? 1u : 0u;
                    ++samples;
                }
                if (samples == 0u) return false;
                u8 bit_value = (ones * 2u >= samples) ? 1u : 0u;
                header_out |= ((u32)bit_value << bit);
            }
            u16 magic16 = (u16)((header_out >> 16) & 0xFFFFu);
            if (magic16 != (u16)0x4D4Du) { // 'M''K'
                return false;
            }
            u32 schema = (header_out >> 12) & 0x0Fu;
            if (schema != TILE_SCHEMA_VERSION) return false;
            u32 meta_len = (header_out >> 4) & 0xFFu;
            u32 palette_count = header_out & 0x0Fu;
            if (palette_count < 2u || palette_count > MAX_CUSTOM_PALETTE_COLORS) return false;
            if (meta_len == 0u || meta_len > 255u) return false;
            if (meta_len + TILE_RS_PARITY_BYTES > 255u) return false;
            return true;
        };

        u32 header = 0u;
        bool inverted_header = false;
        if (!decode_header(false, header)) {
            if (!decode_header(true, header)) {
                return false;
            }
            inverted_header = true;
        }

        u32 meta_len = (header >> 4) & 0xFFu;
        u32 palette_count = header & 0x0Fu;

        // Extract RS codeword bits from tile inner area.
        u32 hole_x0 = (TILE_SIDE - TILE_HOLE_SIDE) / 2u;
        u32 hole_y0 = (TILE_SIDE - TILE_HOLE_SIDE) / 2u;
        u32 hole_x1 = hole_x0 + TILE_HOLE_SIDE;
        u32 hole_y1 = hole_y0 + TILE_HOLE_SIDE;

        usize total_bits = ((usize)meta_len + (usize)TILE_RS_PARITY_BYTES) * 8u;
        ByteBuffer codeword;
        if (!codeword.ensure((usize)meta_len + (usize)TILE_RS_PARITY_BYTES)) return false;
        codeword.size = (usize)meta_len + (usize)TILE_RS_PARITY_BYTES;
        for (usize i = 0u; i < codeword.size; ++i) codeword.data[i] = 0u;

        usize bit_cursor = 0u;
        for (u32 inner_y = TILE_BORDER; inner_y < TILE_SIDE - TILE_BORDER; ++inner_y) {
            if (inner_y < TILE_BORDER + TILE_HEADER_REPETITIONS) continue;
            for (u32 inner_x = TILE_BORDER; inner_x < TILE_SIDE - TILE_BORDER; ++inner_x) {
                if (inner_x >= hole_x0 && inner_x < hole_x1 && inner_y >= hole_y0 && inner_y < hole_y1) continue;
                if (bit_cursor >= total_bits) break;
                u8 bit = inverted_header ? (read_bit(inner_x, inner_y) ^ 1u) : read_bit(inner_x, inner_y);
                usize byte_index = bit_cursor / 8u;
                u32 bit_index = (u32)(bit_cursor % 8u);
                if (byte_index < codeword.size) {
                    codeword.data[byte_index] |= (u8)(bit << bit_index);
                }
                ++bit_cursor;
            }
            if (bit_cursor >= total_bits) break;
        }
        if (bit_cursor != total_bits) return false;

        u32 corrections = 0u;
        bool rs_ok = rs_decode_with_parity_32(codeword, (usize)meta_len, corrections);

        // Validate CRC byte at end of metadata (also doubles as a fallback check when RS fails).
        if (meta_len < 1u) return false;
        u8 expected_crc = codeword.data[meta_len - 1u];
        u8 computed_crc = compute_crc8(codeword.data, meta_len - 1u);
        if (!rs_ok && expected_crc != computed_crc) {
            return false;
        }
        if (expected_crc != computed_crc) {
            return false;
        }

        // Parse metadata bytes (bit-packed) into Values.
        BitReader reader;
        reader.reset(codeword.data, (u64)(meta_len - 1u) * 8u);
        u64 magic32 = reader.read_bits(32u);
        if (reader.failed || magic32 != 0x4D4B4D44u) return false;
        u64 schema8 = reader.read_bits(8u);
        if (reader.failed || schema8 != TILE_SCHEMA_VERSION) return false;
        u64 pal_count = reader.read_bits(8u);
        if (reader.failed || pal_count != (u64)palette_count) return false;
        out_values.palette_count = (u32)pal_count;
        for (u32 i = 0u; i < out_values.palette_count; ++i) {
            u64 r = reader.read_bits(8u);
            u64 g = reader.read_bits(8u);
            u64 b = reader.read_bits(8u);
            if (reader.failed) return false;
            out_values.palette[i].r = (u8)r;
            out_values.palette[i].g = (u8)g;
            out_values.palette[i].b = (u8)b;
        }
        out_values.page_bits = reader.read_bits(64u);
        out_values.page_count = reader.read_bits(32u);
        out_values.page_index = reader.read_bits(32u);
        out_values.page_width_pixels = (u32)reader.read_bits(32u);
        out_values.page_height_pixels = (u32)reader.read_bits(32u);
        out_values.footer_rows = (u32)reader.read_bits(16u);
        out_values.fiducial_marker_size_pixels = (u32)reader.read_bits(8u);
        out_values.ecc_enabled = reader.read_bit() ? true : false;
        out_values.ecc_block_data = (u16)reader.read_bits(16u);
        out_values.ecc_parity = (u16)reader.read_bits(16u);
        out_values.ecc_block_count = reader.read_bits(32u);
        out_values.ecc_original_bytes = reader.read_bits(64u);
        if (reader.failed) return false;

        // Rebuild palette_text as hex tokens for existing decode pipeline.
        if (!build_palette_text_from_colors(out_values.palette, out_values.palette_count, out_palette_text)) {
            return false;
        }
        return true;
    }

    struct AffineParams {
        double center_x;
        double center_y;
        double pitch_pixels; // pixels per module
        double angle_rad;
    };

    static bool match_tile_header_affine(const u8* pixel_data_rgb,
                                         u32 width_pixels,
                                         u32 height_pixels,
                                         u32 data_height_pixels,
                                         const AffineParams& affine,
                                         u32& header_out,
                                         bool& inverted_out,
                                         double& confidence_out) {
        header_out = 0u;
        inverted_out = false;
        confidence_out = 0.0;
        if (!pixel_data_rgb || width_pixels == 0u || height_pixels == 0u || data_height_pixels == 0u) return false;
        if (data_height_pixels > height_pixels) data_height_pixels = height_pixels;
        if (!(affine.pitch_pixels > 0.0)) return false;

        double c = cos(affine.angle_rad);
        double s = sin(affine.angle_rad);
        double vx_x = affine.pitch_pixels * c;
        double vx_y = affine.pitch_pixels * s;
        double vy_x = -affine.pitch_pixels * s;
        double vy_y = affine.pitch_pixels * c;
        double half = ((double)TILE_SIDE - 1.0) * 0.5;

        double tl_x = affine.center_x + vx_x * (-half) + vy_x * (-half);
        double tl_y = affine.center_y + vx_y * (-half) + vy_y * (-half);
        double tr_x = affine.center_x + vx_x * (half) + vy_x * (-half);
        double tr_y = affine.center_y + vx_y * (half) + vy_y * (-half);
        double bl_x = affine.center_x + vx_x * (-half) + vy_x * (half);
        double bl_y = affine.center_y + vx_y * (-half) + vy_y * (half);
        double br_x = affine.center_x + vx_x * (half) + vy_x * (half);
        double br_y = affine.center_y + vx_y * (half) + vy_y * (half);
        double min_x = tl_x, max_x = tl_x, min_y = tl_y, max_y = tl_y;
        auto expand = [&](double x, double y) {
            if (x < min_x) min_x = x;
            if (x > max_x) max_x = x;
            if (y < min_y) min_y = y;
            if (y > max_y) max_y = y;
        };
        expand(tr_x, tr_y);
        expand(bl_x, bl_y);
        expand(br_x, br_y);
        if (min_x < 0.0 || min_y < 0.0 || max_x > (double)(width_pixels - 1u) ||
            max_y > (double)(data_height_pixels - 1u)) {
            return false;
        }

        auto module_luminance = [&](u32 module_x, u32 module_y) -> double {
            double sx = (double)module_x - half;
            double sy = (double)module_y - half;
            double x = affine.center_x + vx_x * sx + vy_x * sy;
            double y = affine.center_y + vx_y * sx + vy_y * sy;
            return sample_luminance_bilinear(pixel_data_rgb, width_pixels, height_pixels, x, y);
        };

        // Cheap threshold estimate for header probing.
        double min_l = 255.0;
        double max_l = 0.0;
        for (u32 y = TILE_BORDER; y < TILE_SIDE - TILE_BORDER; y += 4u) {
            for (u32 x = TILE_BORDER; x < TILE_SIDE - TILE_BORDER; x += 4u) {
                double l = module_luminance(x, y);
                if (l < min_l) min_l = l;
                if (l > max_l) max_l = l;
            }
        }
        if (!(max_l > min_l + 1.0)) return false;
        double threshold = (min_l + max_l) * 0.5;

        auto read_bit = [&](u32 x, u32 y) -> u8 {
            double l = module_luminance(x, y);
            return (l < threshold) ? 1u : 0u; // dark => 1
        };

        auto decode_header = [&](bool invert_bits, u32& header_tmp, double& conf_avg) -> bool {
            header_tmp = 0u;
            double conf_sum = 0.0;
            for (u32 bit = 0u; bit < TILE_HEADER_BITS; ++bit) {
                u32 ones = 0u;
                u32 samples = 0u;
                for (u32 rep = 0u; rep < TILE_HEADER_REPETITIONS; ++rep) {
                    u32 inner_y = TILE_BORDER + rep;
                    u32 inner_x = TILE_BORDER + bit;
                    if (inner_x >= TILE_SIDE - TILE_BORDER) continue;
                    if (inner_y >= TILE_SIDE - TILE_BORDER) continue;
                    u8 b = invert_bits ? (read_bit(inner_x, inner_y) ^ 1u) : read_bit(inner_x, inner_y);
                    ones += b ? 1u : 0u;
                    ++samples;
                }
                if (samples == 0u) return false;
                u8 bit_value = (ones * 2u >= samples) ? 1u : 0u;
                header_tmp |= ((u32)bit_value << bit);
                double margin = (double)((ones * 2u >= samples) ? (ones * 2u - samples) : (samples - ones * 2u));
                conf_sum += margin / (double)samples;
            }
            conf_avg = conf_sum / (double)TILE_HEADER_BITS;
            u16 magic16 = (u16)((header_tmp >> 16) & 0xFFFFu);
            if (magic16 != (u16)0x4D4Du) { // 'M''K'
                return false;
            }
            u32 schema = (header_tmp >> 12) & 0x0Fu;
            if (schema != TILE_SCHEMA_VERSION) return false;
            u32 meta_len = (header_tmp >> 4) & 0xFFu;
            u32 palette_count = header_tmp & 0x0Fu;
            if (palette_count < 2u || palette_count > MAX_CUSTOM_PALETTE_COLORS) return false;
            if (meta_len == 0u || meta_len > 255u) return false;
            if (meta_len + TILE_RS_PARITY_BYTES > 255u) return false;
            return true;
        };

        u32 header = 0u;
        bool inverted = false;
        double conf_avg = 0.0;
        if (!decode_header(false, header, conf_avg)) {
            if (!decode_header(true, header, conf_avg)) {
                return false;
            }
            inverted = true;
        }

        header_out = header;
        inverted_out = inverted;
        confidence_out = conf_avg;
        return true;
    }

    static bool decode_tile_affine(const u8* pixel_data_rgb,
                                   u32 width_pixels,
                                   u32 height_pixels,
                                   u32 data_height_pixels,
                                   const AffineParams& affine,
                                   Values& out_values,
                                   ByteBuffer& out_palette_text,
                                   double* out_border_mismatch = 0) {
        if (!pixel_data_rgb || width_pixels == 0u || height_pixels == 0u || data_height_pixels == 0u) return false;
        if (data_height_pixels > height_pixels) data_height_pixels = height_pixels;
        if (!(affine.pitch_pixels > 0.0)) return false;

        double c = cos(affine.angle_rad);
        double s = sin(affine.angle_rad);
        double vx_x = affine.pitch_pixels * c;
        double vx_y = affine.pitch_pixels * s;
        double vy_x = -affine.pitch_pixels * s;
        double vy_y = affine.pitch_pixels * c;
        double half = ((double)TILE_SIDE - 1.0) * 0.5;

        // Ensure the transformed tile stays within bounds (data region).
        double tl_x = affine.center_x + vx_x * (-half) + vy_x * (-half);
        double tl_y = affine.center_y + vx_y * (-half) + vy_y * (-half);
        double tr_x = affine.center_x + vx_x * (half) + vy_x * (-half);
        double tr_y = affine.center_y + vx_y * (half) + vy_y * (-half);
        double bl_x = affine.center_x + vx_x * (-half) + vy_x * (half);
        double bl_y = affine.center_y + vx_y * (-half) + vy_y * (half);
        double br_x = affine.center_x + vx_x * (half) + vy_x * (half);
        double br_y = affine.center_y + vx_y * (half) + vy_y * (half);
        double min_x = tl_x, max_x = tl_x, min_y = tl_y, max_y = tl_y;
        auto expand = [&](double x, double y) {
            if (x < min_x) min_x = x;
            if (x > max_x) max_x = x;
            if (y < min_y) min_y = y;
            if (y > max_y) max_y = y;
        };
        expand(tr_x, tr_y);
        expand(bl_x, bl_y);
        expand(br_x, br_y);
        if (min_x < 0.0 || min_y < 0.0 || max_x > (double)(width_pixels - 1u) ||
            max_y > (double)(data_height_pixels - 1u)) {
            return false;
        }

        auto module_luminance = [&](u32 module_x, u32 module_y) -> double {
            double sx = (double)module_x - half;
            double sy = (double)module_y - half;
            double x = affine.center_x + vx_x * sx + vy_x * sy;
            double y = affine.center_y + vx_y * sx + vy_y * sy;
            return sample_luminance_bilinear(pixel_data_rgb, width_pixels, height_pixels, x, y);
        };

        // Threshold from inner region statistics (like decode_tile).
        double min_l = 255.0;
        double max_l = 0.0;
        for (u32 y = 0u; y < TILE_SIDE; ++y) {
            for (u32 x = 0u; x < TILE_SIDE; ++x) {
                if (x < TILE_BORDER || y < TILE_BORDER || x >= TILE_SIDE - TILE_BORDER || y >= TILE_SIDE - TILE_BORDER) {
                    continue;
                }
                double l = module_luminance(x, y);
                if (l < min_l) min_l = l;
                if (l > max_l) max_l = l;
            }
        }
        if (!(max_l > min_l + 1.0)) return false;
        double threshold = (min_l + max_l) * 0.5;

        auto read_bit = [&](u32 x, u32 y) -> u8 {
            double l = module_luminance(x, y);
            return (l < threshold) ? 1u : 0u; // dark => 1
        };

        auto decode_header = [&](bool invert_bits, u32& header_out) -> bool {
            header_out = 0u;
            for (u32 bit = 0u; bit < TILE_HEADER_BITS; ++bit) {
                u32 ones = 0u;
                u32 samples = 0u;
                for (u32 rep = 0u; rep < TILE_HEADER_REPETITIONS; ++rep) {
                    u32 inner_y = TILE_BORDER + rep;
                    u32 inner_x = TILE_BORDER + bit;
                    if (inner_x >= TILE_SIDE - TILE_BORDER) continue;
                    if (inner_y >= TILE_SIDE - TILE_BORDER) continue;
                    u8 b = invert_bits ? (read_bit(inner_x, inner_y) ^ 1u) : read_bit(inner_x, inner_y);
                    ones += b ? 1u : 0u;
                    ++samples;
                }
                if (samples == 0u) return false;
                u8 bit_value = (ones * 2u >= samples) ? 1u : 0u;
                header_out |= ((u32)bit_value << bit);
            }
            u16 magic16 = (u16)((header_out >> 16) & 0xFFFFu);
            if (magic16 != (u16)0x4D4Du) { // 'M''K'
                return false;
            }
            u32 schema = (header_out >> 12) & 0x0Fu;
            if (schema != TILE_SCHEMA_VERSION) return false;
            u32 meta_len = (header_out >> 4) & 0xFFu;
            u32 palette_count = header_out & 0x0Fu;
            if (palette_count < 2u || palette_count > MAX_CUSTOM_PALETTE_COLORS) return false;
            if (meta_len == 0u || meta_len > 255u) return false;
            if (meta_len + TILE_RS_PARITY_BYTES > 255u) return false;
            return true;
        };

        u32 header = 0u;
        bool inverted_header = false;
        if (!decode_header(false, header)) {
            if (!decode_header(true, header)) {
                return false;
            }
            inverted_header = true;
        }

        if (out_border_mismatch) {
            u32 mismatches = 0u;
            u32 samples = 0u;
            for (u32 y = 0u; y < TILE_SIDE; ++y) {
                for (u32 x = 0u; x < TILE_SIDE; ++x) {
                    bool border = (x < TILE_BORDER) || (y < TILE_BORDER) ||
                                  (x >= TILE_SIDE - TILE_BORDER) || (y >= TILE_SIDE - TILE_BORDER);
                    if (!border) continue;
                    u8 expected = (u8)(((x + y) & 1u) ? 1u : 0u);
                    u8 got = read_bit(x, y);
                    if (got != expected) {
                        ++mismatches;
                    }
                    ++samples;
                }
            }
            *out_border_mismatch = (samples > 0u) ? ((double)mismatches / (double)samples) : 1.0;
        }

        u32 meta_len = (header >> 4) & 0xFFu;
        u32 palette_count = header & 0x0Fu;

        // Extract RS codeword bits from tile inner area.
        u32 hole_x0 = (TILE_SIDE - TILE_HOLE_SIDE) / 2u;
        u32 hole_y0 = (TILE_SIDE - TILE_HOLE_SIDE) / 2u;
        u32 hole_x1 = hole_x0 + TILE_HOLE_SIDE;
        u32 hole_y1 = hole_y0 + TILE_HOLE_SIDE;

        usize total_bits = ((usize)meta_len + (usize)TILE_RS_PARITY_BYTES) * 8u;
        ByteBuffer codeword;
        if (!codeword.ensure((usize)meta_len + (usize)TILE_RS_PARITY_BYTES)) return false;
        codeword.size = (usize)meta_len + (usize)TILE_RS_PARITY_BYTES;
        for (usize i = 0u; i < codeword.size; ++i) codeword.data[i] = 0u;

        usize bit_cursor = 0u;
        for (u32 inner_y = TILE_BORDER; inner_y < TILE_SIDE - TILE_BORDER; ++inner_y) {
            if (inner_y < TILE_BORDER + TILE_HEADER_REPETITIONS) continue;
            for (u32 inner_x = TILE_BORDER; inner_x < TILE_SIDE - TILE_BORDER; ++inner_x) {
                if (inner_x >= hole_x0 && inner_x < hole_x1 && inner_y >= hole_y0 && inner_y < hole_y1) continue;
                if (bit_cursor >= total_bits) break;
                u8 bit = inverted_header ? (read_bit(inner_x, inner_y) ^ 1u) : read_bit(inner_x, inner_y);
                usize byte_index = bit_cursor / 8u;
                u32 bit_index = (u32)(bit_cursor % 8u);
                if (byte_index < codeword.size) {
                    codeword.data[byte_index] |= (u8)(bit << bit_index);
                }
                ++bit_cursor;
            }
            if (bit_cursor >= total_bits) break;
        }
        if (bit_cursor != total_bits) return false;

        u32 corrections = 0u;
        bool rs_ok = rs_decode_with_parity_32(codeword, (usize)meta_len, corrections);

        if (meta_len < 1u) return false;
        u8 expected_crc = codeword.data[meta_len - 1u];
        u8 computed_crc = compute_crc8(codeword.data, meta_len - 1u);
        if (!rs_ok && expected_crc != computed_crc) {
            return false;
        }
        if (expected_crc != computed_crc) {
            return false;
        }

        BitReader reader;
        reader.reset(codeword.data, (u64)(meta_len - 1u) * 8u);
        u64 magic32 = reader.read_bits(32u);
        if (reader.failed || magic32 != 0x4D4B4D44u) return false;
        u64 schema8 = reader.read_bits(8u);
        if (reader.failed || schema8 != TILE_SCHEMA_VERSION) return false;
        u64 pal_count = reader.read_bits(8u);
        if (reader.failed || pal_count != (u64)palette_count) return false;
        out_values.palette_count = (u32)pal_count;
        for (u32 i = 0u; i < out_values.palette_count; ++i) {
            u64 r = reader.read_bits(8u);
            u64 g = reader.read_bits(8u);
            u64 b = reader.read_bits(8u);
            if (reader.failed) return false;
            out_values.palette[i].r = (u8)r;
            out_values.palette[i].g = (u8)g;
            out_values.palette[i].b = (u8)b;
        }
        out_values.page_bits = reader.read_bits(64u);
        out_values.page_count = reader.read_bits(32u);
        out_values.page_index = reader.read_bits(32u);
        out_values.page_width_pixels = (u32)reader.read_bits(32u);
        out_values.page_height_pixels = (u32)reader.read_bits(32u);
        out_values.footer_rows = (u32)reader.read_bits(16u);
        out_values.fiducial_marker_size_pixels = (u32)reader.read_bits(8u);
        out_values.ecc_enabled = reader.read_bit() ? true : false;
        out_values.ecc_block_data = (u16)reader.read_bits(16u);
        out_values.ecc_parity = (u16)reader.read_bits(16u);
        out_values.ecc_block_count = reader.read_bits(32u);
        out_values.ecc_original_bytes = reader.read_bits(64u);
        if (reader.failed) return false;

        if (!build_palette_text_from_colors(out_values.palette, out_values.palette_count, out_palette_text)) {
            return false;
        }
        return true;
    }

    static bool search_decode_tile_affine(const u8* pixel_data_rgb,
                                          u32 width_pixels,
                                          u32 height_pixels,
                                          u32 data_height_pixels,
                                          double max_abs_angle_degrees,
                                          Values& out_values,
                                          ByteBuffer& out_palette_text,
                                          AffineParams* found_affine_out = 0) {
        if (!pixel_data_rgb || width_pixels == 0u || height_pixels == 0u || data_height_pixels == 0u) return false;
        if (data_height_pixels > height_pixels) data_height_pixels = height_pixels;

        // For now the metadata tile is expected near the page center (even when the fiducial grid
        // isn't reliable or present), so anchor the search at the image midpoint.
        double base_center_x = (double)width_pixels * 0.5;
        double base_center_y = (double)data_height_pixels * 0.5;

        // Estimate pixels-per-module from square page guess.
        double pitch_guess = 1.0;
        u64 logical_guess = estimate_square_page_from_image(width_pixels, height_pixels);
        if (logical_guess > 0u) {
            double sx = (double)width_pixels / (double)logical_guess;
            double sy = (double)height_pixels / (double)logical_guess;
            pitch_guess = 0.5 * (sx + sy);
        }
        if (!(pitch_guess > 0.0)) pitch_guess = 1.0;

        // Stage 1: find a header match (cheap), then refine and fully decode.
        // NOTE: `estimate_square_page_from_image()` is tuned for general pages and is not a reliable
        // predictor of metadata-tile pixels-per-module (e.g. it may prefer ~2x over ~3x).
        // Use a broader pitch search window here.
        double pitch_min = 0.90;
        double pitch_max = 4.20;
        const int kCenterSpan = 96;
        const int kCenterStepCoarse = 4;

        if (debug_logging_enabled()) {
            char buf[64];
            console_write(2, "debug metadata tile: affine search base_center=");
            format_fixed_3(base_center_x, buf, sizeof(buf));
            console_write(2, buf);
            console_write(2, ",");
            format_fixed_3(base_center_y, buf, sizeof(buf));
            console_write(2, buf);
            console_write(2, " pitch_guess=");
            format_fixed_3(pitch_guess, buf, sizeof(buf));
            console_write(2, buf);
            console_write(2, " pitch_range=");
            format_fixed_3(pitch_min, buf, sizeof(buf));
            console_write(2, buf);
            console_write(2, "..");
            format_fixed_3(pitch_max, buf, sizeof(buf));
            console_line(2, buf);
        }

        bool have_best = false;
        double best_score = 1e30;
        AffineParams best_affine = {};

        for (int dy = -kCenterSpan; dy <= kCenterSpan; dy += kCenterStepCoarse) {
            for (int dx = -kCenterSpan; dx <= kCenterSpan; dx += kCenterStepCoarse) {
                double cx = base_center_x + (double)dx;
                double cy = base_center_y + (double)dy;
                for (double angle = -max_abs_angle_degrees; angle <= max_abs_angle_degrees + 1e-9; angle += 0.1) {
                    double angle_rad = angle * (3.14159265358979323846 / 180.0);
                    for (double pitch = pitch_min; pitch <= pitch_max + 1e-9; pitch += 0.1) {
                        AffineParams affine;
                        affine.center_x = cx;
                        affine.center_y = cy;
                        affine.pitch_pixels = pitch;
                        affine.angle_rad = angle_rad;
                        u32 header = 0u;
                        bool inverted = false;
                        double confidence = 0.0;
                        if (!match_tile_header_affine(pixel_data_rgb,
                                                      width_pixels,
                                                      height_pixels,
                                                      data_height_pixels,
                                                      affine,
                                                      header,
                                                      inverted,
                                                      confidence)) {
                            continue;
                        }
                        if (confidence < 0.55) {
                            continue;
                        }
                        double score = -confidence;
                        score += fabs(angle) * 0.01;
                        score += fabs(pitch - pitch_guess) * 0.05;
                        score += (fabs((double)dx) + fabs((double)dy)) * 0.0005;
                        if (score < best_score) {
                            best_score = score;
                            best_affine = affine;
                            have_best = true;
                        }
                    }
                }
            }
        }

        if (!have_best) {
            return false;
        }

        // Stage 2: refine around the best header match and fully decode.
        const int kRefineSpan = 6;
        const double kRefineAngleSpan = 0.75;
        const double kRefinePitchSpan = 0.25;
        for (int dy = -kRefineSpan; dy <= kRefineSpan; ++dy) {
            for (int dx = -kRefineSpan; dx <= kRefineSpan; ++dx) {
                double cx = best_affine.center_x + (double)dx;
                double cy = best_affine.center_y + (double)dy;
                double base_angle_deg = best_affine.angle_rad * (180.0 / 3.14159265358979323846);
                for (double angle = base_angle_deg - kRefineAngleSpan; angle <= base_angle_deg + kRefineAngleSpan + 1e-9; angle += 0.05) {
                    double angle_rad = angle * (3.14159265358979323846 / 180.0);
                    for (double pitch = best_affine.pitch_pixels - kRefinePitchSpan; pitch <= best_affine.pitch_pixels + kRefinePitchSpan + 1e-9; pitch += 0.01) {
                        if (!(pitch > 0.0)) continue;
                        AffineParams affine;
                        affine.center_x = cx;
                        affine.center_y = cy;
                        affine.pitch_pixels = pitch;
                        affine.angle_rad = angle_rad;
                        Values values;
                        ByteBuffer pal_text;
                        if (!decode_tile_affine(pixel_data_rgb,
                                                width_pixels,
                                                height_pixels,
                                                data_height_pixels,
                                                affine,
                                                values,
                                                pal_text)) {
                            continue;
                        }
                        out_values = values;
                        byte_buffer_move(out_palette_text, pal_text);
                        if (found_affine_out) {
                            *found_affine_out = affine;
                        }
                        if (debug_logging_enabled()) {
                            char buf_angle[64];
                            char buf_pitch[64];
                            char buf_cx[64];
                            char buf_cy[64];
                            format_fixed_3(angle, buf_angle, sizeof(buf_angle));
                            format_fixed_3(pitch, buf_pitch, sizeof(buf_pitch));
                            format_fixed_3(cx, buf_cx, sizeof(buf_cx));
                            format_fixed_3(cy, buf_cy, sizeof(buf_cy));
                            console_write(2, "debug metadata tile: affine decoded angle_deg=");
                            console_write(2, buf_angle);
                            console_write(2, " pitch=");
                            console_write(2, buf_pitch);
                            console_write(2, " center=");
                            console_write(2, buf_cx);
                            console_write(2, ",");
                            console_line(2, buf_cy);
                        }
                        return true;
                    }
                }
            }
        }

        return false;
    }
} // namespace MetadataTile

static double debug_sample_luminance_bilinear(const u8* pixel_data_rgb,
                                              u32 width_pixels,
                                              u32 height_pixels,
                                              double x,
                                              double y) {
    if (!pixel_data_rgb || width_pixels == 0u || height_pixels == 0u) {
        return 0.0;
    }
    x = clamp_double(x, 0.0, (double)(width_pixels - 1u));
    y = clamp_double(y, 0.0, (double)(height_pixels - 1u));

    u32 x0 = (u32)floor(x);
    u32 y0 = (u32)floor(y);
    u32 x1 = (x0 + 1u < width_pixels) ? (x0 + 1u) : x0;
    u32 y1 = (y0 + 1u < height_pixels) ? (y0 + 1u) : y0;
    double fx = x - (double)x0;
    double fy = y - (double)y0;

    auto lum_at = [&](u32 ix, u32 iy) -> double {
        usize idx = ((usize)iy * (usize)width_pixels + (usize)ix) * 3u;
        u8 r = pixel_data_rgb[idx + 0u];
        u8 g = pixel_data_rgb[idx + 1u];
        u8 b = pixel_data_rgb[idx + 2u];
        return 0.2126 * (double)r + 0.7152 * (double)g + 0.0722 * (double)b;
    };

    double v00 = lum_at(x0, y0);
    double v10 = lum_at(x1, y0);
    double v01 = lum_at(x0, y1);
    double v11 = lum_at(x1, y1);

    double v0 = v00 * (1.0 - fx) + v10 * fx;
    double v1 = v01 * (1.0 - fx) + v11 * fx;
    return v0 * (1.0 - fy) + v1 * fy;
}

struct DebugMetadataTileProbe {
    bool found;
    bool inverted_header;
    double center_x;
    double center_y;
    double pitch_pixels;
    double angle_degrees;
    u32 header;
    u32 meta_len;
    u32 palette_count;

    DebugMetadataTileProbe()
        : found(false),
          inverted_header(false),
          center_x(0.0),
          center_y(0.0),
          pitch_pixels(0.0),
          angle_degrees(0.0),
          header(0u),
          meta_len(0u),
          palette_count(0u) {}
};

static bool debug_try_metadata_tile_header_affine(const u8* pixel_data_rgb,
                                                 u32 width_pixels,
                                                 u32 height_pixels,
                                                 u32 data_height_pixels,
                                                 double center_x,
                                                 double center_y,
                                                 double pitch_pixels,
                                                 double angle_rad,
                                                 DebugMetadataTileProbe& out_probe) {
    using namespace MetadataTile;
    if (!pixel_data_rgb || width_pixels == 0u || height_pixels == 0u || data_height_pixels == 0u) {
        return false;
    }
    if (data_height_pixels > height_pixels) {
        data_height_pixels = height_pixels;
    }
    if (!(pitch_pixels > 0.0)) {
        return false;
    }

    double c = cos(angle_rad);
    double s = sin(angle_rad);
    double vx_x = pitch_pixels * c;
    double vx_y = pitch_pixels * s;
    double vy_x = -pitch_pixels * s;
    double vy_y = pitch_pixels * c;
    double half = ((double)TILE_SIDE - 1.0) * 0.5;

    auto corner_x = [&](double sx, double sy) -> double {
        return center_x + vx_x * sx + vy_x * sy;
    };
    auto corner_y = [&](double sx, double sy) -> double {
        return center_y + vx_y * sx + vy_y * sy;
    };
    double tl_x = corner_x(-half, -half);
    double tl_y = corner_y(-half, -half);
    double tr_x = corner_x(half, -half);
    double tr_y = corner_y(half, -half);
    double bl_x = corner_x(-half, half);
    double bl_y = corner_y(-half, half);
    double br_x = corner_x(half, half);
    double br_y = corner_y(half, half);

    double min_x = tl_x;
    double max_x = tl_x;
    double min_y = tl_y;
    double max_y = tl_y;
    auto expand = [&](double x, double y) {
        if (x < min_x) min_x = x;
        if (x > max_x) max_x = x;
        if (y < min_y) min_y = y;
        if (y > max_y) max_y = y;
    };
    expand(tr_x, tr_y);
    expand(bl_x, bl_y);
    expand(br_x, br_y);
    if (min_x < 0.0 || min_y < 0.0 || max_x > (double)(width_pixels - 1u) ||
        max_y > (double)(data_height_pixels - 1u)) {
        return false;
    }

    auto module_lum = [&](double mx, double my) -> double {
        // module indices in [0, TILE_SIDE-1], map around center so (half,half) is tile center
        double sx = mx - half;
        double sy = my - half;
        double x = center_x + vx_x * sx + vy_x * sy;
        double y = center_y + vx_y * sx + vy_y * sy;
        return debug_sample_luminance_bilinear(pixel_data_rgb, width_pixels, height_pixels, x, y);
    };

    // Cheap threshold estimate: subsample inner modules.
    double min_l = 255.0;
    double max_l = 0.0;
    for (u32 y = TILE_BORDER; y < TILE_SIDE - TILE_BORDER; y += 4u) {
        for (u32 x = TILE_BORDER; x < TILE_SIDE - TILE_BORDER; x += 4u) {
            double l = module_lum((double)x, (double)y);
            if (l < min_l) min_l = l;
            if (l > max_l) max_l = l;
        }
    }
    if (!(max_l > min_l + 1.0)) {
        return false;
    }
    double threshold = (min_l + max_l) * 0.5;

    auto read_bit = [&](u32 mx, u32 my) -> u8 {
        double l = module_lum((double)mx, (double)my);
        return (l < threshold) ? 1u : 0u; // dark => 1
    };

    auto decode_header = [&](bool invert_bits, u32& header_out) -> bool {
        header_out = 0u;
        for (u32 bit = 0u; bit < TILE_HEADER_BITS; ++bit) {
            u32 ones = 0u;
            u32 samples = 0u;
            for (u32 rep = 0u; rep < TILE_HEADER_REPETITIONS; ++rep) {
                u32 inner_y = TILE_BORDER + rep;
                u32 inner_x = TILE_BORDER + bit;
                if (inner_x >= TILE_SIDE - TILE_BORDER) continue;
                if (inner_y >= TILE_SIDE - TILE_BORDER) continue;
                u8 b = read_bit(inner_x, inner_y);
                if (invert_bits) b ^= 1u;
                ones += b ? 1u : 0u;
                ++samples;
            }
            if (samples == 0u) return false;
            u32 bit_value = (ones * 2u >= samples) ? 1u : 0u;
            header_out |= (bit_value << bit);
        }
        u16 magic16 = (u16)((header_out >> 16) & 0xFFFFu);
        if (magic16 != (u16)0x4D4Du) {
            return false;
        }
        u32 schema = (header_out >> 12) & 0x0Fu;
        if (schema != TILE_SCHEMA_VERSION) return false;
        u32 meta_len = (header_out >> 4) & 0xFFu;
        u32 palette_count = header_out & 0x0Fu;
        if (palette_count < 2u || palette_count > MAX_CUSTOM_PALETTE_COLORS) return false;
        if (meta_len == 0u || meta_len > 255u) return false;
        if (meta_len + TILE_RS_PARITY_BYTES > 255u) return false;
        return true;
    };

    u32 header = 0u;
    bool inverted = false;
    if (!decode_header(false, header)) {
        if (!decode_header(true, header)) {
            return false;
        }
        inverted = true;
    }

    out_probe.found = true;
    out_probe.inverted_header = inverted;
    out_probe.center_x = center_x;
    out_probe.center_y = center_y;
    out_probe.pitch_pixels = pitch_pixels;
    out_probe.angle_degrees = angle_rad * (180.0 / 3.14159265358979323846);
    out_probe.header = header;
    out_probe.meta_len = (header >> 4) & 0xFFu;
    out_probe.palette_count = header & 0x0Fu;
    return true;
}

static void debug_probe_metadata_tile_affine(const u8* pixel_data_rgb,
                                             u32 width_pixels,
                                             u32 height_pixels,
                                             u32 data_height_pixels) {
    if (!debug_logging_enabled()) return;
    using namespace MetadataTile;
    if (!pixel_data_rgb || width_pixels == 0u || height_pixels == 0u) return;

    if (data_height_pixels == 0u || data_height_pixels > height_pixels) {
        data_height_pixels = height_pixels;
    }

    console_write(2, "debug tile probe: canvas=");
    char bufw[32], bufh[32];
    u64_to_ascii(width_pixels, bufw, sizeof(bufw));
    u64_to_ascii(height_pixels, bufh, sizeof(bufh));
    console_write(2, bufw);
    console_write(2, "x");
    console_write(2, bufh);
    console_write(2, " data_h=");
    u64_to_ascii(data_height_pixels, bufh, sizeof(bufh));
    console_line(2, bufh);

    double base_center_x = (double)width_pixels * 0.5;
    double base_center_y = (double)data_height_pixels * 0.5;

    DebugMetadataTileProbe best;
    bool found_any = false;

    // Coarse search around the page center for small rotations and moderate scale factors.
    // This is diagnostic-only and runs only with --debug.
    for (int dy = -16; dy <= 16 && !found_any; dy += 4) {
        for (int dx = -16; dx <= 16 && !found_any; dx += 4) {
            double cx = base_center_x + (double)dx;
            double cy = base_center_y + (double)dy;
            for (int a = -20; a <= 20 && !found_any; ++a) {
                double angle_deg = (double)a * 0.1;
                double angle_rad = angle_deg * (3.14159265358979323846 / 180.0);
                for (int p = 18; p <= 36 && !found_any; ++p) {
                    double pitch = (double)p * 0.1;
                    DebugMetadataTileProbe probe;
                    if (debug_try_metadata_tile_header_affine(pixel_data_rgb,
                                                             width_pixels,
                                                             height_pixels,
                                                             data_height_pixels,
                                                             cx,
                                                             cy,
                                                             pitch,
                                                             angle_rad,
                                                             probe)) {
                        best = probe;
                        found_any = true;
                    }
                }
            }
        }
    }

    if (!found_any) {
        console_line(2, "debug tile probe: no header match in search window");
        return;
    }

    console_write(2, "debug tile probe: header match angle_deg=");
    char buf_angle[64];
    char buf_pitch[64];
    char buf_cx[64];
    char buf_cy[64];
    format_fixed_3(best.angle_degrees, buf_angle, sizeof(buf_angle));
    format_fixed_3(best.pitch_pixels, buf_pitch, sizeof(buf_pitch));
    format_fixed_3(best.center_x, buf_cx, sizeof(buf_cx));
    format_fixed_3(best.center_y, buf_cy, sizeof(buf_cy));
    console_write(2, buf_angle);
    console_write(2, " pitch=");
    console_write(2, buf_pitch);
    console_write(2, " center=");
    console_write(2, buf_cx);
    console_write(2, ",");
    console_line(2, buf_cy);

    console_write(2, "debug tile probe: header=0x");
    char buf_hdr[32];
    u32_to_hex(best.header, buf_hdr, sizeof(buf_hdr));
    console_write(2, buf_hdr);
    console_write(2, " meta_len=");
    u64_to_ascii(best.meta_len, buf_hdr, sizeof(buf_hdr));
    console_write(2, buf_hdr);
    console_write(2, " palette=");
    u64_to_ascii(best.palette_count, buf_hdr, sizeof(buf_hdr));
    console_write(2, buf_hdr);
    console_write(2, " inverted=");
    console_line(2, best.inverted_header ? "1" : "0");

    // Also report approximate corners for cross-checking with visual inspection.
    double angle_rad = best.angle_degrees * (3.14159265358979323846 / 180.0);
    double c = cos(angle_rad);
    double s = sin(angle_rad);
    double vx_x = best.pitch_pixels * c;
    double vx_y = best.pitch_pixels * s;
    double vy_x = -best.pitch_pixels * s;
    double vy_y = best.pitch_pixels * c;
    double half = ((double)TILE_SIDE - 1.0) * 0.5;
    auto corner = [&](double sx, double sy, u32& out_x, u32& out_y) {
        double x = best.center_x + vx_x * sx + vy_x * sy;
        double y = best.center_y + vx_y * sx + vy_y * sy;
        x = clamp_double(x, 0.0, (double)(width_pixels - 1u));
        y = clamp_double(y, 0.0, (double)(height_pixels - 1u));
        out_x = (u32)floor(x + 0.5);
        out_y = (u32)floor(y + 0.5);
    };
    u32 tl_x = 0u, tl_y = 0u, tr_x = 0u, tr_y = 0u, bl_x = 0u, bl_y = 0u, br_x = 0u, br_y = 0u;
    corner(-half, -half, tl_x, tl_y);
    corner(half, -half, tr_x, tr_y);
    corner(-half, half, bl_x, bl_y);
    corner(half, half, br_x, br_y);
    char bufx[32], bufy[32];
    console_write(2, "debug tile probe: corners TL=");
    u64_to_ascii((u64)tl_x, bufx, sizeof(bufx));
    u64_to_ascii((u64)tl_y, bufy, sizeof(bufy));
    console_write(2, bufx);
    console_write(2, ",");
    console_write(2, bufy);
    console_write(2, " TR=");
    u64_to_ascii((u64)tr_x, bufx, sizeof(bufx));
    u64_to_ascii((u64)tr_y, bufy, sizeof(bufy));
    console_write(2, bufx);
    console_write(2, ",");
    console_write(2, bufy);
    console_write(2, " BL=");
    u64_to_ascii((u64)bl_x, bufx, sizeof(bufx));
    u64_to_ascii((u64)bl_y, bufy, sizeof(bufy));
    console_write(2, bufx);
    console_write(2, ",");
    console_write(2, bufy);
    console_write(2, " BR=");
    u64_to_ascii((u64)br_x, bufx, sizeof(bufx));
    u64_to_ascii((u64)br_y, bufy, sizeof(bufy));
    console_write(2, bufx);
    console_write(2, ",");
    console_line(2, bufy);
}

struct GlyphPattern {
    char symbol;
    const char* rows[FOOTER_BASE_GLYPH_HEIGHT];
};

#define FOOTER_GLYPH_BLANK_ROW "00000"
#define FOOTER_GLYPH_SIMPLE(symbol, r0, r1, r2, r3, r4, r5, r6) \
    {symbol, {r0, r1, r2, r3, r4, r5, r6, FOOTER_GLYPH_BLANK_ROW}}
#define FOOTER_GLYPH_CUSTOM(symbol, r0, r1, r2, r3, r4, r5, r6, r7) \
    {symbol, {r0, r1, r2, r3, r4, r5, r6, r7}}

static const GlyphPattern FOOTER_GLYPHS[] = {
    FOOTER_GLYPH_SIMPLE(' ', "00000", "00000", "00000", "00000", "00000", "00000", "00000"),
    FOOTER_GLYPH_SIMPLE('!', "00100", "00100", "00100", "00100", "00100", "00000", "00100"),
    FOOTER_GLYPH_SIMPLE('"', "01010", "01010", "00000", "00000", "00000", "00000", "00000"),
    FOOTER_GLYPH_SIMPLE('#', "01010", "01010", "11111", "01010", "11111", "01010", "01010"),
    FOOTER_GLYPH_SIMPLE('$', "00100", "01111", "10100", "01110", "00101", "11110", "00100"),
    FOOTER_GLYPH_SIMPLE('%', "11001", "11001", "00010", "00100", "01000", "10011", "10011"),
    FOOTER_GLYPH_SIMPLE('&', "01100", "10010", "10100", "01000", "10101", "10010", "01101"),
    FOOTER_GLYPH_SIMPLE('\'', "00100", "00100", "00000", "00000", "00000", "00000", "00000"),
    FOOTER_GLYPH_SIMPLE('(', "00010", "00100", "01000", "01000", "01000", "00100", "00010"),
    FOOTER_GLYPH_SIMPLE(')', "01000", "00100", "00010", "00010", "00010", "00100", "01000"),
    FOOTER_GLYPH_SIMPLE('*', "00000", "00100", "10101", "01110", "10101", "00100", "00000"),
    FOOTER_GLYPH_SIMPLE('+', "00000", "00100", "00100", "11111", "00100", "00100", "00000"),
    FOOTER_GLYPH_SIMPLE(',', "00000", "00000", "00000", "00000", "00100", "00100", "01000"),
    FOOTER_GLYPH_SIMPLE('-', "00000", "00000", "11111", "00000", "00000", "00000", "00000"),
    FOOTER_GLYPH_SIMPLE('.', "00000", "00000", "00000", "00000", "00000", "00100", "00000"),
    FOOTER_GLYPH_SIMPLE('/', "00001", "00010", "00100", "01000", "10000", "00000", "00000"),
    FOOTER_GLYPH_SIMPLE('0', "01110", "10001", "11001", "10101", "10011", "10001", "01110"),
    FOOTER_GLYPH_SIMPLE('1', "00100", "01100", "00100", "00100", "00100", "00100", "01110"),
    FOOTER_GLYPH_SIMPLE('2', "01110", "10001", "00001", "00010", "00100", "01000", "11111"),
    FOOTER_GLYPH_SIMPLE('3', "01110", "10001", "00001", "00110", "00001", "10001", "01110"),
    FOOTER_GLYPH_SIMPLE('4', "00010", "00110", "01010", "10010", "11111", "00010", "00010"),
    FOOTER_GLYPH_SIMPLE('5', "11111", "10000", "11110", "00001", "00001", "10001", "01110"),
    FOOTER_GLYPH_SIMPLE('6', "01110", "10000", "11110", "10001", "10001", "10001", "01110"),
    FOOTER_GLYPH_SIMPLE('7', "11111", "00001", "00010", "00100", "01000", "01000", "01000"),
    FOOTER_GLYPH_SIMPLE('8', "01110", "10001", "10001", "01110", "10001", "10001", "01110"),
    FOOTER_GLYPH_SIMPLE('9', "01110", "10001", "10001", "01111", "00001", "00001", "01110"),
    FOOTER_GLYPH_SIMPLE(':', "00000", "00100", "00000", "00000", "00100", "00000", "00000"),
    FOOTER_GLYPH_SIMPLE(';', "00000", "00100", "00000", "00000", "00100", "00100", "01000"),
    FOOTER_GLYPH_SIMPLE('<', "00010", "00100", "01000", "10000", "01000", "00100", "00010"),
    FOOTER_GLYPH_SIMPLE('=', "00000", "11111", "00000", "11111", "00000", "00000", "00000"),
    FOOTER_GLYPH_SIMPLE('>', "01000", "00100", "00010", "00001", "00010", "00100", "01000"),
    FOOTER_GLYPH_SIMPLE('?', "01110", "10001", "00010", "00100", "00100", "00000", "00100"),
    FOOTER_GLYPH_SIMPLE('@', "01110", "10001", "10111", "10101", "10111", "10000", "01110"),
    FOOTER_GLYPH_SIMPLE('[', "01110", "01000", "01000", "01000", "01000", "01000", "01110"),
    FOOTER_GLYPH_SIMPLE('\\', "10000", "01000", "00100", "00010", "00001", "00000", "00000"),
    FOOTER_GLYPH_SIMPLE(']', "01110", "00010", "00010", "00010", "00010", "00010", "01110"),
    FOOTER_GLYPH_SIMPLE('^', "00100", "01010", "10001", "00000", "00000", "00000", "00000"),
    FOOTER_GLYPH_SIMPLE('_', "00000", "00000", "00000", "00000", "00000", "11111", "00000"),
    FOOTER_GLYPH_SIMPLE('`', "00100", "00010", "00000", "00000", "00000", "00000", "00000"),
    FOOTER_GLYPH_SIMPLE('{', "00011", "00100", "00100", "01000", "00100", "00100", "00011"),
    FOOTER_GLYPH_SIMPLE('|', "00100", "00100", "00100", "00100", "00100", "00100", "00100"),
    FOOTER_GLYPH_SIMPLE('}', "11000", "00100", "00100", "00010", "00100", "00100", "11000"),
    FOOTER_GLYPH_SIMPLE('~', "00000", "00000", "01001", "10110", "00000", "00000", "00000"),
    FOOTER_GLYPH_SIMPLE('A', "01110", "10001", "10001", "11111", "10001", "10001", "10001"),
    FOOTER_GLYPH_SIMPLE('B', "11110", "10001", "10001", "11110", "10001", "10001", "11110"),
    FOOTER_GLYPH_SIMPLE('C', "01110", "10001", "10000", "10000", "10000", "10001", "01110"),
    FOOTER_GLYPH_SIMPLE('D', "11110", "10001", "10001", "10001", "10001", "10001", "11110"),
    FOOTER_GLYPH_SIMPLE('E', "11111", "10000", "10000", "11110", "10000", "10000", "11111"),
    FOOTER_GLYPH_SIMPLE('F', "11111", "10000", "10000", "11110", "10000", "10000", "10000"),
    FOOTER_GLYPH_SIMPLE('G', "01110", "10001", "10000", "10000", "10011", "10001", "01110"),
    FOOTER_GLYPH_SIMPLE('H', "10001", "10001", "10001", "11111", "10001", "10001", "10001"),
    FOOTER_GLYPH_SIMPLE('I', "01110", "00100", "00100", "00100", "00100", "00100", "01110"),
    FOOTER_GLYPH_SIMPLE('J', "00111", "00010", "00010", "00010", "10010", "10010", "01100"),
    FOOTER_GLYPH_SIMPLE('K', "10001", "10010", "10100", "11000", "10100", "10010", "10001"),
    FOOTER_GLYPH_SIMPLE('L', "10000", "10000", "10000", "10000", "10000", "10000", "11111"),
    FOOTER_GLYPH_SIMPLE('M', "10001", "11011", "10101", "10101", "10001", "10001", "10001"),
    FOOTER_GLYPH_SIMPLE('N', "10001", "11001", "10101", "10011", "10001", "10001", "10001"),
    FOOTER_GLYPH_SIMPLE('O', "01110", "10001", "10001", "10001", "10001", "10001", "01110"),
    FOOTER_GLYPH_SIMPLE('P', "11110", "10001", "10001", "11110", "10000", "10000", "10000"),
    FOOTER_GLYPH_SIMPLE('Q', "01110", "10001", "10001", "10001", "10101", "10010", "01101"),
    FOOTER_GLYPH_SIMPLE('R', "11110", "10001", "10001", "11110", "10100", "10010", "10001"),
    FOOTER_GLYPH_SIMPLE('S', "01110", "10001", "10000", "01110", "00001", "10001", "01110"),
    FOOTER_GLYPH_SIMPLE('T', "11111", "00100", "00100", "00100", "00100", "00100", "00100"),
    FOOTER_GLYPH_SIMPLE('U', "10001", "10001", "10001", "10001", "10001", "10001", "01110"),
    FOOTER_GLYPH_SIMPLE('V', "10001", "10001", "10001", "10001", "10001", "01010", "00100"),
    FOOTER_GLYPH_SIMPLE('W', "10001", "10001", "10001", "10101", "10101", "10101", "01010"),
    FOOTER_GLYPH_SIMPLE('X', "10001", "10001", "01010", "00100", "01010", "10001", "10001"),
    FOOTER_GLYPH_SIMPLE('Y', "10001", "10001", "01010", "00100", "00100", "00100", "00100"),
    FOOTER_GLYPH_SIMPLE('Z', "11111", "00001", "00010", "00100", "01000", "10000", "11111"),
    FOOTER_GLYPH_SIMPLE('a', "00000", "00000", "01110", "00001", "01111", "10001", "01111"),
    FOOTER_GLYPH_SIMPLE('b', "10000", "10000", "11110", "10001", "10001", "10001", "11110"),
    FOOTER_GLYPH_SIMPLE('c', "00000", "00000", "01110", "10001", "10000", "10001", "01110"),
    FOOTER_GLYPH_SIMPLE('d', "00001", "00001", "01111", "10001", "10001", "10001", "01111"),
    FOOTER_GLYPH_SIMPLE('e', "00000", "00000", "01110", "10001", "11111", "10000", "01110"),
    FOOTER_GLYPH_SIMPLE('f', "00110", "01001", "01000", "11110", "01000", "01000", "01000"),
    FOOTER_GLYPH_CUSTOM('g', "00000", "01110", "10001", "10001", "01111", "00001", "01110", "00000"),
    FOOTER_GLYPH_SIMPLE('h', "10000", "10000", "11110", "10001", "10001", "10001", "10001"),
    FOOTER_GLYPH_SIMPLE('i', "00100", "00000", "01100", "00100", "00100", "00100", "01110"),
    FOOTER_GLYPH_CUSTOM('j', "00010", "00000", "00110", "00010", "00010", "00010", "01100", "00000"),
    FOOTER_GLYPH_SIMPLE('k', "10000", "10000", "10010", "10100", "11000", "10100", "10010"),
    FOOTER_GLYPH_SIMPLE('l', "01100", "00100", "00100", "00100", "00100", "00100", "01110"),
    FOOTER_GLYPH_SIMPLE('m', "00000", "00000", "11010", "10101", "10101", "10101", "10101"),
    FOOTER_GLYPH_SIMPLE('n', "00000", "00000", "11110", "10001", "10001", "10001", "10001"),
    FOOTER_GLYPH_SIMPLE('o', "00000", "00000", "01110", "10001", "10001", "10001", "01110"),
    FOOTER_GLYPH_CUSTOM('p', "00000", "00000", "11110", "10001", "10001", "11110", "10000", "10000"),
    FOOTER_GLYPH_CUSTOM('q', "00000", "00000", "01110", "10001", "10001", "01111", "00001", "00001"),
    FOOTER_GLYPH_SIMPLE('r', "00000", "00000", "10110", "11001", "10000", "10000", "10000"),
    FOOTER_GLYPH_SIMPLE('s', "00000", "00000", "01110", "10000", "01110", "00001", "11110"),
    FOOTER_GLYPH_SIMPLE('t', "01000", "01000", "11110", "01000", "01000", "01001", "00110"),
    FOOTER_GLYPH_SIMPLE('u', "00000", "00000", "10001", "10001", "10001", "10011", "01101"),
    FOOTER_GLYPH_SIMPLE('v', "00000", "00000", "10001", "10001", "10001", "01010", "00100"),
    FOOTER_GLYPH_SIMPLE('w', "00000", "00000", "10001", "10001", "10101", "11011", "10001"),
    FOOTER_GLYPH_SIMPLE('x', "00000", "00000", "10001", "01010", "00100", "01010", "10001"),
    FOOTER_GLYPH_CUSTOM('y', "00000", "00000", "10001", "10001", "01010", "00100", "00100", "01000")
};

#undef FOOTER_GLYPH_CUSTOM
#undef FOOTER_GLYPH_SIMPLE
#undef FOOTER_GLYPH_BLANK_ROW

static const usize FOOTER_GLYPH_COUNT = (usize)(sizeof(FOOTER_GLYPHS) / sizeof(FOOTER_GLYPHS[0]));

static const GlyphPattern* footer_lookup_glyph(char c) {
    for (usize i = 0u; i < FOOTER_GLYPH_COUNT; ++i) {
        if (FOOTER_GLYPHS[i].symbol == c) {
            return &FOOTER_GLYPHS[i];
        }
    }
    if (c >= 'a' && c <= 'z') {
        char upper = (char)(c - 'a' + 'A');
        for (usize i = 0u; i < FOOTER_GLYPH_COUNT; ++i) {
            if (FOOTER_GLYPHS[i].symbol == upper) {
                return &FOOTER_GLYPHS[i];
            }
        }
    }
    return 0;
}

static bool compute_footer_layout(u32 page_width_pixels,
                                  u32 page_height_pixels,
                                  const PageFooterConfig& footer,
                                  FooterLayout& layout) {
    if (page_width_pixels == 0u || page_height_pixels == 0u) {
        return false;
    }
    layout = FooterLayout();
    bool has_text = (footer.max_text_length > 0u);
    u32 text_height_pixels = 0u;
    if (has_text) {
        if (footer.font_size == 0u) {
            return false;
        }
        if (footer.font_size > 2048u) {
            return false;
        }
        if (footer.max_text_length > (USIZE_MAX_VALUE / FOOTER_BASE_GLYPH_WIDTH)) {
            return false;
        }
        u32 scale = footer.font_size;
        u64 glyph_width_pixels = (u64)FOOTER_BASE_GLYPH_WIDTH * (u64)scale;
        u64 glyph_height_pixels = (u64)FOOTER_BASE_GLYPH_HEIGHT * (u64)scale;
        u64 char_spacing_pixels = (u64)scale;
        u64 text_pixel_width = (u64)footer.max_text_length * glyph_width_pixels;
        if (footer.max_text_length > 1u) {
            text_pixel_width += (u64)(footer.max_text_length - 1u) * char_spacing_pixels;
        }
        if (text_pixel_width > (u64)page_width_pixels) {
            return false;
        }
        u32 text_width_u32 = (u32)text_pixel_width;
        u32 text_left = 0u;
        if (page_width_pixels > text_width_u32) {
            text_left = (page_width_pixels - text_width_u32) / 2u;
        }
        layout.has_text = true;
        layout.font_size = scale;
        layout.glyph_width_pixels = (u32)glyph_width_pixels;
        layout.glyph_height_pixels = (u32)glyph_height_pixels;
        layout.char_spacing_pixels = (u32)char_spacing_pixels;
        layout.text_left_column = text_left;
        layout.text_pixel_width = text_width_u32;
        text_height_pixels = (u32)glyph_height_pixels;
    } else {
        layout.has_text = false;
    }
    // Footer barcode has been removed; disable all stripe fields.
    layout.stripe_module_pitch = 0u;
    layout.stripe_rows = 0u;
    layout.stripe_gap_pixels = 0u;
    layout.stripe_height_pixels = 0u;
    layout.stripe_data_bits = 0u;
    layout.stripe_quiet_modules = 0u;
    layout.stripe_sentinel_modules = 0u;
    layout.stripe_module_count = 0u;
    layout.stripe_pixel_width = 0u;

    u64 footer_height = 0u;
    if (has_text) {
        footer_height = text_height_pixels;
    }
    if (footer_height >= page_height_pixels) {
        return false;
    }
    layout.footer_height_pixels = (u32)footer_height;
    layout.data_height_pixels = page_height_pixels - layout.footer_height_pixels;
    if (layout.data_height_pixels == 0u) {
        return false;
    }
    layout.stripe_top_row = layout.data_height_pixels;
    if (layout.has_text) {
        layout.text_top_row = layout.data_height_pixels;
        if ((u64)layout.text_top_row + (u64)layout.glyph_height_pixels > page_height_pixels) {
            return false;
        }
    } else {
        layout.text_top_row = 0u;
    }
    return true;
}

static bool footer_is_text_pixel(const char* text,
                                 usize text_length,
                                 const FooterLayout& layout,
                                 u32 column,
                                 u32 row) {
    if (!text || text_length == 0u || !layout.has_text) {
        return false;
    }
    if (layout.font_size == 0u) {
        return false;
    }
    if (row < layout.text_top_row || row >= (layout.text_top_row + layout.glyph_height_pixels)) {
        return false;
    }
    if (column < layout.text_left_column || column >= (layout.text_left_column + layout.text_pixel_width)) {
        return false;
    }
    u32 char_span = layout.glyph_width_pixels + layout.char_spacing_pixels;
    if (char_span == 0u) {
        return false;
    }
    u32 local_x = column - layout.text_left_column;
    u32 glyph_index = local_x / char_span;
    if (glyph_index >= text_length) {
        return false;
    }
    u32 within_char = local_x - glyph_index * char_span;
    if (within_char >= layout.glyph_width_pixels) {
        return false;
    }
    u32 local_y = row - layout.text_top_row;
    u32 glyph_x = within_char / layout.font_size;
    u32 glyph_y = local_y / layout.font_size;
    if (glyph_x >= FOOTER_BASE_GLYPH_WIDTH || glyph_y >= FOOTER_BASE_GLYPH_HEIGHT) {
        return false;
    }
    const GlyphPattern* glyph = footer_lookup_glyph(text[glyph_index]);
    if (!glyph) {
        return false;
    }
    const char* row_pattern = glyph->rows[glyph_y];
    if (!row_pattern) {
        return false;
    }
    char bit = row_pattern[glyph_x];
    return (bit == '1');
}

static u8 color_mode_samples_per_pixel(u8 mode) {
    if (mode >= 1u && mode <= 3u) {
        return 1u;
    }
    return 0u;
}

static const PaletteColor PALETTE_GRAY[2] = {
    {0u, 0u, 0u},     // black
    {255u, 255u, 255u} // white
};

static const PaletteColor PALETTE_CMYW[4] = {
    {255u, 255u, 255u}, // white
    {0u, 255u, 255u},   // cyan
    {255u, 0u, 255u},   // magenta
    {255u, 255u, 0u}    // yellow
};

static const PaletteColor PALETTE_RGB_CMY_WB[8] = {
    {255u, 255u, 255u}, // white
    {0u, 0u, 0u},       // black
    {255u, 0u, 0u},     // red
    {0u, 255u, 0u},     // green
    {0u, 0u, 255u},     // blue
    {0u, 255u, 255u},   // cyan
    {255u, 0u, 255u},   // magenta
    {255u, 255u, 0u}    // yellow
};

static bool palette_for_mode(u8 mode, const PaletteColor*& colors, u32& count) {
    if (mode == 1u) {
        colors = PALETTE_GRAY;
        count = (u32)(sizeof(PALETTE_GRAY) / sizeof(PALETTE_GRAY[0]));
        return true;
    }
    if (mode == 2u) {
        colors = PALETTE_CMYW;
        count = (u32)(sizeof(PALETTE_CMYW) / sizeof(PALETTE_CMYW[0]));
        return true;
    }
    if (mode == 3u) {
        colors = PALETTE_RGB_CMY_WB;
        count = (u32)(sizeof(PALETTE_RGB_CMY_WB) / sizeof(PALETTE_RGB_CMY_WB[0]));
        return true;
    }
    colors = 0;
    count = 0u;
    return false;
}

enum NamedPaletteColorId {
    NAMED_COLOR_WHITE = 0u,
    NAMED_COLOR_CYAN = 1u,
    NAMED_COLOR_MAGENTA = 2u,
    NAMED_COLOR_YELLOW = 3u,
    NAMED_COLOR_BLACK = 4u,
    NAMED_COLOR_INVALID = 0xFFu
};

static const char* NAMED_COLOR_LABELS[] = {
    "White",
    "Cyan",
    "Magenta",
    "Yellow",
    "Black"
};

static const PaletteColor NAMED_COLOR_VALUES[] = {
    {255u, 255u, 255u},
    {0u, 255u, 255u},
    {255u, 0u, 255u},
    {255u, 255u, 0u},
    {0u, 0u, 0u}
};

static bool decode_hex_palette_color(const char* token,
                                     usize length,
                                     PaletteColor& color) {
    if (!token || length == 0u) {
        return false;
    }
    const char* cursor = token;
    if (length == 7u && cursor[0] == '#') {
        ++cursor;
        length = 6u;
    } else if (length != 6u) {
        return false;
    }
    u8 components[3];
    for (u32 i = 0u; i < 3u; ++i) {
        usize pair_index = i * 2u;
        u8 high = 0u;
        u8 low = 0u;
        if (!ascii_hex_value(cursor[pair_index], high) ||
            !ascii_hex_value(cursor[pair_index + 1u], low)) {
            return false;
        }
        components[i] = (u8)((high << 4u) | low);
    }
    color.r = components[0];
    color.g = components[1];
    color.b = components[2];
    return true;
}

static bool decode_named_palette_color(const char* token,
                                       usize length,
                                       u8& color_id,
                                       PaletteColor& color) {
    for (u8 idx = 0u; idx < (u8)(sizeof(NAMED_COLOR_LABELS) / sizeof(NAMED_COLOR_LABELS[0])); ++idx) {
        const char* label = NAMED_COLOR_LABELS[idx];
        if (ascii_equals_token_ignore_case(token, length, label)) {
            color_id = idx;
            color = NAMED_COLOR_VALUES[idx];
            return true;
        }
    }
    if (decode_hex_palette_color(token, length, color)) {
        color_id = NAMED_COLOR_INVALID;
        return true;
    }
    color_id = NAMED_COLOR_INVALID;
    return false;
}

static bool image_mapping_set_palette_text(ImageMappingConfig& config,
                                           const char* text,
                                           usize length,
                                           const char* command_name) {
    const char* prefix = command_name ? command_name : "makocode";
    if (!text || length == 0u) {
        console_write(2, prefix);
        console_line(2, ": --palette requires a non-empty list of colors");
        return false;
    }
    if (length >= MAX_CUSTOM_PALETTE_TEXT) {
        console_write(2, prefix);
        console_line(2, ": --palette text is too long");
        return false;
    }
    for (usize i = 0u; i < length; ++i) {
        config.palette_text[i] = text[i];
    }
    config.palette_text[length] = '\0';
    config.palette_text_length = length;
    config.palette_set = true;
    config.custom_palette_valid = false;
    config.custom_palette_count = 0u;
    config.custom_palette_base = 0u;
    config.color_channels = CUSTOM_PALETTE_SYNTHETIC_COLOR_MODE;
    return true;
}

static bool image_mapping_build_custom_palette(ImageMappingConfig& config,
                                               const char* command_name) {
    if (!config.palette_set) {
        config.custom_palette_valid = false;
        config.custom_palette_count = 0u;
        config.custom_palette_base = 0u;
        return true;
    }
    if (config.custom_palette_valid) {
        if (config.custom_palette_count >= 2u) {
            config.custom_palette_base = config.custom_palette_count;
        }
        config.color_channels = CUSTOM_PALETTE_SYNTHETIC_COLOR_MODE;
        return true;
    }
    const char* prefix = command_name ? command_name : "makocode";
    if (config.palette_text_length == 0u) {
        console_write(2, prefix);
        console_line(2, ": --palette requires a non-empty list of colors");
        config.custom_palette_valid = false;
        config.custom_palette_count = 0u;
        config.custom_palette_base = 0u;
        return false;
    }
    config.custom_palette_valid = false;
    config.custom_palette_count = 0u;
    config.custom_palette_base = 0u;

    const char* text = config.palette_text;
    usize length = config.palette_text_length;
    u32 count = 0u;
    u8 token_ids[MAX_CUSTOM_PALETTE_COLORS];
    PaletteColor token_colors[MAX_CUSTOM_PALETTE_COLORS];
    usize cursor = 0u;
    while (cursor < length) {
        while (cursor < length) {
            char c = text[cursor];
            if (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == ',' || c == ';') {
                ++cursor;
                continue;
            }
            break;
        }
        if (cursor >= length) {
            break;
        }
        usize start = cursor;
        while (cursor < length) {
            char c = text[cursor];
            if (c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == ',' || c == ';') {
                break;
            }
            ++cursor;
        }
        usize token_length = cursor - start;
        if (token_length == 0u) {
            continue;
        }
        if (count >= MAX_CUSTOM_PALETTE_COLORS) {
            console_write(2, prefix);
            console_line(2, ": --palette supports at most 16 colors");
            return false;
        }
        PaletteColor decoded_color;
        u8 decoded_id = NAMED_COLOR_INVALID;
        if (!decode_named_palette_color(text + start, token_length, decoded_id, decoded_color)) {
            console_write(2, prefix);
            console_line(2, ": --palette contains an unsupported color name or hex code");
            return false;
        }
        token_colors[count] = decoded_color;
        token_ids[count] = decoded_id;
        ++count;
    }
    if (count < 2u) {
        console_write(2, prefix);
        console_line(2, ": --palette requires at least two colors");
        return false;
    }
    for (u32 i = 0u; i < count; ++i) {
        for (u32 j = i + 1u; j < count; ++j) {
            bool both_named = (token_ids[i] != NAMED_COLOR_INVALID) &&
                               (token_ids[j] != NAMED_COLOR_INVALID);
            if (both_named && token_ids[i] == token_ids[j]) {
                console_write(2, prefix);
                console_line(2, ": --palette cannot repeat colors");
                return false;
            }
            if (palette_colors_equal(token_colors[i], token_colors[j])) {
                console_write(2, prefix);
                console_line(2, ": --palette cannot repeat colors");
                return false;
            }
        }
    }
    for (u32 i = 0u; i < count; ++i) {
        config.custom_palette[i] = token_colors[i];
        config.custom_palette_ids[i] = token_ids[i];
    }
    config.custom_palette_count = count;
    config.custom_palette_base = count;
    config.custom_palette_valid = true;
    config.color_channels = CUSTOM_PALETTE_SYNTHETIC_COLOR_MODE;
    return true;
}

static bool mapping_has_custom_palette(const ImageMappingConfig& mapping) {
    return mapping.palette_set &&
           mapping.custom_palette_valid &&
           mapping.custom_palette_count >= 2u;
}

static u32 mapping_custom_palette_base(const ImageMappingConfig& mapping) {
    if (!mapping_has_custom_palette(mapping)) {
        return 0u;
    }
    u32 base = mapping.custom_palette_base;
    if (base < 2u) {
        base = mapping.custom_palette_count;
    }
    if (base > mapping.custom_palette_count) {
        base = mapping.custom_palette_count;
    }
    return base;
}

static usize divide_le_bytes_by_base(u8* data, usize length, u32 base, u32& remainder) {
    remainder = 0u;
    if (!data || length == 0u || base < 2u) {
        return 0u;
    }
    for (ssize_t index = (ssize_t)length - 1; index >= 0; --index) {
        u32 value = ((u32)remainder << 8u) | (u32)data[index];
        u32 quotient = value / base;
        remainder = value % base;
        data[index] = (u8)quotient;
    }
    while (length > 0u && data[length - 1u] == 0u) {
        --length;
    }
    return length;
}

static bool normalize_bits_output_size(makocode::ByteBuffer& bits_out, usize alloc_size) {
    if (alloc_size == 0u) {
        alloc_size = bits_out.size;
    }
    if (alloc_size == 0u) {
        alloc_size = 1u;
    }
    if (!bits_out.ensure(alloc_size)) {
        return false;
    }
    if (bits_out.size < alloc_size) {
        for (usize i = bits_out.size; i < alloc_size; ++i) {
            bits_out.data[i] = 0u;
        }
        bits_out.size = alloc_size;
    } else if (bits_out.size > alloc_size && alloc_size > 0u) {
        for (usize i = alloc_size; i < bits_out.size; ++i) {
            if (bits_out.data[i] != 0u) {
                return false;
            }
        }
        bits_out.size = alloc_size;
    }
    if (bits_out.size == 0u) {
        bits_out.size = 1u;
        bits_out.data[0] = 0u;
    }
    return true;
}

static bool bits_to_base_digits(makocode::ByteBuffer& bit_scratch,
                                u64 bit_count,
                                u32 base,
                                makocode::ByteBuffer& digits_out,
                                u64& digit_count_out) {
    digit_count_out = 0u;
    digits_out.release();
    if (base < 2u) {
        return false;
    }
    if (bit_count == 0u) {
        return true;
    }
    if (!bit_scratch.data) {
        return false;
    }
    usize byte_count = (usize)((bit_count + 7u) / 8u);
    if (bit_scratch.size < byte_count) {
        return false;
    }
    u64 used_bits_last_byte = bit_count - ((u64)(byte_count - 1u) * 8u);
    if (used_bits_last_byte > 0u && used_bits_last_byte < 8u) {
        u8 mask = (u8)((1u << used_bits_last_byte) - 1u);
        bit_scratch.data[byte_count - 1u] &= mask;
    }
    if (is_power_of_two_u32(base)) {
        u32 digit_bits = log2_u32(base);
        if (digit_bits == 0u) {
            if (!digits_out.ensure(1u)) {
                return false;
            }
            digits_out.data[0] = 0u;
            digits_out.size = 1u;
            digit_count_out = 1u;
            return true;
        }
        u64 effective_bits = bit_count;
        if (byte_count == 0u) {
            effective_bits = 0u;
        } else {
            ssize_t scan = (ssize_t)byte_count - 1;
            while (scan >= 0) {
                u8 value = bit_scratch.data[scan];
                if (value != 0u) {
                    u8 highest_bit = 7u;
                    while (highest_bit > 0u && ((value >> highest_bit) & 1u) == 0u) {
                        --highest_bit;
                    }
                    effective_bits = ((u64)scan * 8u) + (u64)highest_bit + 1u;
                    break;
                }
                if (scan == 0) {
                    effective_bits = 0u;
                    break;
                }
                --scan;
            }
            if (scan < 0) {
                effective_bits = 0u;
            }
        }
        if (effective_bits == 0u) {
            if (!digits_out.ensure(1u)) {
                return false;
            }
            digits_out.data[0] = 0u;
            digits_out.size = 1u;
            digit_count_out = 1u;
            return true;
        }
        u64 total_digits = (effective_bits + (u64)digit_bits - 1u) / (u64)digit_bits;
        if (total_digits == 0u) {
            if (!digits_out.ensure(1u)) {
                return false;
            }
            digits_out.data[0] = 0u;
            digits_out.size = 1u;
            digit_count_out = 1u;
            return true;
        }
        if (total_digits > (u64)USIZE_MAX_VALUE) {
            return false;
        }
        usize required = (usize)total_digits;
        if (!digits_out.ensure(required)) {
            return false;
        }
        digits_out.size = required;
        u64 bit_cursor = 0u;
        u64 bit_limit = effective_bits;
        for (usize digit_index = 0u; digit_index < required; ++digit_index) {
            u32 symbol = 0u;
            for (u32 local_bit = 0u; local_bit < digit_bits; ++local_bit) {
                u8 bit_value = 0u;
                if (bit_cursor < bit_limit) {
                    usize byte_index = (usize)(bit_cursor >> 3u);
                    if (byte_index < bit_scratch.size) {
                        u8 mask = (u8)(1u << (bit_cursor & 7u));
                        bit_value = (bit_scratch.data[byte_index] & mask) ? 1u : 0u;
                    }
                }
                symbol |= ((u32)bit_value) << local_bit;
                ++bit_cursor;
            }
            digits_out.data[digit_index] = (u8)symbol;
        }
        digit_count_out = total_digits;
        return true;
    }
    while (byte_count > 0u) {
        u32 remainder = 0u;
        byte_count = divide_le_bytes_by_base(bit_scratch.data, byte_count, base, remainder);
        if (!digits_out.ensure(digits_out.size + 1u)) {
            return false;
        }
        digits_out.data[digits_out.size++] = (u8)remainder;
    }
    if (digits_out.size == 0u) {
        if (!digits_out.ensure(1u)) {
            return false;
        }
        digits_out.data[0] = 0u;
        digits_out.size = 1u;
    }
    digit_count_out = (u64)digits_out.size;
    return true;
}

static bool base_digits_to_bits(const u8* digits,
                                u64 digit_count,
                                u32 base,
                                u64 bit_count_target,
                                makocode::ByteBuffer& bits_out) {
    bits_out.release();
    if (base < 2u) {
        return false;
    }
    if (is_power_of_two_u32(base)) {
        u32 digit_bits = log2_u32(base);
        u64 digit_capacity_bits = digit_count * (u64)digit_bits;
        if (digit_count && digit_bits && (digit_capacity_bits / digit_count) != (u64)digit_bits) {
            return false;
        }
        u64 total_bits = bit_count_target ? bit_count_target : digit_capacity_bits;
        if (digit_bits == 0u || total_bits == 0u) {
            if (!bits_out.ensure(1u)) {
                return false;
            }
            bits_out.data[0] = 0u;
            bits_out.size = 1u;
            return true;
        }
        u64 bytes_u64 = (total_bits + 7u) / 8u;
        if (bytes_u64 == 0u || bytes_u64 > (u64)USIZE_MAX_VALUE) {
            return false;
        }
        usize bytes_needed = (usize)bytes_u64;
        if (!bits_out.ensure(bytes_needed)) {
            return false;
        }
        for (usize i = 0u; i < bytes_needed; ++i) {
            bits_out.data[i] = 0u;
        }
        bits_out.size = bytes_needed;
        u64 bit_cursor = 0u;
        u64 bits_to_emit = digit_capacity_bits;
        if (bits_to_emit > total_bits) {
            bits_to_emit = total_bits;
        }
        for (u64 idx = 0u; idx < digit_count; ++idx) {
            u32 digit = digits ? (u32)digits[idx] : 0u;
            if (digit >= base) {
                return false;
            }
            if (bit_cursor >= bits_to_emit) {
                continue;
            }
            for (u32 local_bit = 0u; local_bit < digit_bits && bit_cursor < bits_to_emit; ++local_bit) {
                if ((digit >> local_bit) & 1u) {
                    usize byte_index = (usize)(bit_cursor >> 3u);
                    u8 mask = (u8)(1u << (bit_cursor & 7u));
                    bits_out.data[byte_index] = (u8)(bits_out.data[byte_index] | mask);
                }
                ++bit_cursor;
            }
        }
        if (bit_count_target == 0u && bit_cursor < total_bits) {
            return false;
        }
        if (bit_count_target == 0u) {
            usize used_bytes = (usize)((bit_cursor + 7u) / 8u);
            if (used_bytes == 0u) {
                used_bytes = 1u;
            }
            bits_out.size = used_bytes;
        }
        return true;
    }
    if (!bits_out.ensure(1u)) {
        return false;
    }
    bits_out.data[0] = 0u;
    bits_out.size = 1u;
    for (u64 idx = digit_count; idx > 0u; --idx) {
        u32 digit = digits ? (u32)digits[idx - 1u] : 0u;
        if (digit >= base) {
            return false;
        }
        u32 carry = digit;
        for (usize byte_index = 0u; byte_index < bits_out.size; ++byte_index) {
            u64 accum = (u64)bits_out.data[byte_index] * (u64)base + (u64)carry;
            bits_out.data[byte_index] = (u8)(accum & 0xFFu);
            carry = (u32)(accum >> 8u);
        }
        while (carry) {
            if (!bits_out.ensure(bits_out.size + 1u)) {
                return false;
            }
            bits_out.data[bits_out.size++] = (u8)(carry & 0xFFu);
            carry >>= 8u;
        }
    }
    u64 target_bytes_u64 = (bit_count_target + 7u) / 8u;
    usize target_bytes = (usize)target_bytes_u64;
    if (!normalize_bits_output_size(bits_out, target_bytes)) {
        return false;
    }
    if (bit_count_target > 0u) {
        usize required_bytes = target_bytes;
        if (required_bytes == 0u) {
            required_bytes = bits_out.size ? bits_out.size : 1u;
        }
        u32 bits_in_last_byte = (u32)(bit_count_target - ((u64)(required_bytes - 1u) * 8u));
        if (bits_in_last_byte > 0u && bits_in_last_byte < 8u) {
            u8 mask = (u8)((1u << bits_in_last_byte) - 1u);
            bits_out.data[required_bytes - 1u] &= mask;
        }
    }
    return true;
}

static bool copy_bits_segment(const u8* source_bits,
                              u64 source_bit_count,
                              u64 bit_offset,
                              u64 bits_to_copy,
                              makocode::ByteBuffer& dest_bits) {
    dest_bits.release();
    if (bits_to_copy == 0u) {
        return true;
    }
    if (!source_bits && source_bit_count) {
        return false;
    }
    usize bytes_needed = (usize)((bits_to_copy + 7u) / 8u);
    if (!dest_bits.ensure(bytes_needed)) {
        return false;
    }
    dest_bits.size = bytes_needed;
    for (usize i = 0u; i < bytes_needed; ++i) {
        dest_bits.data[i] = 0u;
    }
    for (u64 bit_index = 0u; bit_index < bits_to_copy; ++bit_index) {
        u64 global_bit = bit_offset + bit_index;
        if (global_bit >= source_bit_count) {
            continue;
        }
        usize byte_index = (usize)(global_bit >> 3u);
        u8 mask = (u8)(1u << (global_bit & 7u));
        bool bit_value = (source_bits[byte_index] & mask) != 0u;
        if (bit_value) {
            usize dest_byte = (usize)(bit_index >> 3u);
            u8 dest_mask = (u8)(1u << (bit_index & 7u));
            dest_bits.data[dest_byte] = (u8)(dest_bits.data[dest_byte] | dest_mask);
        }
    }
    return true;
}

static bool map_rgb_to_custom_symbol(const ImageMappingConfig& mapping,
                                     const u8* rgb,
                                     u32& symbol_out) {
    symbol_out = 0u;
    if (!mapping_has_custom_palette(mapping) || !rgb) {
        return false;
    }
    u64 best_score = (u64)USIZE_MAX_VALUE;
    u32 best_index = 0u;
    for (u32 i = 0u; i < mapping.custom_palette_count; ++i) {
        const PaletteColor& color = mapping.custom_palette[i];
        i64 dr = (i64)color.r - (i64)rgb[0];
        i64 dg = (i64)color.g - (i64)rgb[1];
        i64 db = (i64)color.b - (i64)rgb[2];
        u64 score = (u64)(dr * dr + dg * dg + db * db);
        if (i == 0u || score < best_score) {
            best_score = score;
            best_index = i;
            if (score == 0u) {
                break;
            }
        }
    }
    if (debug_logging_enabled() && best_score > 0u) {
        static u32 palette_log_budget = 32u;
        if (palette_log_budget) {
            --palette_log_budget;
            char index_buffer[32];
            char score_buffer[32];
            char sample_r[32];
            char sample_g[32];
            char sample_b[32];
            char palette_r[32];
            char palette_g[32];
            char palette_b[32];
            u64_to_ascii((u64)best_index, index_buffer, sizeof(index_buffer));
            u64_to_ascii(best_score, score_buffer, sizeof(score_buffer));
            u64_to_ascii((u64)rgb[0], sample_r, sizeof(sample_r));
            u64_to_ascii((u64)rgb[1], sample_g, sizeof(sample_g));
            u64_to_ascii((u64)rgb[2], sample_b, sizeof(sample_b));
            const PaletteColor& chosen = mapping.custom_palette[best_index];
            u64_to_ascii((u64)chosen.r, palette_r, sizeof(palette_r));
            u64_to_ascii((u64)chosen.g, palette_g, sizeof(palette_g));
            u64_to_ascii((u64)chosen.b, palette_b, sizeof(palette_b));
            console_write(2, "decode: approximated custom symbol ");
            console_line(2, index_buffer);
            console_write(2, "decode: sample rgb = ");
            console_write(2, sample_r);
            console_write(2, ", ");
            console_write(2, sample_g);
            console_write(2, ", ");
            console_line(2, sample_b);
            console_write(2, "decode: palette rgb = ");
            console_write(2, palette_r);
            console_write(2, ", ");
            console_write(2, palette_g);
            console_write(2, ", ");
            console_line(2, palette_b);
            console_write(2, "decode: squared distance = ");
            console_line(2, score_buffer);
        }
    }
    symbol_out = best_index;
    return true;
}

static u32 palette_color_luminance(const PaletteColor& color) {
    return (u32)color.r * 299u + (u32)color.g * 587u + (u32)color.b * 114u;
}

static void footer_select_colors(const ImageMappingConfig& mapping,
                                 u8* text_rgb,
                                 u8* background_rgb) {
    if (!text_rgb || !background_rgb) {
        return;
    }
    if (mapping.palette_set && mapping.custom_palette_valid && mapping.custom_palette_count >= 2u) {
        u32 darkest_index = 0u;
        u32 lightest_index = 0u;
        u32 darkest_luma = 0xFFFFFFFFu;
        u32 lightest_luma = 0u;
        for (u32 i = 0u; i < mapping.custom_palette_count; ++i) {
            const PaletteColor& candidate = mapping.custom_palette[i];
            u32 luma = palette_color_luminance(candidate);
            if (luma < darkest_luma) {
                darkest_luma = luma;
                darkest_index = i;
            }
            if (luma >= lightest_luma) {
                lightest_luma = luma;
                lightest_index = i;
            }
        }
        const PaletteColor& background = mapping.custom_palette[lightest_index];
        const PaletteColor& text = mapping.custom_palette[darkest_index];
        background_rgb[0] = background.r;
        background_rgb[1] = background.g;
        background_rgb[2] = background.b;
        text_rgb[0] = text.r;
        text_rgb[1] = text.g;
        text_rgb[2] = text.b;
        return;
    }
    background_rgb[0] = 255u;
    background_rgb[1] = 255u;
    background_rgb[2] = 255u;
    text_rgb[0] = 0u;
    text_rgb[1] = 0u;
    text_rgb[2] = 0u;
    u8 color_mode = mapping.color_channels;
    if (color_mode == 1u) {
        background_rgb[0] = PALETTE_GRAY[1].r;
        background_rgb[1] = PALETTE_GRAY[1].g;
        background_rgb[2] = PALETTE_GRAY[1].b;
        text_rgb[0] = PALETTE_GRAY[0].r;
        text_rgb[1] = PALETTE_GRAY[0].g;
        text_rgb[2] = PALETTE_GRAY[0].b;
        return;
    }
    if (color_mode == 2u) {
        background_rgb[0] = PALETTE_CMYW[0].r;
        background_rgb[1] = PALETTE_CMYW[0].g;
        background_rgb[2] = PALETTE_CMYW[0].b;
        text_rgb[0] = PALETTE_CMYW[1].r;
        text_rgb[1] = PALETTE_CMYW[1].g;
        text_rgb[2] = PALETTE_CMYW[1].b;
        return;
    }
    if (color_mode == 3u) {
        background_rgb[0] = PALETTE_RGB_CMY_WB[0].r;
        background_rgb[1] = PALETTE_RGB_CMY_WB[0].g;
        background_rgb[2] = PALETTE_RGB_CMY_WB[0].b;
        text_rgb[0] = PALETTE_RGB_CMY_WB[1].r;
        text_rgb[1] = PALETTE_RGB_CMY_WB[1].g;
        text_rgb[2] = PALETTE_RGB_CMY_WB[1].b;
        return;
    }
}

static u8 bits_per_sample(u8 mode) {
    if (mode == 1u) {
        return 1u;
    }
    if (mode == 2u) {
        return 2u;
    }
    if (mode == 3u) {
        return 3u;
    }
    return 0u;
}

static bool map_samples_to_rgb(u8 mode, const u32* samples, u8* rgb) {
    const PaletteColor* palette = 0;
    u32 palette_size = 0u;
    if (!palette_for_mode(mode, palette, palette_size)) {
        return false;
    }
    u8 samples_per_pixel = color_mode_samples_per_pixel(mode);
    if (samples_per_pixel != 1u) {
        return false;
    }
    u32 value = samples[0];
    if (mode == 1u) {
        if (value > 1u) {
            return false;
        }
        value ^= 1u;
    }
    if (value >= palette_size) {
        return false;
    }
    const PaletteColor& color = palette[value];
    rgb[0] = color.r;
    rgb[1] = color.g;
    rgb[2] = color.b;
    return true;
}

static bool map_rgb_to_samples(u8 mode, const u8* rgb, u32* samples) {
    const PaletteColor* palette = 0;
    u32 palette_size = 0u;
    if (!palette_for_mode(mode, palette, palette_size)) {
        return false;
    }
    u8 samples_per_pixel = color_mode_samples_per_pixel(mode);
    if (samples_per_pixel != 1u) {
        return false;
    }
    if (!samples) {
        return false;
    }
    u32 best_index = 0u;
    u64 best_score = (u64)USIZE_MAX_VALUE;
    for (u32 palette_index = 0u; palette_index < palette_size; ++palette_index) {
        const PaletteColor& candidate = palette[palette_index];
        i64 dr = (i64)candidate.r - (i64)rgb[0];
        i64 dg = (i64)candidate.g - (i64)rgb[1];
        i64 db = (i64)candidate.b - (i64)rgb[2];
        u64 score = (u64)(dr * dr + dg * dg + db * db);
        if (palette_index == 0u || score < best_score) {
            best_score = score;
            best_index = palette_index;
        }
    }
    if (mode == 1u) {
        if (best_index > 1u) {
            return false;
        }
        samples[0] = best_index ^ 1u;
        return true;
    }
    samples[0] = best_index;
    return true;
}

static double mapping_bits_per_data_pixel(const ImageMappingConfig& mapping) {
    if (mapping_has_custom_palette(mapping)) {
        u32 base = mapping_custom_palette_base(mapping);
        if (base < 2u) {
            return 0.0;
        }
        double base_log = log((double)base);
        double log_two = log(2.0);
        if (log_two == 0.0) {
            return 0.0;
        }
        return base_log / log_two;
    }
    u8 sample_bits = bits_per_sample(mapping.color_channels);
    u8 samples_per_pixel = color_mode_samples_per_pixel(mapping.color_channels);
    if (sample_bits == 0u || samples_per_pixel == 0u) {
        return 0.0;
    }
    return (double)sample_bits * (double)samples_per_pixel;
}

static u8 rotate_left_u8(u8 value, u8 amount) {
    amount &= 7u;
    if (!amount) {
        return value;
    }
    return (u8)((u8)(value << amount) | (u8)(value >> (8u - amount)));
}

static u8 rotate_right_u8(u8 value, u8 amount) {
    amount &= 7u;
    if (!amount) {
        return value;
    }
    return (u8)((u8)(value >> amount) | (u8)(value << (8u - amount)));
}

static bool write_all_fd(int fd, const u8* data, usize length) {
    if (length == 0u) {
        return true;
    }
    if (!data) {
        return false;
    }
    usize written = 0u;
    while (written < length) {
        unsigned long slice = (unsigned long)(length - written);
        int result = write(fd, data + written, slice);
        if (result <= 0) {
            return false;
        }
        written += (usize)result;
    }
    return true;
}

static bool write_bytes_to_file(const char* path, const u8* data, usize length) {
    if (!path) {
        return false;
    }
    int fd = creat(path, 0644);
    if (fd < 0) {
        return false;
    }
    bool ok = true;
    if (length) {
        ok = write_all_fd(fd, data, length);
    }
    close(fd);
    return ok;
}

static bool write_ppm_with_fiducials_to_file(const char* path, const makocode::ByteBuffer& buffer);

static bool buffer_contains_fiducial_metadata(const makocode::ByteBuffer& buffer) {
    if (!buffer.data || buffer.size == 0u) {
        return false;
    }
    static const char fiducial_prefix[] = "MAKOCODE_FIDUCIAL";
    const usize prefix_length = (usize)sizeof(fiducial_prefix) - 1u;
    if (buffer.size < prefix_length) {
        return false;
    }
    for (usize i = 0u; i <= buffer.size - prefix_length; ++i) {
        bool match = true;
        for (usize j = 0u; j < prefix_length; ++j) {
            if (buffer.data[i + j] != (u8)fiducial_prefix[j]) {
                match = false;
                break;
            }
        }
        if (match) {
            return true;
        }
    }
    return false;
}

static bool path_contains_substring(const char* path, const char* needle) {
    if (!path || !needle || !needle[0]) {
        return false;
    }
    for (const char* cursor = path; *cursor; ++cursor) {
        const char* a = cursor;
        const char* b = needle;
        while (*a && *b && (*a == *b)) {
            ++a;
            ++b;
        }
        if (*b == '\0') {
            return true;
        }
    }
    return false;
}

static bool should_embed_fiducials_for_path(const char* path, const makocode::ByteBuffer& buffer) {
    if (!path) {
        return false;
    }
    usize path_length = ascii_length(path);
    if (path_length < 4u) {
        return false;
    }
    const char* suffix = path + (path_length - 4u);
    if (suffix[0] != '.' || suffix[1] != 'p' || suffix[2] != 'p' || suffix[3] != 'm') {
        return false;
    }
    if (!path_contains_substring(path, "_encoded")) {
        return false;
    }
    if (buffer_contains_fiducial_metadata(buffer)) {
        return false;
    }
    return true;
}

static bool write_buffer_to_file(const char* path, const makocode::ByteBuffer& buffer) {
    if (should_embed_fiducials_for_path(path, buffer)) {
        return write_ppm_with_fiducials_to_file(path, buffer);
    }
    return write_bytes_to_file(path, buffer.data, buffer.size);
}


static const u32 MAX_FIDUCIAL_SUBGRID_ENTRIES = 1024u;

struct PpmParserState {
    const u8* data;
    usize size;
    usize cursor;
    bool has_bytes;
    u64 bytes_value;
    bool has_bits;
    u64 bits_value;
    bool has_ecc_flag;
    u64 ecc_flag_value;
    bool has_ecc_block_data;
    u64 ecc_block_data_value;
    bool has_ecc_parity;
    u64 ecc_parity_value;
    bool has_ecc_block_count;
    u64 ecc_block_count_value;
    bool has_ecc_original_bytes;
    u64 ecc_original_bytes_value;
    bool has_palette_text;
    char palette_text[MAX_CUSTOM_PALETTE_TEXT];
    usize palette_text_length;
    bool has_palette_base;
    u64 palette_base_value;
    bool has_page_symbols;
    u64 page_symbols_value;
    bool has_page_width_pixels;
    u64 page_width_pixels_value;
    bool has_page_height_pixels;
    u64 page_height_pixels_value;
    bool has_page_index;
    u64 page_index_value;
    bool has_page_count;
    u64 page_count_value;
    bool has_page_bits;
    u64 page_bits_value;
    bool has_footer_rows;
    u64 footer_rows_value;
    bool has_footer_stripe;
    FooterStripe::Values footer_stripe_values;
    bool has_rotation_degrees;
    double rotation_degrees_value;
    bool has_rotation_width;
    u64 rotation_width_value;
    bool has_rotation_height;
    u64 rotation_height_value;
    bool has_rotation_margin;
    double rotation_margin_value;
    bool has_affine_transform;
    AffineTransform affine_transform;
    bool has_skew_src_width;
    u64 skew_src_width_value;
    bool has_skew_src_height;
    u64 skew_src_height_value;
    bool has_skew_margin_x;
    double skew_margin_x_value;
    bool has_skew_x_pixels;
    bool has_skew_y_pixels;
    double skew_x_pixels_value;
    double skew_y_pixels_value;
    bool has_skew_bottom_x;
    double skew_bottom_x_value;
    bool has_fiducial_size;
    u64 fiducial_size_value;
    bool has_fiducial_columns;
    u64 fiducial_columns_value;
    bool has_fiducial_rows;
    u64 fiducial_rows_value;
    bool has_fiducial_margin;
    u64 fiducial_margin_value;
    bool has_fiducial_col_offsets;
    u32 fiducial_col_offset_count;
    u64 fiducial_col_offsets[MAX_FIDUCIAL_SUBGRID_ENTRIES];
    bool has_fiducial_row_offsets;
    u32 fiducial_row_offset_count;
    u64 fiducial_row_offsets[MAX_FIDUCIAL_SUBGRID_ENTRIES];
    bool has_tile_pitch;
    double tile_pitch_value;

    PpmParserState()
        : data(0),
          size(0u),
          cursor(0u),
          has_bytes(false),
          bytes_value(0u),
          has_bits(false),
          bits_value(0u),
          has_ecc_flag(false),
          ecc_flag_value(0u),
          has_ecc_block_data(false),
          ecc_block_data_value(0u),
          has_ecc_parity(false),
          ecc_parity_value(0u),
          has_ecc_block_count(false),
          ecc_block_count_value(0u),
          has_ecc_original_bytes(false),
          ecc_original_bytes_value(0u),
          has_palette_text(false),
          palette_text_length(0u),
          has_palette_base(false),
          palette_base_value(0u),
          has_page_symbols(false),
          page_symbols_value(0u),
          has_page_width_pixels(false),
          page_width_pixels_value(0u),
          has_page_height_pixels(false),
          page_height_pixels_value(0u),
          has_page_index(false),
          page_index_value(0u),
          has_page_count(false),
          page_count_value(0u),
          has_page_bits(false),
          page_bits_value(0u),
          has_footer_rows(false),
          footer_rows_value(0u),
          has_footer_stripe(false),
          footer_stripe_values(),
          has_rotation_degrees(false),
          rotation_degrees_value(0.0),
          has_rotation_width(false),
          rotation_width_value(0u),
          has_rotation_height(false),
          rotation_height_value(0u),
          has_rotation_margin(false),
          rotation_margin_value(0.0),
          has_affine_transform(false),
          affine_transform(),
          has_skew_src_width(false),
          skew_src_width_value(0u),
          has_skew_src_height(false),
          skew_src_height_value(0u),
          has_skew_margin_x(false),
          skew_margin_x_value(0.0),
          has_skew_x_pixels(false),
          has_skew_y_pixels(false),
          skew_x_pixels_value(0.0),
          skew_y_pixels_value(0.0),
          has_skew_bottom_x(false),
          skew_bottom_x_value(0.0),
          has_fiducial_size(false),
          fiducial_size_value(0u),
          has_fiducial_columns(false),
          fiducial_columns_value(0u),
          has_fiducial_rows(false),
          fiducial_rows_value(0u),
          has_fiducial_margin(false),
          fiducial_margin_value(0u),
          has_fiducial_col_offsets(false),
          fiducial_col_offset_count(0u),
          has_fiducial_row_offsets(false),
          fiducial_row_offset_count(0u) {
        has_tile_pitch = false;
        tile_pitch_value = 0.0;
        palette_text[0] = '\0';
        for (u32 i = 0u; i < MAX_FIDUCIAL_SUBGRID_ENTRIES; ++i) {
            fiducial_col_offsets[i] = 0u;
            fiducial_row_offsets[i] = 0u;
        }
    }
};

static bool ppm_append_extended_metadata(const PpmParserState& state,
                                         makocode::ByteBuffer& output);

static void apply_footer_stripe_metadata(PpmParserState& state,
                                         const FooterStripe::Values& values);

static void apply_metadata_tile_metadata(PpmParserState& state,
                                         const MetadataTile::Values& values,
                                         const makocode::ByteBuffer& palette_text);

static void ppm_consume_comment(PpmParserState& state, usize start, usize length) {
    const char* comment = (const char*)(state.data + start);
    usize index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    const char bytes_tag[] = "MAKOCODE_BYTES";
    const char bits_tag[] = "MAKOCODE_BITS";
    const char ecc_block_tag[] = "MAKOCODE_ECC_BLOCK_DATA";
    const char ecc_original_tag[] = "MAKOCODE_ECC_ORIGINAL_BYTES";
    const char palette_tag[] = "MAKOCODE_PALETTE";
    const char palette_base_tag[] = "MAKOCODE_PALETTE_BASE";
    const char page_symbols_tag[] = "MAKOCODE_PAGE_SYMBOLS";
    const char fiducial_size_tag[] = "MAKOCODE_FIDUCIAL_SIZE";
    const char fiducial_columns_tag[] = "MAKOCODE_FIDUCIAL_COLUMNS";
    const char fiducial_rows_tag[] = "MAKOCODE_FIDUCIAL_ROWS";
    const char fiducial_margin_tag[] = "MAKOCODE_FIDUCIAL_MARGIN";
    const char subgrid_col_offsets_tag[] = "MAKOCODE_SUBGRID_COL_OFFSETS";
    const char subgrid_row_offsets_tag[] = "MAKOCODE_SUBGRID_ROW_OFFSETS";
    const usize bytes_tag_len = (usize)sizeof(bytes_tag) - 1u;
    const usize bits_tag_len = (usize)sizeof(bits_tag) - 1u;
    const usize ecc_block_tag_len = (usize)sizeof(ecc_block_tag) - 1u;
    const usize ecc_original_tag_len = (usize)sizeof(ecc_original_tag) - 1u;
    const usize palette_tag_len = (usize)sizeof(palette_tag) - 1u;
    const usize palette_base_tag_len = (usize)sizeof(palette_base_tag) - 1u;
    const usize page_symbols_tag_len = (usize)sizeof(page_symbols_tag) - 1u;
    const usize fiducial_size_tag_len = (usize)sizeof(fiducial_size_tag) - 1u;
    const usize fiducial_columns_tag_len = (usize)sizeof(fiducial_columns_tag) - 1u;
    const usize fiducial_rows_tag_len = (usize)sizeof(fiducial_rows_tag) - 1u;
    const usize fiducial_margin_tag_len = (usize)sizeof(fiducial_margin_tag) - 1u;
    const usize subgrid_col_offsets_tag_len = (usize)sizeof(subgrid_col_offsets_tag) - 1u;
    const usize subgrid_row_offsets_tag_len = (usize)sizeof(subgrid_row_offsets_tag) - 1u;
    if ((length - index) >= bytes_tag_len) {
        bool match = true;
        for (usize i = 0u; i < bytes_tag_len; ++i) {
            if (comment[index + i] != bytes_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += bytes_tag_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_bytes = true;
                    state.bytes_value = value;
                }
            }
            return;
        }
    }
    if ((length - index) >= bits_tag_len) {
        bool match = true;
        for (usize i = 0u; i < bits_tag_len; ++i) {
            if (comment[index + i] != bits_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += bits_tag_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_bits = true;
                    state.bits_value = value;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    if ((length - index) >= ecc_block_tag_len) {
        bool match = true;
        for (usize i = 0u; i < ecc_block_tag_len; ++i) {
            if (comment[index + i] != ecc_block_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            usize next = index + ecc_block_tag_len;
            if (next < length) {
                char next_char = comment[next];
                if (next_char != ' ' && next_char != '\t') {
                    match = false;
                }
            }
        }
        if (match) {
            index += ecc_block_tag_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_ecc_block_data = true;
                    state.ecc_block_data_value = value;
                    state.has_ecc_flag = true;
                    state.ecc_flag_value = 1u;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    if ((length - index) >= ecc_original_tag_len) {
        bool match = true;
        for (usize i = 0u; i < ecc_original_tag_len; ++i) {
            if (comment[index + i] != ecc_original_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            usize next = index + ecc_original_tag_len;
            if (next < length) {
                char next_char = comment[next];
                if (next_char != ' ' && next_char != '\t') {
                    match = false;
                }
            }
        }
        if (match) {
            index += ecc_original_tag_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_ecc_original_bytes = true;
                    state.ecc_original_bytes_value = value;
                    state.has_ecc_flag = true;
                    state.ecc_flag_value = 1u;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    if ((length - index) >= palette_tag_len) {
        bool match = true;
        for (usize i = 0u; i < palette_tag_len; ++i) {
            if (comment[index + i] != palette_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            usize next = index + palette_tag_len;
            if (next < length) {
                char next_char = comment[next];
                if (next_char != ' ' && next_char != '\t') {
                    match = false;
                }
            }
        }
        if (match) {
            index += palette_tag_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize text_start = index;
            usize text_end = length;
            while (text_end > text_start) {
                char tail = comment[text_end - 1u];
                if (tail == ' ' || tail == '\t' || tail == '\r' || tail == '\n') {
                    --text_end;
                } else {
                    break;
                }
            }
            if (text_end > text_start) {
                usize text_length = text_end - text_start;
                if (text_length >= MAX_CUSTOM_PALETTE_TEXT) {
                    text_length = MAX_CUSTOM_PALETTE_TEXT - 1u;
                }
                for (usize i = 0u; i < text_length; ++i) {
                    state.palette_text[i] = comment[text_start + i];
                }
                state.palette_text[text_length] = '\0';
                state.palette_text_length = text_length;
                state.has_palette_text = true;
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    if ((length - index) >= palette_base_tag_len) {
        bool match = true;
        for (usize i = 0u; i < palette_base_tag_len; ++i) {
            if (comment[index + i] != palette_base_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += palette_base_tag_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_palette_base = true;
                    state.palette_base_value = value;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    if ((length - index) >= page_symbols_tag_len) {
        bool match = true;
        for (usize i = 0u; i < page_symbols_tag_len; ++i) {
            if (comment[index + i] != page_symbols_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            usize next = index + page_symbols_tag_len;
            if (next < length) {
                char next_char = comment[next];
                if (next_char != ' ' && next_char != '\t') {
                    match = false;
                }
            }
        }
        if (match) {
            index += page_symbols_tag_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_page_symbols = true;
                    state.page_symbols_value = value;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    if ((length - index) >= fiducial_size_tag_len) {
        bool match = true;
        for (usize i = 0u; i < fiducial_size_tag_len; ++i) {
            if (comment[index + i] != fiducial_size_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += fiducial_size_tag_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_fiducial_size = true;
                    state.fiducial_size_value = value;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    if ((length - index) >= fiducial_columns_tag_len) {
        bool match = true;
        for (usize i = 0u; i < fiducial_columns_tag_len; ++i) {
            if (comment[index + i] != fiducial_columns_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += fiducial_columns_tag_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_fiducial_columns = true;
                    state.fiducial_columns_value = value;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    if ((length - index) >= fiducial_rows_tag_len) {
        bool match = true;
        for (usize i = 0u; i < fiducial_rows_tag_len; ++i) {
            if (comment[index + i] != fiducial_rows_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += fiducial_rows_tag_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_fiducial_rows = true;
                    state.fiducial_rows_value = value;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    if ((length - index) >= fiducial_margin_tag_len) {
        bool match = true;
        for (usize i = 0u; i < fiducial_margin_tag_len; ++i) {
            if (comment[index + i] != fiducial_margin_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += fiducial_margin_tag_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_fiducial_margin = true;
                    state.fiducial_margin_value = value;
                }
            }
            return;
        }
    }
    if ((length - index) >= subgrid_col_offsets_tag_len) {
        bool match = true;
        for (usize i = 0u; i < subgrid_col_offsets_tag_len; ++i) {
            if (comment[index + i] != subgrid_col_offsets_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += subgrid_col_offsets_tag_len;
            u64 values[MAX_FIDUCIAL_SUBGRID_ENTRIES];
            u32 count = 0u;
            while (index < length) {
                while (index < length && (comment[index] == ' ' || comment[index] == '\t' || comment[index] == ',')) {
                    ++index;
                }
                if (index >= length) {
                    break;
                }
                usize number_start = index;
                while (index < length) {
                    char c = comment[index];
                    if (c < '0' || c > '9') {
                        break;
                    }
                    ++index;
                }
                usize number_length = index - number_start;
                if (!number_length) {
                    if (index < length) {
                        ++index;
                    }
                    continue;
                }
                if (count >= MAX_FIDUCIAL_SUBGRID_ENTRIES) {
                    count = 0u;
                    break;
                }
                u64 value = 0u;
                if (!ascii_to_u64(comment + number_start, number_length, &value)) {
                    count = 0u;
                    break;
                }
                values[count++] = value;
            }
            if (count >= 2u) {
                state.has_fiducial_col_offsets = true;
                state.fiducial_col_offset_count = count;
                for (u32 i = 0u; i < count; ++i) {
                    state.fiducial_col_offsets[i] = values[i];
                }
            }
            return;
        }
    }
    if ((length - index) >= subgrid_row_offsets_tag_len) {
        bool match = true;
        for (usize i = 0u; i < subgrid_row_offsets_tag_len; ++i) {
            if (comment[index + i] != subgrid_row_offsets_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += subgrid_row_offsets_tag_len;
            u64 values[MAX_FIDUCIAL_SUBGRID_ENTRIES];
            u32 count = 0u;
            while (index < length) {
                while (index < length && (comment[index] == ' ' || comment[index] == '\t' || comment[index] == ',')) {
                    ++index;
                }
                if (index >= length) {
                    break;
                }
                usize number_start = index;
                while (index < length) {
                    char c = comment[index];
                    if (c < '0' || c > '9') {
                        break;
                    }
                    ++index;
                }
                usize number_length = index - number_start;
                if (!number_length) {
                    if (index < length) {
                        ++index;
                    }
                    continue;
                }
                if (count >= MAX_FIDUCIAL_SUBGRID_ENTRIES) {
                    count = 0u;
                    break;
                }
                u64 value = 0u;
                if (!ascii_to_u64(comment + number_start, number_length, &value)) {
                    count = 0u;
                    break;
                }
                values[count++] = value;
            }
            if (count >= 2u) {
                state.has_fiducial_row_offsets = true;
                state.fiducial_row_offset_count = count;
                for (u32 i = 0u; i < count; ++i) {
                    state.fiducial_row_offsets[i] = values[i];
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    const char footer_rows_tag[] = "MAKOCODE_FOOTER_ROWS";
    const usize footer_rows_tag_len = (usize)sizeof(footer_rows_tag) - 1u;
    if ((length - index) >= footer_rows_tag_len) {
        bool match = true;
        for (usize i = 0u; i < footer_rows_tag_len; ++i) {
            if (comment[index + i] != footer_rows_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += footer_rows_tag_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_footer_rows = true;
                    state.footer_rows_value = value;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    const char skew_src_width_tag[] = "skew_src_width";
    const usize skew_src_width_len = (usize)sizeof(skew_src_width_tag) - 1u;
    if ((length - index) >= skew_src_width_len) {
        bool match = true;
        for (usize i = 0u; i < skew_src_width_len; ++i) {
            if (comment[index + i] != skew_src_width_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += skew_src_width_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_skew_src_width = true;
                    state.skew_src_width_value = value;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    const char skew_src_height_tag[] = "skew_src_height";
    const usize skew_src_height_len = (usize)sizeof(skew_src_height_tag) - 1u;
    if ((length - index) >= skew_src_height_len) {
        bool match = true;
        for (usize i = 0u; i < skew_src_height_len; ++i) {
            if (comment[index + i] != skew_src_height_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += skew_src_height_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if (c < '0' || c > '9') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                u64 value = 0u;
                if (ascii_to_u64(comment + number_start, number_length, &value)) {
                    state.has_skew_src_height = true;
                    state.skew_src_height_value = value;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    const char skew_margin_tag[] = "skew_margin_x";
    const usize skew_margin_len = (usize)sizeof(skew_margin_tag) - 1u;
    if ((length - index) >= skew_margin_len) {
        bool match = true;
        for (usize i = 0u; i < skew_margin_len; ++i) {
            if (comment[index + i] != skew_margin_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += skew_margin_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            bool negative = false;
            if (index < length && comment[index] == '-') {
                negative = true;
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if ((c < '0' || c > '9') && c != '.') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                double value = 0.0;
                if (ascii_to_double(comment + number_start, number_length, &value)) {
                    if (negative) {
                        value = -value;
                    }
                    state.has_skew_margin_x = true;
                    state.skew_margin_x_value = value;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    const char skew_amount_tag[] = "skew_x_pixels";
    const usize skew_amount_len = (usize)sizeof(skew_amount_tag) - 1u;
    if ((length - index) >= skew_amount_len) {
        bool match = true;
        for (usize i = 0u; i < skew_amount_len; ++i) {
            if (comment[index + i] != skew_amount_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += skew_amount_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            bool negative = false;
            if (index < length && comment[index] == '-') {
                negative = true;
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if ((c < '0' || c > '9') && c != '.') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                double value = 0.0;
                if (ascii_to_double(comment + number_start, number_length, &value)) {
                    if (negative) {
                        value = -value;
                    }
                    state.has_skew_x_pixels = true;
                    state.skew_x_pixels_value = value;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    const char skew_bottom_tag[] = "skew_bottom_x";
    const usize skew_bottom_len = (usize)sizeof(skew_bottom_tag) - 1u;
    const char skew_y_tag[] = "skew_y_pixels";
    const usize skew_y_len = (usize)sizeof(skew_y_tag) - 1u;
    if ((length - index) >= skew_bottom_len) {
        bool match = true;
        for (usize i = 0u; i < skew_bottom_len; ++i) {
            if (comment[index + i] != skew_bottom_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += skew_bottom_len;
            while (index < length && (comment[index] == ' ' || comment[index] == '\t')) {
                ++index;
            }
            bool negative = false;
            if (index < length && comment[index] == '-') {
                negative = true;
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if ((c < '0' || c > '9') && c != '.') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                double value = 0.0;
                if (ascii_to_double(comment + number_start, number_length, &value)) {
                    if (negative) {
                        value = -value;
                    }
                    state.has_skew_bottom_x = true;
                    state.skew_bottom_x_value = value;
                }
            }
            return;
        }
    }
    index = 0u;
    while (index < length) {
        char c = comment[index];
        if (c != ' ' && c != '\t') {
            break;
        }
        ++index;
    }
    if ((length - index) >= skew_y_len) {
        bool match = true;
        for (usize i = 0u; i < skew_y_len; ++i) {
            if (comment[index + i] != skew_y_tag[i]) {
                match = false;
                break;
            }
        }
        if (match) {
            index += skew_y_len;
            bool negative = false;
            if (index < length && comment[index] == '-') {
                negative = true;
                ++index;
            }
            usize number_start = index;
            while (index < length) {
                char c = comment[index];
                if ((c < '0' || c > '9') && c != '.') {
                    break;
                }
                ++index;
            }
            usize number_length = index - number_start;
            if (number_length) {
                double value = 0.0;
                if (ascii_to_double(comment + number_start, number_length, &value)) {
                    if (negative) {
                        value = -value;
                    }
                    state.has_skew_y_pixels = true;
                    state.skew_y_pixels_value = value;
                }
            }
            return;
        }
    }
}

static bool ppm_next_token(PpmParserState& state, const char** out_start, usize* out_length) {
    while (state.cursor < state.size) {
        char current = (char)state.data[state.cursor];
        if (current == '#') {
            ++state.cursor;
            usize comment_start = state.cursor;
            while (state.cursor < state.size) {
                char c = (char)state.data[state.cursor];
                if (c == '\n' || c == '\r') {
                    break;
                }
                ++state.cursor;
            }
            usize comment_length = state.cursor - comment_start;
            ppm_consume_comment(state, comment_start, comment_length);
            while (state.cursor < state.size) {
                char newline_char = (char)state.data[state.cursor];
                if (newline_char == '\n' || newline_char == '\r') {
                    ++state.cursor;
                } else {
                    break;
                }
            }
            continue;
        }
        if (current <= ' ') {
            ++state.cursor;
            continue;
        }
        usize start = state.cursor;
        while (state.cursor < state.size) {
            char c = (char)state.data[state.cursor];
            if (c <= ' ' || c == '#') {
                break;
            }
            ++state.cursor;
        }
        *out_start = (const char*)(state.data + start);
        *out_length = state.cursor - start;
        return true;
    }
    return false;
}

static bool map_rgb_to_samples(u8 mode, const u8* rgb, u32* samples);

static u64 gcd_u64(u64 a, u64 b) {
    while (b) {
        u64 temp = a % b;
        a = b;
        b = temp;
    }
    return a ? a : b;
}

static bool rgb_within_tolerance(const u8* a, const u8* b, u8 tolerance) {
    if (!a || !b) {
        return false;
    }
    int dr = (int)a[0] - (int)b[0];
    if (dr < 0) {
        dr = -dr;
    }
    int dg = (int)a[1] - (int)b[1];
    if (dg < 0) {
        dg = -dg;
    }
    int db = (int)a[2] - (int)b[2];
    if (db < 0) {
        db = -db;
    }
    int limit = (int)tolerance;
    if (limit < 0) {
        limit = 0;
    }
    return dr <= limit && dg <= limit && db <= limit;
}

static bool ppm_read_rgb_pixels(PpmParserState& state,
                                u64 pixel_count,
                                makocode::ByteBuffer& pixel_buffer) {
    if (pixel_count == 0u) {
        return false;
    }
    u64 total_bytes = pixel_count * 3u;
    if (total_bytes > (u64)USIZE_MAX_VALUE) {
        return false;
    }
    if (!pixel_buffer.ensure((usize)total_bytes)) {
        return false;
    }
    for (u64 pixel = 0u; pixel < pixel_count; ++pixel) {
        for (u32 channel = 0u; channel < 3u; ++channel) {
            const char* token = 0;
            usize length = 0u;
            if (!ppm_next_token(state, &token, &length)) {
                return false;
            }
            u64 value = 0u;
            if (!ascii_to_u64(token, length, &value) || value > 255u) {
                return false;
            }
            pixel_buffer.data[pixel * 3u + channel] = (u8)value;
        }
    }
    pixel_buffer.size = (usize)total_bytes;
    return true;
}

static double compute_rotation_margin_from_geometry(unsigned src_width,
                                                    unsigned src_height,
                                                    double rotation_degrees,
                                                    unsigned rotated_width,
                                                    unsigned rotated_height) {
    if (src_width == 0u || src_height == 0u || rotated_width == 0u || rotated_height == 0u) {
        return 0.0;
    }
    if (rotation_degrees == 0.0) {
        return 0.0;
    }
    const double radians = rotation_degrees * (3.14159265358979323846 / 180.0);
    const double cos_a = cos(radians);
    const double sin_a = sin(radians);
    const double center_x = ((double)src_width - 1.0) * 0.5;
    const double center_y = ((double)src_height - 1.0) * 0.5;
    double min_x = 0.0;
    double min_y = 0.0;
    bool initialized = false;
    for (int i = 0; i < 4; ++i) {
        double corner_x = (i & 1) ? (double)(src_width - 1u) : 0.0;
        double corner_y = (i & 2) ? (double)(src_height - 1u) : 0.0;
        double dx = corner_x - center_x;
        double dy = corner_y - center_y;
        double rx = dx * cos_a - dy * sin_a;
        double ry = dx * sin_a + dy * cos_a;
        if (!initialized) {
            min_x = rx;
            min_y = ry;
            initialized = true;
        } else {
            if (rx < min_x) {
                min_x = rx;
            }
            if (ry < min_y) {
                min_y = ry;
            }
        }
    }
    double offset_x = (((double)rotated_width - 1.0) * 0.5) + min_x;
    double offset_y = (((double)rotated_height - 1.0) * 0.5) + min_y;
    if (offset_x < 0.0) {
        offset_x = 0.0;
    }
    if (offset_y < 0.0) {
        offset_y = 0.0;
    }
    return (offset_x + offset_y) * 0.5;
}

static bool auto_detect_page_rotation(const u8* pixel_data,
                                      u64 image_width,
                                      u64 image_height,
                                      u64 expected_width,
                                      u64 expected_height,
                                      PpmParserState& state) {
    if (!pixel_data || !image_width || !image_height || !expected_width || !expected_height) {
        return false;
    }
    if (expected_width < 256u || expected_height < 256u) {
        return false;
    }
    if (image_width > 0xFFFFFFFFull || image_height > 0xFFFFFFFFull) {
        return false;
    }
    if (expected_width > 0xFFFFFFFFull || expected_height > 0xFFFFFFFFull) {
        return false;
    }
    u64 pixel_count = image_width * image_height;
    if (pixel_count == 0u || pixel_count > (u64)USIZE_MAX_VALUE) {
        return false;
    }

    makocode::image::ImageBuffer gray;
    gray.width = (unsigned)image_width;
    gray.height = (unsigned)image_height;
    gray.pixels = (unsigned char*)malloc((usize)pixel_count);
    if (!gray.pixels) {
        return false;
    }
    const u8* rgb_ptr = pixel_data;
    for (u64 idx = 0u; idx < pixel_count; ++idx) {
        u32 r = rgb_ptr[0u];
        u32 g = rgb_ptr[1u];
        u32 b = rgb_ptr[2u];
        gray.pixels[idx] = (u8)((r + g + b) / 3u);
        rgb_ptr += 3u;
    }

    makocode::image::Histogram histogram;
    makocode::image::compute_histogram(gray, histogram);
    makocode::image::CutLevels levels;
    if (!makocode::image::analyze_cut_levels(histogram, 0.80, levels)) {
        makocode::image::release(gray);
        return false;
    }
    makocode::image::CornerDetectionConfig config;
    config.logical_width = (u32)expected_width;
    config.logical_height = (u32)expected_height;
    if (config.logical_width == 0u || config.logical_height == 0u) {
        makocode::image::release(gray);
        return false;
    }
    if (config.logical_width > 64u && config.logical_height > 64u) {
        config.cross_half = 5u;
        config.cross_trim = 0.5;
    }
    makocode::image::CornerDetectionResult result;
    bool found = makocode::image::find_corners(gray, levels.global_cut, config, result);
    makocode::image::release(gray);
    if (!found || !result.valid) {
        return false;
    }
    double rotation_radians = atan2(result.pixelhy, result.pixelhx);
    double rotation_degrees = rotation_radians * (180.0 / 3.14159265358979323846);
    rotation_degrees = makocode::image::normalize_angle(rotation_degrees);
    double abs_rotation = (rotation_degrees < 0.0) ? -rotation_degrees : rotation_degrees;
    if (abs_rotation < 0.35) {
        return false;
    }
    double width_pixels = result.hpixel * (double)config.logical_width;
    double height_pixels = result.vpixel * (double)config.logical_height;
    if (width_pixels <= 0.0 || height_pixels <= 0.0) {
        return false;
    }
    u64 rotation_width = (u64)(width_pixels + 0.5);
    u64 rotation_height = (u64)(height_pixels + 0.5);
    if (!rotation_width || !rotation_height) {
        return false;
    }
    if (rotation_width > 0xFFFFFFFFull || rotation_height > 0xFFFFFFFFull) {
        return false;
    }
    double rotation_margin = compute_rotation_margin_from_geometry((unsigned)rotation_width,
                                                                   (unsigned)rotation_height,
                                                                   rotation_degrees,
                                                                   (unsigned)image_width,
                                                                   (unsigned)image_height);
    state.has_rotation_degrees = true;
    state.rotation_degrees_value = rotation_degrees;
    state.has_rotation_width = true;
    state.rotation_width_value = rotation_width;
    state.has_rotation_height = true;
    state.rotation_height_value = rotation_height;
    state.has_rotation_margin = true;
    state.rotation_margin_value = rotation_margin;
    return true;
}

static bool estimate_rotation_from_gradients(const u8* pixel_data,
                                             u64 width,
                                             u64 height,
                                             u64 expected_width,
                                             u64 expected_height,
                                             double fiducial_margin,
                                             double& out_degrees,
                                             double& out_scale) {
    if (!pixel_data || width < 4u || height < 4u || !expected_width || !expected_height) {
        return false;
    }
    double scale_x_est = (double)width / (double)expected_width;
    double scale_y_est = (double)height / (double)expected_height;
    double scale_est = (scale_x_est + scale_y_est) * 0.5;
    if (scale_est < 1.0) {
        scale_est = 1.0;
    }
    int margin = (int)(fiducial_margin * scale_est + 0.5);
    if (margin < 2) {
        margin = 2;
    }
    int x_start = margin;
    int y_start = margin;
    int x_end = (int)width - margin - 2;
    int y_end = (int)height - margin - 2;
    if (x_end <= x_start || y_end <= y_start) {
        return false;
    }
    int sample_step = (int)(scale_est >= 1.0 ? scale_est : 1.0);
    if (sample_step < 1) {
        sample_step = 1;
    }
    const int bins = 181;
    double histogram[bins];
    for (int i = 0; i < bins; ++i) {
        histogram[i] = 0.0;
    }
    for (int y = y_start; y <= y_end; y += sample_step) {
        for (int x = x_start; x <= x_end; x += sample_step) {
            const u8* left = pixel_data + ((u64)y * width + (u64)(x - 1)) * 3u;
            const u8* right = pixel_data + ((u64)y * width + (u64)(x + 1)) * 3u;
            const u8* up = pixel_data + ((u64)(y - 1) * width + (u64)x) * 3u;
            const u8* down = pixel_data + ((u64)(y + 1) * width + (u64)x) * 3u;
            double left_i = ((double)left[0] + left[1] + left[2]) / 3.0;
            double right_i = ((double)right[0] + right[1] + right[2]) / 3.0;
            double up_i = ((double)up[0] + up[1] + up[2]) / 3.0;
            double down_i = ((double)down[0] + down[1] + down[2]) / 3.0;
            double gx = right_i - left_i;
            double gy = down_i - up_i;
            double magnitude = sqrt(gx * gx + gy * gy);
            if (magnitude < 25.0) {
                continue;
            }
            double theta_grad = atan2(gy, gx) * (180.0 / 3.14159265358979323846);
            double theta_line = makocode::image::normalize_angle(theta_grad);
            if (theta_line < -90.0) {
                theta_line += 180.0;
            } else if (theta_line > 90.0) {
                theta_line -= 180.0;
            }
            int bin = (int)floor(theta_line + 90.0 + 0.5);
            if (bin < 0) {
                bin = 0;
            }
            if (bin >= bins) {
                bin = bins - 1;
            }
            histogram[bin] += magnitude;
        }
    }
    int best_bin = -1;
    double best_value = 0.0;
    for (int i = 0; i < bins; ++i) {
        if (histogram[i] > best_value) {
            best_value = histogram[i];
            best_bin = i;
        }
    }
    if (best_bin < 0 || best_value <= 0.0) {
        return false;
    }
    double rotation_degrees = (double)best_bin - 90.0;
    rotation_degrees = makocode::image::normalize_angle(rotation_degrees);
    double radians = rotation_degrees * (3.14159265358979323846 / 180.0);
    double cos_a = cos(radians);
    double sin_a = sin(radians);
    double rotated_w = fabs((double)expected_width * cos_a) + fabs((double)expected_height * sin_a);
    double rotated_h = fabs((double)expected_width * sin_a) + fabs((double)expected_height * cos_a);
    if (rotated_w <= 0.0 || rotated_h <= 0.0) {
        return false;
    }
    double scale_w = (double)width / rotated_w;
    double scale_h = (double)height / rotated_h;
    double uniform_scale = (scale_w + scale_h) * 0.5;
    if (uniform_scale <= 0.0) {
        return false;
    }
    out_degrees = rotation_degrees;
    out_scale = uniform_scale;
    return true;
}


static bool auto_detect_rotation_from_fiducials(const double* centers_x,
                                                const double* centers_y,
                                                u32 fiducial_columns,
                                                u32 fiducial_rows,
                                                u64 expected_width,
                                                u64 expected_height,
                                                double fiducial_margin,
                                                u64 image_width,
                                                u64 image_height,
                                                const PpmParserState& state,
                                                double& out_degrees,
                                                u64& out_rotation_width,
                                                u64& out_rotation_height,
                                                double& out_margin,
                                                AffineTransform* out_affine) {
    if (!centers_x || !centers_y || !fiducial_columns || !fiducial_rows ||
        !expected_width || !expected_height || !image_width || !image_height) {
        return false;
    }
    (void)fiducial_margin;
    u64 point_count = (u64)fiducial_columns * (u64)fiducial_rows;
    if (point_count == 0u) {
        return false;
    }
    if (out_affine) {
        *out_affine = AffineTransform();
    }

    double* row_bias_y = (double*)malloc((usize)fiducial_rows * sizeof(double));
    double* row_bias_count = (double*)malloc((usize)fiducial_rows * sizeof(double));
    double* column_bias_x = (double*)malloc((usize)fiducial_columns * sizeof(double));
    double* column_bias_count = (double*)malloc((usize)fiducial_columns * sizeof(double));
    if (!row_bias_y || !row_bias_count || !column_bias_x || !column_bias_count) {
        if (row_bias_y) free(row_bias_y);
        if (row_bias_count) free(row_bias_count);
        if (column_bias_x) free(column_bias_x);
        if (column_bias_count) free(column_bias_count);
        return false;
    }
    for (u32 i = 0u; i < fiducial_rows; ++i) {
        row_bias_y[i] = 0.0;
        row_bias_count[i] = 0.0;
    }
    for (u32 i = 0u; i < fiducial_columns; ++i) {
        column_bias_x[i] = 0.0;
        column_bias_count[i] = 0.0;
    }
    auto free_bias_buffers = [&]() {
        if (row_bias_y) {
            free(row_bias_y);
            row_bias_y = 0;
        }
        if (row_bias_count) {
            free(row_bias_count);
            row_bias_count = 0;
        }
        if (column_bias_x) {
            free(column_bias_x);
            column_bias_x = 0;
        }
        if (column_bias_count) {
            free(column_bias_count);
            column_bias_count = 0;
        }
    };

    auto logical_column_value = [&](u32 col_index) -> double {
        if (state.has_fiducial_col_offsets &&
            state.fiducial_col_offset_count > col_index) {
            return (double)state.fiducial_col_offsets[col_index];
        }
        if (fiducial_columns <= 1u) {
            return (double)expected_width * 0.5;
        }
        double t = (double)col_index / (double)(fiducial_columns - 1u);
        return t * (double)expected_width;
    };
    auto logical_row_value = [&](u32 row_index) -> double {
        if (state.has_fiducial_row_offsets &&
            state.fiducial_row_offset_count > row_index) {
            return (double)state.fiducial_row_offsets[row_index];
        }
        if (fiducial_rows <= 1u) {
            return (double)expected_height * 0.5;
        }
        double t = (double)row_index / (double)(fiducial_rows - 1u);
        return t * (double)expected_height;
    };
    const double integer_snap_tolerance = 0.12;

    double logical_span_x = (fiducial_columns > 1u)
                                ? (logical_column_value(fiducial_columns - 1u) - logical_column_value(0u))
                                : (double)expected_width;
    double logical_span_y = (fiducial_rows > 1u)
                                ? (logical_row_value(fiducial_rows - 1u) - logical_row_value(0u))
                                : (double)expected_height;
    if (logical_span_x <= 0.0) {
        logical_span_x = (double)expected_width;
    }
    if (logical_span_y <= 0.0) {
        logical_span_y = (double)expected_height;
    }

    for (u32 row = 0u; row < fiducial_rows; ++row) {
        double logical_y = logical_row_value(row);
        for (u32 col = 0u; col < fiducial_columns; ++col) {
            double logical_x = logical_column_value(col);
            usize idx = (usize)row * (usize)fiducial_columns + (usize)col;
            row_bias_y[row] += centers_y[idx] - logical_y;
            row_bias_count[row] += 1.0;
            column_bias_x[col] += centers_x[idx] - logical_x;
            column_bias_count[col] += 1.0;
        }
    }
    for (u32 row = 0u; row < fiducial_rows; ++row) {
        if (row_bias_count[row] > 0.0) {
            row_bias_y[row] /= row_bias_count[row];
        } else {
            row_bias_y[row] = 0.0;
        }
    }
    for (u32 col = 0u; col < fiducial_columns; ++col) {
        if (column_bias_count[col] > 0.0) {
            column_bias_x[col] /= column_bias_count[col];
        } else {
            column_bias_x[col] = 0.0;
        }
    }

    double sum_logical_x = 0.0;
    double sum_logical_y = 0.0;
    double sum_physical_x = 0.0;
    double sum_physical_y = 0.0;
    for (u32 row = 0u; row < fiducial_rows; ++row) {
        double logical_y = logical_row_value(row);
        for (u32 col = 0u; col < fiducial_columns; ++col) {
            double logical_x = logical_column_value(col);
            usize idx = (usize)row * (usize)fiducial_columns + (usize)col;
            double adjusted_x = centers_x[idx] - column_bias_x[col];
            double adjusted_y = centers_y[idx] - row_bias_y[row];
            sum_logical_x += logical_x;
            sum_logical_y += logical_y;
            sum_physical_x += adjusted_x;
            sum_physical_y += adjusted_y;
        }
    }
    double inv_points = 1.0 / (double)point_count;
    double mean_logical_x = sum_logical_x * inv_points;
    double mean_logical_y = sum_logical_y * inv_points;
    double mean_physical_x = sum_physical_x * inv_points;
    double mean_physical_y = sum_physical_y * inv_points;

    double h00 = 0.0;
    double h01 = 0.0;
    double h10 = 0.0;
    double h11 = 0.0;
    double logical_variance = 0.0;
    for (u32 row = 0u; row < fiducial_rows; ++row) {
        double logical_y = logical_row_value(row) - mean_logical_y;
        for (u32 col = 0u; col < fiducial_columns; ++col) {
            double logical_x = logical_column_value(col) - mean_logical_x;
            usize idx = (usize)row * (usize)fiducial_columns + (usize)col;
            double adjusted_x = centers_x[idx] - column_bias_x[col];
            double adjusted_y = centers_y[idx] - row_bias_y[row];
            double physical_x = adjusted_x - mean_physical_x;
            double physical_y = adjusted_y - mean_physical_y;
            h00 += physical_x * logical_x;
            h01 += physical_x * logical_y;
            h10 += physical_y * logical_x;
            h11 += physical_y * logical_y;
            logical_variance += logical_x * logical_x + logical_y * logical_y;
        }
    }
    if (logical_variance <= 1e-9) {
        free_bias_buffers();
        return false;
    }
    double a = h00 + h11;
    double b = h01 - h10;
    if (fabs(a) < 1e-9 && fabs(b) < 1e-9) {
        free_bias_buffers();
        return false;
    }
    double rotation_radians = atan2(b, a);
    double rotation_degrees = rotation_radians * (180.0 / 3.14159265358979323846);
    double scale_hint = 1.0;
    if (expected_width && expected_height) {
        double hint_x = (double)image_width / (double)expected_width;
        double hint_y = (double)image_height / (double)expected_height;
        if (hint_x > 0.0 && hint_y > 0.0) {
            scale_hint = (hint_x + hint_y) * 0.5;
        }
    }
    if (scale_hint <= 0.0) {
        scale_hint = 1.0;
    }
    double sin_sum = 0.0;
    double sin_weight = 0.0;
    if (fiducial_rows >= 2u) {
        for (u32 col = 0u; col < fiducial_columns; ++col) {
            usize top_index = (usize)col;
            usize bottom_index = (usize)(fiducial_rows - 1u) * (usize)fiducial_columns + (usize)col;
            double dx = centers_x[bottom_index] - centers_x[top_index];
            double dy = centers_y[bottom_index] - centers_y[top_index];
            double length = sqrt(dx * dx + dy * dy);
            if (length > 1.0) {
                double sin_col = dx / length;
                if (sin_col > 1.0) sin_col = 1.0;
                if (sin_col < -1.0) sin_col = -1.0;
                sin_sum += sin_col * length;
                sin_weight += length;
            }
        }
    }
    if (fiducial_columns >= 2u) {
        for (u32 row = 0u; row < fiducial_rows; ++row) {
            usize left_index = (usize)row * (usize)fiducial_columns;
            usize right_index = left_index + (usize)(fiducial_columns - 1u);
            double dx = centers_x[right_index] - centers_x[left_index];
            double dy = centers_y[right_index] - centers_y[left_index];
            double length = sqrt(dx * dx + dy * dy);
            if (length > 1.0) {
                double sin_row = -dy / length;
                if (sin_row > 1.0) sin_row = 1.0;
                if (sin_row < -1.0) sin_row = -1.0;
                sin_sum += sin_row * length;
                sin_weight += length;
            }
        }
    }
    if (sin_weight > 0.0) {
        double sin_value = sin_sum / sin_weight;
        if (sin_value > 1.0) sin_value = 1.0;
        if (sin_value < -1.0) sin_value = -1.0;
        rotation_radians = asin(sin_value);
        rotation_degrees = rotation_radians * (180.0 / 3.14159265358979323846);
    }
    if (fabs(rotation_degrees) < 0.05 && state.has_rotation_width && state.has_rotation_height) {
        double src_w = (double)state.rotation_width_value;
        double src_h = (double)state.rotation_height_value;
        double margin = state.has_rotation_margin ? state.rotation_margin_value : 0.0;
        double obs_w = (double)image_width - margin * 2.0;
        double obs_h = (double)image_height - margin * 2.0;
        if (obs_w > 0.0 && obs_h > 0.0 && src_w > 0.0 && src_h > 0.0) {
            double theta = 0.0;
            if (fabs(src_w - src_h) < 1e-3) {
                double ratio = obs_w / src_w;
                double value = ratio / 1.4142135623730951;
                if (value > 1.0) value = 1.0;
                if (value < -1.0) value = -1.0;
                theta = asin(value) - (3.14159265358979323846 * 0.25);
            } else {
                double denom = (src_w * src_w) - (src_h * src_h);
                if (fabs(denom) > 1e-6) {
                    double c = (src_w * obs_w - src_h * obs_h) / denom;
                    double s = (src_h * obs_w - src_w * obs_h) / denom;
                    double norm = sqrt(c * c + s * s);
                    if (norm > 1e-6) {
                        c /= norm;
                        s /= norm;
                        theta = atan2(s, c);
                    }
                }
            }
            rotation_radians = theta;
            rotation_degrees = rotation_radians * (180.0 / 3.14159265358979323846);
        }
    }
    rotation_degrees = makocode::image::normalize_angle(rotation_degrees);

    auto compute_average_span = [&](bool horizontal) -> double {
        double total = 0.0;
        double count = 0.0;
        if (horizontal && fiducial_columns >= 2u) {
            for (u32 row = 0u; row < fiducial_rows; ++row) {
                double row_span = 0.0;
                bool row_valid = false;
                for (u32 col = 0u; col + 1u < fiducial_columns; ++col) {
                    usize idx0 = (usize)row * (usize)fiducial_columns + (usize)col;
                    usize idx1 = idx0 + 1u;
                    double dx = centers_x[idx1] - centers_x[idx0];
                    double dy = centers_y[idx1] - centers_y[idx0];
                    double length = sqrt(dx * dx + dy * dy);
                    if (length < 1.0) {
                        continue;
                    }
                    row_span += length;
                    row_valid = true;
                }
                if (row_valid) {
                    total += row_span;
                    count += 1.0;
                }
            }
        } else if (!horizontal && fiducial_rows >= 2u) {
            for (u32 col = 0u; col < fiducial_columns; ++col) {
                double column_span = 0.0;
                bool column_valid = false;
                for (u32 row = 0u; row + 1u < fiducial_rows; ++row) {
                    usize idx0 = (usize)row * (usize)fiducial_columns + (usize)col;
                    usize idx1 = idx0 + (usize)fiducial_columns;
                    double dx = centers_x[idx1] - centers_x[idx0];
                    double dy = centers_y[idx1] - centers_y[idx0];
                    double length = sqrt(dx * dx + dy * dy);
                    if (length < 1.0) {
                        continue;
                    }
                    column_span += length;
                    column_valid = true;
                }
                if (column_valid) {
                    total += column_span;
                    count += 1.0;
                }
            }
        }
        return (count > 0.0) ? (total / count) : 0.0;
    };

    double average_span_x = compute_average_span(true);
    double average_span_y = compute_average_span(false);

    double axis_cos_x = cos(rotation_radians);
    double axis_sin_x = sin(rotation_radians);
    double axis_cos_y = -axis_sin_x;
    double axis_sin_y = axis_cos_x;

    auto compute_axis_scale = [&](bool horizontal) -> double {
        if (horizontal && fiducial_columns < 2u) {
            return 0.0;
        }
        if (!horizontal && fiducial_rows < 2u) {
            return 0.0;
        }
        double axis_cos = horizontal ? axis_cos_x : axis_cos_y;
        double axis_sin = horizontal ? axis_sin_x : axis_sin_y;
        double base_logical = horizontal ? logical_column_value(0u) : logical_row_value(0u);
        double sum_l = 0.0;
        double sum_l2 = 0.0;
        double sum_p = 0.0;
        double sum_lp = 0.0;
        u64 sample_count = 0u;
        for (u32 row = 0u; row < fiducial_rows; ++row) {
            for (u32 col = 0u; col < fiducial_columns; ++col) {
                double logical = horizontal ? (logical_column_value(col) - base_logical)
                                            : (logical_row_value(row) - base_logical);
                usize idx = (usize)row * (usize)fiducial_columns + (usize)col;
                double proj = centers_x[idx] * axis_cos + centers_y[idx] * axis_sin;
                sum_l += logical;
                sum_l2 += logical * logical;
                sum_p += proj;
                sum_lp += logical * proj;
                ++sample_count;
            }
        }
        double denom = (double)sample_count * sum_l2 - sum_l * sum_l;
        if (sample_count >= 2u && fabs(denom) > 1e-6) {
            double slope = ((double)sample_count * sum_lp - sum_l * sum_p) / denom;
            if (slope > 0.0) {
                return slope;
            }
        }
        return 0.0;
    };

    double scale_x = compute_axis_scale(true);
    double average_scale_x = (average_span_x > 0.0 && logical_span_x > 0.0)
                                 ? (average_span_x / logical_span_x)
                                 : 0.0;
    if (scale_x <= 0.0) {
        scale_x = average_scale_x;
    } else if (average_scale_x > 0.0 && scale_x < average_scale_x * 0.85) {
        scale_x = average_scale_x;
    }
    double scale_y = compute_axis_scale(false);
    double average_scale_y = (average_span_y > 0.0 && logical_span_y > 0.0)
                                 ? (average_span_y / logical_span_y)
                                 : 0.0;
    if (scale_y <= 0.0) {
        scale_y = average_scale_y;
    } else if (average_scale_y > 0.0 && scale_y < average_scale_y * 0.85) {
        scale_y = average_scale_y;
    }
    // If the observed image dimensions already match the expected logical size (common when
    // we downsampled to the target resolution), prefer that direct scale over noisier
    // fiducial-derived estimates that can underfit after heavy downsampling blur.
    double dim_scale_x = (double)image_width / (double)expected_width;
    double dim_scale_y = (double)image_height / (double)expected_height;
    auto prefer_dimension_scale = [](double candidate, double direct) -> double {
        if (!(direct > 0.0)) {
            return candidate;
        }
        if (candidate <= 0.0) {
            return direct;
        }
        double rel_gap = fabs(candidate - direct) / direct;
        // If dimensional estimate is reasonably close (<=8%) and closer to an integer snap, prefer it.
        if (rel_gap <= 0.08) {
            double cand_round = floor(candidate + 0.5);
            double direct_round = floor(direct + 0.5);
            double cand_snap_gap = fabs(candidate - cand_round);
            double direct_snap_gap = fabs(direct - direct_round);
            if (direct_snap_gap * 0.8 <= cand_snap_gap) {
                return direct;
            }
        }
        // If candidate is way off (>12%) choose the dimensional scale.
        if (rel_gap > 0.12) {
            return direct;
        }
        return candidate;
    };

    // Build per-cell pitch map for additional robustness.
    double median_pitch_x = scale_x;
    double median_pitch_y = scale_y;
    if (fiducial_columns >= 2u && fiducial_rows >= 2u) {
        // Collect pitches between adjacent fiducials.
        const usize cell_count = (usize)(fiducial_columns - 1u) * (usize)(fiducial_rows - 1u);
        double* pitches_x = (double*)malloc(cell_count * sizeof(double));
        double* pitches_y = (double*)malloc(cell_count * sizeof(double));
        usize idx = 0u;
        if (pitches_x && pitches_y) {
            for (u32 r = 0u; r + 1u < fiducial_rows; ++r) {
                for (u32 c = 0u; c + 1u < fiducial_columns; ++c) {
                    double cx0 = centers_x[(usize)r * fiducial_columns + c];
                    double cy0 = centers_y[(usize)r * fiducial_columns + c];
                    double cx1 = centers_x[(usize)r * fiducial_columns + (c + 1u)];
                    double cy1 = centers_y[(usize)r * fiducial_columns + (c + 1u)];
                    double cx2 = centers_x[(usize)(r + 1u) * fiducial_columns + c];
                    double cy2 = centers_y[(usize)(r + 1u) * fiducial_columns + c];
                    double dx = sqrt((cx1 - cx0) * (cx1 - cx0) + (cy1 - cy0) * (cy1 - cy0));
                    double dy = sqrt((cx2 - cx0) * (cx2 - cx0) + (cy2 - cy0) * (cy2 - cy0));
                    pitches_x[idx] = dx;
                    pitches_y[idx] = dy;
                    ++idx;
                }
            }
            auto median_inplace = [](double* arr, usize n) -> double {
                if (!arr || n == 0u) return 0.0;
                // simple selection sort for small n
                for (usize i = 0; i < n; ++i) {
                    usize min_i = i;
                    for (usize j = i + 1; j < n; ++j) {
                        if (arr[j] < arr[min_i]) min_i = j;
                    }
                    double tmp = arr[i]; arr[i] = arr[min_i]; arr[min_i] = tmp;
                }
                if (n & 1u) return arr[n/2u];
                return 0.5 * (arr[n/2u - 1u] + arr[n/2u]);
            };
            median_pitch_x = median_inplace(pitches_x, idx);
            median_pitch_y = median_inplace(pitches_y, idx);
        }
        if (pitches_x) free(pitches_x);
        if (pitches_y) free(pitches_y);
    }

    scale_x = median_pitch_x;
    scale_y = median_pitch_y;
    scale_x = prefer_dimension_scale(scale_x, dim_scale_x);
    scale_y = prefer_dimension_scale(scale_y, dim_scale_y);

    // If metadata tile provided an affine pitch, force scale to that pitch (pixels per module).
    // Defer calling until analysis_width/height exist.
    if (debug_logging_enabled()) {
        char lsx_buf[32], lsy_buf[32], asx_buf[32], asy_buf[32], sx_buf[32], sy_buf[32];
        format_fixed_3(logical_span_x, lsx_buf, sizeof(lsx_buf));
        format_fixed_3(logical_span_y, lsy_buf, sizeof(lsy_buf));
        format_fixed_3(average_scale_x, asx_buf, sizeof(asx_buf));
        format_fixed_3(average_scale_y, asy_buf, sizeof(asy_buf));
        format_fixed_3(scale_x, sx_buf, sizeof(sx_buf));
        format_fixed_3(scale_y, sy_buf, sizeof(sy_buf));
        console_write(2, "debug fiducial-scale: logical_span_x=");
        console_write(2, lsx_buf);
        console_write(2, " logical_span_y=");
        console_write(2, lsy_buf);
        console_write(2, " avg_scale_x=");
        console_write(2, asx_buf);
        console_write(2, " avg_scale_y=");
        console_write(2, asy_buf);
        console_write(2, " scale_x=");
        console_write(2, sx_buf);
        console_write(2, " scale_y=");
        console_line(2, sy_buf);
    }
    if (scale_x <= 0.0 && scale_y <= 0.0) {
        free_bias_buffers();
        return false;
    }
    if (scale_x <= 0.0 && scale_y > 0.0) {
        scale_x = scale_y;
    }
    if (scale_y <= 0.0 && scale_x > 0.0) {
        scale_y = scale_x;
    }
    if (debug_logging_enabled()) {
        char angle_buf[32];
        char span_x_buf[32];
        char span_y_buf[32];
        format_fixed_3(rotation_degrees, angle_buf, sizeof(angle_buf));
        format_fixed_3(average_span_x, span_x_buf, sizeof(span_x_buf));
        format_fixed_3(average_span_y, span_y_buf, sizeof(span_y_buf));
        console_write(2, "debug fiducial-axis: procrustes_deg=");
        console_write(2, angle_buf);
        console_write(2, " avg_span_x=");
        console_write(2, span_x_buf);
        console_write(2, " avg_span_y=");
        console_line(2, span_y_buf);
    }
    double computed_width = scale_x * (double)expected_width;
    double computed_height = scale_y * (double)expected_height;
    if (expected_width > 0u && computed_width > 0.0) {
        double scale_ratio_x = computed_width / (double)expected_width;
        double rounded_ratio_x = floor(scale_ratio_x + 0.5);
        if (rounded_ratio_x >= 1.0 && fabs(scale_ratio_x - rounded_ratio_x) < integer_snap_tolerance) {
            computed_width = rounded_ratio_x * (double)expected_width;
        }
    }
    if (expected_height > 0u && computed_height > 0.0) {
        double scale_ratio_y = computed_height / (double)expected_height;
        double rounded_ratio_y = floor(scale_ratio_y + 0.5);
        if (rounded_ratio_y >= 1.0 && fabs(scale_ratio_y - rounded_ratio_y) < integer_snap_tolerance) {
            computed_height = rounded_ratio_y * (double)expected_height;
        }
    }
    if (computed_width <= 0.0 || computed_height <= 0.0) {
        free_bias_buffers();
        return false;
    }
    u64 rotation_width = (u64)(computed_width + 0.5);
    u64 rotation_height = (u64)(computed_height + 0.5);
    if (!rotation_width || !rotation_height) {
        free_bias_buffers();
        return false;
    }
    if (rotation_width > 0xFFFFFFFFull || rotation_height > 0xFFFFFFFFull) {
        free_bias_buffers();
        return false;
    }
    double rotation_margin = compute_rotation_margin_from_geometry((unsigned)rotation_width,
                                                                   (unsigned)rotation_height,
                                                                   rotation_degrees,
                                                                   (unsigned)image_width,
                                                                   (unsigned)image_height);

    // Fit full affine transform (logical -> image) from fiducial centers.
    // We solve two independent least-squares systems:
    //   X = a00 * x + a01 * y + tx
    //   Y = a10 * x + a11 * y + ty
    // where (x, y) are logical coordinates and (X, Y) are measured centers.
    auto solve_linear3 = [](double m[3][3], double b[3], double& r0, double& r1, double& r2) -> bool {
        double a[3][4] = {
            {m[0][0], m[0][1], m[0][2], b[0]},
            {m[1][0], m[1][1], m[1][2], b[1]},
            {m[2][0], m[2][1], m[2][2], b[2]},
        };
        for (int col = 0; col < 3; ++col) {
            int pivot = col;
            double pivot_val = fabs(a[pivot][col]);
            for (int row = col + 1; row < 3; ++row) {
                double v = fabs(a[row][col]);
                if (v > pivot_val) {
                    pivot = row;
                    pivot_val = v;
                }
            }
            if (pivot_val < 1e-12) {
                return false;
            }
            if (pivot != col) {
                for (int k = col; k < 4; ++k) {
                    double tmp = a[col][k];
                    a[col][k] = a[pivot][k];
                    a[pivot][k] = tmp;
                }
            }
            double inv = 1.0 / a[col][col];
            for (int k = col; k < 4; ++k) {
                a[col][k] *= inv;
            }
            for (int row = 0; row < 3; ++row) {
                if (row == col) continue;
                double factor = a[row][col];
                for (int k = col; k < 4; ++k) {
                    a[row][k] -= factor * a[col][k];
                }
            }
        }
        r0 = a[0][3];
        r1 = a[1][3];
        r2 = a[2][3];
        return true;
    };

    if (out_affine) {
        double Sxx = 0.0, Syy = 0.0, Sxy = 0.0;
        double Sx = 0.0, Sy = 0.0;
        double SX = 0.0, SY = 0.0;
        double SxX = 0.0, SyX = 0.0, SxY = 0.0, SyY = 0.0;
        for (u32 row = 0u; row < fiducial_rows; ++row) {
            double logical_y = logical_row_value(row);
            for (u32 col = 0u; col < fiducial_columns; ++col) {
                double logical_x = logical_column_value(col);
                usize idx = (usize)row * (usize)fiducial_columns + (usize)col;
                double px = centers_x[idx];
                double py = centers_y[idx];
                Sxx += logical_x * logical_x;
                Syy += logical_y * logical_y;
                Sxy += logical_x * logical_y;
                Sx += logical_x;
                Sy += logical_y;
                SX += px;
                SY += py;
                SxX += logical_x * px;
                SyX += logical_y * px;
                SxY += logical_x * py;
                SyY += logical_y * py;
            }
        }
        double M[3][3] = {
            {Sxx, Sxy, Sx},
            {Sxy, Syy, Sy},
            {Sx,  Sy,  (double)point_count},
        };
        double bx[3] = {SxX, SyX, SX};
        double by[3] = {SxY, SyY, SY};
        double a00, a01, tx;
        double a10, a11, ty;
        bool ok_x = solve_linear3(M, bx, a00, a01, tx);
        bool ok_y = solve_linear3(M, by, a10, a11, ty);
        if (ok_x && ok_y) {
            out_affine->a00 = a00;
            out_affine->a01 = a01;
            out_affine->a10 = a10;
            out_affine->a11 = a11;
            out_affine->tx = tx;
            out_affine->ty = ty;
        }
    }

    free_bias_buffers();
    out_degrees = rotation_degrees;
    out_rotation_width = rotation_width;
    out_rotation_height = rotation_height;
    out_margin = rotation_margin;
    return true;
}

static bool sample_fiducial_centers(const u8* pixel_data,
                                    u64 width,
                                    u64 height,
                                    u32 fiducial_columns,
                                    u32 fiducial_rows,
                                    double fiducial_margin,
                                    double fiducial_size_value,
                                    u64 expected_width,
                                    u64 expected_height,
                                    double*& centers_x_out,
                                    double*& centers_y_out) {
    if (!pixel_data || !width || !height || !fiducial_columns || !fiducial_rows) {
        return false;
    }
    usize point_count = (usize)fiducial_columns * (usize)fiducial_rows;
    if (point_count == 0u) {
        return false;
    }
    double* centers_x = (double*)malloc(point_count * sizeof(double));
    double* centers_y = (double*)malloc(point_count * sizeof(double));
    if (!centers_x || !centers_y) {
        if (centers_x) free(centers_x);
        if (centers_y) free(centers_y);
        return false;
    }
    double scale_x_est = (expected_width > 0u) ? ((double)width / (double)expected_width) : 1.0;
    double scale_y_est = (expected_height > 0u) ? ((double)height / (double)expected_height) : 1.0;
    double scale_est = (scale_x_est > 0.0 && scale_y_est > 0.0)
                           ? ((scale_x_est + scale_y_est) * 0.5)
                           : 1.0;
    if (scale_est < 1.0) {
        scale_est = 1.0;
    }
    double margin_pixels = (fiducial_margin >= 0.0) ? (fiducial_margin * scale_est) : 0.0;
    double min_x = margin_pixels;
    double max_x = (width > 0u) ? ((double)(width - 1u) - margin_pixels) : 0.0;
    if (max_x < min_x) {
        max_x = min_x;
    }
    double min_y = margin_pixels;
    double max_y = (height > 0u) ? ((double)(height - 1u) - margin_pixels) : 0.0;
    if (max_y < min_y) {
        max_y = min_y;
    }
    double fiducial_size_pixels = (fiducial_size_value > 0.0) ? fiducial_size_value : 1.0;
    fiducial_size_pixels *= scale_est;
    // Keep the fiducial search radius tight so nearby dark structures (e.g., metadata tile)
    // do not bias the fiducial center estimate.
    double search_radius_d = fiducial_size_pixels * 1.5 + 4.0 * scale_est;
    if (search_radius_d < 6.0) {
        search_radius_d = 6.0;
    }
    u32 search_radius = (u32)(search_radius_d + 0.5);
    if (search_radius < 6u) {
        search_radius = 6u;
    }
    double inv_radius_sq = 1.0 / ((double)search_radius * (double)search_radius + 1.0);
    u64 pixel_count = width * height;
    u64 total_bytes = pixel_count * 3u;

    // Avoid biasing fiducial sampling with the metadata tile region.
    bool exclude_tile = false;
    int tile_x0 = 0;
    int tile_y0 = 0;
    int tile_x1 = 0;
    int tile_y1 = 0;
    const char* disable_tile_env = getenv("MAKO_DISABLE_METADATA_TILE");
    if (!(disable_tile_env && disable_tile_env[0]) &&
        expected_width <= 0xFFFFFFFFull &&
        expected_height <= 0xFFFFFFFFull &&
        expected_width >= (u64)MetadataTile::TILE_SIDE &&
        expected_height >= (u64)MetadataTile::TILE_SIDE) {
        MetadataTile::Placement placement = MetadataTile::compute_tile_placement((u32)expected_width, (u32)expected_height);
        if (placement.valid) {
            tile_x0 = (int)floor((double)placement.x0 * scale_x_est);
            tile_y0 = (int)floor((double)placement.y0 * scale_y_est);
            tile_x1 = (int)ceil((double)(placement.x0 + MetadataTile::TILE_SIDE) * scale_x_est);
            tile_y1 = (int)ceil((double)(placement.y0 + MetadataTile::TILE_SIDE) * scale_y_est);
            if (tile_x0 < 0) tile_x0 = 0;
            if (tile_y0 < 0) tile_y0 = 0;
            if (tile_x1 > (int)width) tile_x1 = (int)width;
            if (tile_y1 > (int)height) tile_y1 = (int)height;
            exclude_tile = (tile_x1 > tile_x0) && (tile_y1 > tile_y0);
        }
    }

    double min_intensity = 255.0;
    double max_intensity = 0.0;
    if (pixel_count > 0u) {
        u64 sample_stride = (pixel_count / 16384u) ? (pixel_count / 16384u) : 1u;
        for (u64 idx = 0u; idx < pixel_count; idx += sample_stride) {
            u64 pixel_index = idx * 3u;
            if ((pixel_index + 2u) >= total_bytes) {
                break;
            }
            if (exclude_tile) {
                u64 py = idx / width;
                u64 px = idx - py * width;
                if ((int)px >= tile_x0 && (int)px < tile_x1 && (int)py >= tile_y0 && (int)py < tile_y1) {
                    continue;
                }
            }
            double intensity = ((double)pixel_data[pixel_index + 0u] +
                                (double)pixel_data[pixel_index + 1u] +
                                (double)pixel_data[pixel_index + 2u]) / 3.0;
            if (intensity < min_intensity) {
                min_intensity = intensity;
            }
            if (intensity > max_intensity) {
                max_intensity = intensity;
            }
        }
    }
    double dynamic_range = max_intensity - min_intensity;
    if (dynamic_range < 1.0) {
        dynamic_range = 1.0;
    }
    double dark_threshold = min_intensity + dynamic_range * 0.20;
    double bright_threshold = max_intensity - dynamic_range * 0.20;
    if (bright_threshold <= dark_threshold) {
        double mid = (min_intensity + max_intensity) * 0.5;
        dark_threshold = mid - 5.0;
        bright_threshold = mid + 5.0;
    }
    if (dark_threshold < 0.0) {
        dark_threshold = 0.0;
    }
    if (bright_threshold > 255.0) {
        bright_threshold = 255.0;
    }

    for (u32 row_index = 0u; row_index < fiducial_rows; ++row_index) {
        double t_row = (fiducial_rows == 1u) ? 0.5 : ((double)row_index / (double)(fiducial_rows - 1u));
        double approx_y = min_y + (max_y - min_y) * t_row;
        for (u32 col_index = 0u; col_index < fiducial_columns; ++col_index) {
            double t_col = (fiducial_columns == 1u) ? 0.5 : ((double)col_index / (double)(fiducial_columns - 1u));
            double approx_x = min_x + (max_x - min_x) * t_col;
            double center_x = approx_x;
            double center_y = approx_y;
            double bright_w = 0.0;
            double bright_x = 0.0;
            double bright_y = 0.0;
            double dark_w = 0.0;
            double dark_x = 0.0;
            double dark_y = 0.0;
            int y_start = (int)(approx_y) - (int)search_radius;
            int y_end = (int)(approx_y) + (int)search_radius;
            if (y_start < 0) {
                y_start = 0;
            }
            if (y_end >= (int)height) {
                y_end = (int)height - 1;
            }
            int x_start = (int)(approx_x) - (int)search_radius;
            int x_end = (int)(approx_x) + (int)search_radius;
            if (x_start < 0) {
                x_start = 0;
            }
            if (x_end >= (int)width) {
                x_end = (int)width - 1;
            }
            for (int sample_y_idx = y_start; sample_y_idx <= y_end; ++sample_y_idx) {
                for (int sample_x_idx = x_start; sample_x_idx <= x_end; ++sample_x_idx) {
                    if (exclude_tile &&
                        sample_x_idx >= tile_x0 && sample_x_idx < tile_x1 &&
                        sample_y_idx >= tile_y0 && sample_y_idx < tile_y1) {
                        continue;
                    }
                    usize sample_index = ((usize)sample_y_idx * (usize)width + (usize)sample_x_idx) * 3u;
                    u32 r_val = pixel_data[sample_index + 0u];
                    u32 g_val = pixel_data[sample_index + 1u];
                    u32 b_val = pixel_data[sample_index + 2u];
                    double intensity = ((double)r_val + (double)g_val + (double)b_val) / 3.0;
                    if (intensity <= dark_threshold) {
                        double weight = (dark_threshold - intensity) + 1.0;
                        double dx = (double)sample_x_idx - approx_x;
                        double dy = (double)sample_y_idx - approx_y;
                        double distance_sq = dx * dx + dy * dy;
                        double falloff = 1.0 / (1.0 + distance_sq * inv_radius_sq);
                        weight *= falloff;
                        dark_w += weight;
                        dark_x += weight * (double)sample_x_idx;
                        dark_y += weight * (double)sample_y_idx;
                    } else if (intensity >= bright_threshold) {
                        double weight = (intensity - bright_threshold) + 1.0;
                        double dx = (double)sample_x_idx - approx_x;
                        double dy = (double)sample_y_idx - approx_y;
                        double distance_sq = dx * dx + dy * dy;
                        double falloff = 1.0 / (1.0 + distance_sq * inv_radius_sq);
                        weight *= falloff;
                        bright_w += weight;
                        bright_x += weight * (double)sample_x_idx;
                        bright_y += weight * (double)sample_y_idx;
                    }
                }
            }
            // Fiducials are rendered as bright markers; prefer bright cluster centers.
            if (bright_w > 0.0) {
                center_x = bright_x / bright_w;
                center_y = bright_y / bright_w;
            } else if (dark_w > 0.0) {
                center_x = dark_x / dark_w;
                center_y = dark_y / dark_w;
            }
            usize point_index = (usize)row_index * (usize)fiducial_columns + (usize)col_index;
            centers_x[point_index] = center_x;
            centers_y[point_index] = center_y;
        }
    }
    centers_x_out = centers_x;
    centers_y_out = centers_y;
    return true;
}

static u64 detect_horizontal_scale_similarity(const u8* pixels, u64 width, u64 height) {
    if (!pixels || width == 0u || height == 0u) {
        return 1u;
    }
    u64 row_limit = (height < 256u) ? height : 256u;
    u64 scale = 0u;
    for (u64 row = 0u; row < row_limit; ++row) {
        const u8* row_ptr = pixels + (row * width * 3u);
        u64 run = 1u;
        for (u64 col = 1u; col < width; ++col) {
            const u8* current = row_ptr + col * 3u;
            const u8* previous = row_ptr + (col - 1u) * 3u;
            if (rgb_within_tolerance(current, previous, 6u)) {
                ++run;
            } else {
                scale = scale ? gcd_u64(scale, run) : run;
                run = 1u;
            }
            if (scale == 1u) {
                return 1u;
            }
        }
        scale = scale ? gcd_u64(scale, run) : run;
        if (scale == 1u) {
            return 1u;
        }
    }
    if (!scale || scale > width || scale == width) {
        return 1u;
    }
    if ((width % scale) != 0u) {
        scale = gcd_u64(scale, width);
        if (!scale || (width % scale) != 0u) {
            return 1u;
        }
    }
    return scale ? scale : 1u;
}

static u64 detect_vertical_scale_similarity(const u8* pixels, u64 width, u64 height) {
    if (!pixels || width == 0u || height == 0u) {
        return 1u;
    }
    u64 column_limit = (width < 256u) ? width : 256u;
    u64 row_limit = (height < 256u) ? height : 256u;
    u64 scale = 0u;
    for (u64 col = 0u; col < column_limit; ++col) {
        u64 run = 1u;
        for (u64 row = 1u; row < row_limit; ++row) {
            const u8* current = pixels + (row * width + col) * 3u;
            const u8* previous = pixels + ((row - 1u) * width + col) * 3u;
            if (rgb_within_tolerance(current, previous, 6u)) {
                ++run;
            } else {
                scale = scale ? gcd_u64(scale, run) : run;
                run = 1u;
            }
            if (scale == 1u) {
                return 1u;
            }
        }
        scale = scale ? gcd_u64(scale, run) : run;
        if (scale == 1u) {
            return 1u;
        }
    }
    if (!scale || scale > height || scale == height) {
        return 1u;
    }
    if ((height % scale) != 0u) {
        scale = gcd_u64(scale, height);
        if (!scale || (height % scale) != 0u) {
            return 1u;
        }
    }
    return scale ? scale : 1u;
}

static bool map_rgb_to_detection_sample(u8 color_mode,
                                        const ImageMappingConfig* mapping,
                                        const u8* rgb,
                                        u32* sample_out) {
    if (!rgb || !sample_out) {
        return false;
    }
    if (mapping && mapping_has_custom_palette(*mapping)) {
        u32 symbol = 0u;
        if (!map_rgb_to_custom_symbol(*mapping, rgb, symbol)) {
            return false;
        }
        *sample_out = symbol;
        return true;
    }
    return map_rgb_to_samples(color_mode, rgb, sample_out);
}

static u64 detect_horizontal_scale_palette(const u8* pixels,
                                           u64 width,
                                           u64 height,
                                           u8 color_mode,
                                           const ImageMappingConfig* mapping) {
    if (!pixels || width < 2u || height == 0u) {
        return 1u;
    }
    u8 effective_color_mode = color_mode;
    if (mapping && mapping_has_custom_palette(*mapping)) {
        effective_color_mode = CUSTOM_PALETTE_SYNTHETIC_COLOR_MODE;
    }
    if (effective_color_mode == 0u || effective_color_mode > 3u) {
        return 1u;
    }
    u64 row_limit = (height < 256u) ? height : 256u;
    u64 scale = 0u;
    u64 run_support = 0u;
    for (u64 row = 0u; row < row_limit; ++row) {
        const u8* row_ptr = pixels + (row * width * 3u);
        u32 prev_sample = 0u;
        if (!map_rgb_to_detection_sample(color_mode, mapping, row_ptr, &prev_sample)) {
            continue;
        }
        u64 run_length = 1u;
        bool row_ok = true;
        for (u64 col = 1u; col < width; ++col) {
            const u8* pixel_ptr = row_ptr + col * 3u;
            u32 current_sample = 0u;
            if (!map_rgb_to_detection_sample(color_mode, mapping, pixel_ptr, &current_sample)) {
                row_ok = false;
                break;
            }
            if (current_sample == prev_sample) {
                ++run_length;
                continue;
            }
            if (run_length > 1u && run_length < width) {
                scale = scale ? gcd_u64(scale, run_length) : run_length;
                ++run_support;
                if (scale == 1u) {
                    return 1u;
                }
            }
            prev_sample = current_sample;
            run_length = 1u;
        }
        if (!row_ok) {
            continue;
        }
        if (run_length > 1u && run_length < width) {
            scale = scale ? gcd_u64(scale, run_length) : run_length;
            ++run_support;
            if (scale == 1u) {
                return 1u;
            }
        }
    }
    if (scale > 1u && run_support >= 4u) {
        if ((width % scale) != 0u) {
            scale = gcd_u64(scale, width);
        }
        if (scale > 1u && (width % scale) == 0u) {
            return scale;
        }
    }
    return 1u;
}

static u64 detect_vertical_scale_palette(const u8* pixels,
                                         u64 width,
                                         u64 height,
                                         u8 color_mode,
                                         const ImageMappingConfig* mapping) {
    if (!pixels || width == 0u || height < 2u) {
        return 1u;
    }
    u8 effective_color_mode = color_mode;
    if (mapping && mapping_has_custom_palette(*mapping)) {
        effective_color_mode = CUSTOM_PALETTE_SYNTHETIC_COLOR_MODE;
    }
    if (effective_color_mode == 0u || effective_color_mode > 3u) {
        return 1u;
    }
    u64 column_limit = (width < 256u) ? width : 256u;
    u64 row_limit = (height < 256u) ? height : 256u;
    u64 scale = 0u;
    u64 run_support = 0u;
    for (u64 col = 0u; col < column_limit; ++col) {
        u32 prev_sample = 0u;
        const u8* first_pixel = pixels + (col * 3u);
        if (!map_rgb_to_detection_sample(color_mode, mapping, first_pixel, &prev_sample)) {
            continue;
        }
        u64 run_length = 1u;
        bool column_ok = true;
        for (u64 row = 1u; row < row_limit; ++row) {
            const u8* pixel_ptr = pixels + ((row * width + col) * 3u);
            u32 current_sample = 0u;
            if (!map_rgb_to_detection_sample(color_mode, mapping, pixel_ptr, &current_sample)) {
                column_ok = false;
                break;
            }
            if (current_sample == prev_sample) {
                ++run_length;
                continue;
            }
            if (run_length > 1u && run_length < height) {
                scale = scale ? gcd_u64(scale, run_length) : run_length;
                ++run_support;
                if (scale == 1u) {
                    return 1u;
                }
            }
            prev_sample = current_sample;
            run_length = 1u;
        }
        if (!column_ok) {
            continue;
        }
        if (run_length > 1u && run_length < height) {
            scale = scale ? gcd_u64(scale, run_length) : run_length;
            ++run_support;
            if (scale == 1u) {
                return 1u;
            }
        }
    }
    if (scale > 1u && run_support >= 4u) {
        if ((height % scale) != 0u) {
            scale = gcd_u64(scale, height);
        }
        if (scale > 1u && (height % scale) == 0u) {
            return scale;
        }
    }
    return 1u;
}

static u64 detect_horizontal_scale(const u8* pixels,
                                   u64 width,
                                   u64 height,
                                   u8 color_mode,
                                   const ImageMappingConfig* mapping) {
    if (!pixels || width == 0u || height == 0u) {
        return 1u;
    }
    u64 palette_scale = detect_horizontal_scale_palette(pixels, width, height, color_mode, mapping);
    if (palette_scale > 1u) {
        return palette_scale;
    }
    return detect_horizontal_scale_similarity(pixels, width, height);
}

static u64 detect_vertical_scale(const u8* pixels,
                                 u64 width,
                                 u64 height,
                                 u8 color_mode,
                                 const ImageMappingConfig* mapping) {
    if (!pixels || width == 0u || height == 0u) {
        return 1u;
    }
    u64 palette_scale = detect_vertical_scale_palette(pixels, width, height, color_mode, mapping);
    if (palette_scale > 1u) {
        return palette_scale;
    }
    return detect_vertical_scale_similarity(pixels, width, height);
}

static bool validate_integer_scale(const u8* pixels,
                                   u64 width,
                                   u64 height,
                                   u64 scale_x,
                                   u64 scale_y,
                                   u8 color_mode,
                                   const ImageMappingConfig* mapping) {
    if (!pixels || width == 0u || height == 0u) {
        return false;
    }
    if (scale_x <= 1u && scale_y <= 1u) {
        return true;
    }
    if (scale_x == 0u || scale_y == 0u) {
        return false;
    }
    if ((width % scale_x) != 0u || (height % scale_y) != 0u) {
        return false;
    }
    u8 effective_color_mode = color_mode;
    if (mapping && mapping_has_custom_palette(*mapping)) {
        effective_color_mode = CUSTOM_PALETTE_SYNTHETIC_COLOR_MODE;
    }
    if (effective_color_mode == 0u || effective_color_mode > 3u) {
        return false;
    }
    u64 logical_width = width / scale_x;
    u64 logical_height = height / scale_y;
    for (u64 logical_row = 0u; logical_row < logical_height; ++logical_row) {
        u64 base_row = logical_row * scale_y;
        for (u64 logical_col = 0u; logical_col < logical_width; ++logical_col) {
            u64 base_col = logical_col * scale_x;
            const u8* origin = pixels + ((base_row * width) + base_col) * 3u;
            u32 reference_sample = 0u;
            if (!map_rgb_to_detection_sample(color_mode, mapping, origin, &reference_sample)) {
                return false;
            }
            for (u64 dy = 0u; dy < scale_y; ++dy) {
                u64 row_index = base_row + dy;
                if (row_index >= height) {
                    return false;
                }
                const u8* row_ptr = pixels + ((row_index * width) + base_col) * 3u;
                for (u64 dx = 0u; dx < scale_x; ++dx) {
                    const u8* sample = row_ptr + dx * 3u;
                    u32 sample_value = 0u;
                    if (!map_rgb_to_detection_sample(color_mode, mapping, sample, &sample_value)) {
                        return false;
                    }
                    if (sample_value != reference_sample) {
                        return false;
                    }
                }
            }
        }
    }
    return true;
}

static bool ppm_extract_frame_bits(const makocode::ByteBuffer& input,
                                   const ImageMappingConfig& overrides,
                                   makocode::ByteBuffer& frame_bits,
                                   u64& frame_bit_count,
                                   PpmParserState& metadata_out,
                                   bool force_disable_fiducial_subgrid = false) {
    if (!input.data || input.size == 0u) {
        return false;
    }
    PpmParserState state;
   state.data = input.data;
   state.size = input.size;
    if (debug_logging_enabled()) {
        char cursor_buffer[32];
        u64_to_ascii((u64)state.cursor, cursor_buffer, sizeof(cursor_buffer));
        console_write(2, "debug initial cursor: ");
        console_line(2, cursor_buffer);
        console_write(2, "debug first bytes: ");
        for (int i = 0; i < 8 && i < (int)state.size; ++i) {
            char value_buffer[32];
            u64_to_ascii((u64)(unsigned char)state.data[i], value_buffer, sizeof(value_buffer));
            console_write(2, value_buffer);
            if (i < 7 && (i + 1) < (int)state.size) {
                console_write(2, " ");
            }
        }
        console_line(2, "");
    }
    const char* token = 0;
    usize token_length = 0u;
    if (!ppm_next_token(state, &token, &token_length)) {
        if (debug_logging_enabled()) {
            console_line(2, "debug: missing magic token");
        }
        return false;
    }
    if (!ascii_equals_token(token, token_length, "P3")) {
        if (debug_logging_enabled()) {
            char debug_token[32];
            usize debug_count = (token_length < (usize)(sizeof(debug_token) - 1u)) ? token_length : (sizeof(debug_token) - 1u);
            for (usize i = 0u; i < debug_count; ++i) {
                debug_token[i] = token[i];
            }
            debug_token[debug_count] = '\0';
            console_line(2, "debug: magic token not P3");
            console_write(2, "debug token: ");
            console_line(2, debug_token);
            char length_buffer[32];
            u64_to_ascii((u64)token_length, length_buffer, sizeof(length_buffer));
            console_write(2, "debug length: ");
            console_line(2, length_buffer);
            usize offset = (usize)(token - (const char*)state.data);
            char offset_buffer[32];
            u64_to_ascii((u64)offset, offset_buffer, sizeof(offset_buffer));
            console_write(2, "debug offset: ");
            console_line(2, offset_buffer);
        }
        return false;
    }
    if (!ppm_next_token(state, &token, &token_length)) {
        if (debug_logging_enabled()) {
            console_line(2, "debug: missing width token");
        }
        return false;
    }
    u64 width = 0u;
    if (!ascii_to_u64(token, token_length, &width) || width == 0u) {
        if (debug_logging_enabled()) {
            console_line(2, "debug: invalid width token");
        }
        return false;
    }
    if (!ppm_next_token(state, &token, &token_length)) {
        if (debug_logging_enabled()) {
            console_line(2, "debug: missing height token");
        }
        return false;
    }
    u64 height = 0u;
    if (!ascii_to_u64(token, token_length, &height) || height == 0u) {
        if (debug_logging_enabled()) {
            console_line(2, "debug: invalid height token");
        }
        return false;
    }
    if (!ppm_next_token(state, &token, &token_length)) {
        if (debug_logging_enabled()) {
            console_line(2, "debug: missing max value token");
        }
        return false;
    }
    u64 max_value = 0u;
    if (!ascii_to_u64(token, token_length, &max_value) || max_value != 255u) {
        if (debug_logging_enabled()) {
            console_line(2, "debug: invalid max value token");
        }
        return false;
    }
    u64 raw_pixel_count = width * height;
    if (raw_pixel_count == 0u) {
        return false;
    }
    makocode::ByteBuffer pixel_buffer;
    if (!ppm_read_rgb_pixels(state, raw_pixel_count, pixel_buffer)) {
        return false;
    }
    u8* pixel_data = pixel_buffer.data;
    if (!pixel_data) {
        return false;
    }
    makocode::ByteBuffer downsampled_pixels;
    const u64 base_width = width;
    const u64 base_height = height;
    // Pixel-carried metadata (preferred): 48x48 2-color metadata tile.
    const char* disable_tile_env = getenv("MAKO_DISABLE_METADATA_TILE");
    bool tile_available = false;
    MetadataTile::Values tile_values;
    makocode::ByteBuffer tile_palette_text;
    auto metadata_tile_plausible = [&](const MetadataTile::Values& values,
                                       u32 canvas_w,
                                       u32 canvas_h) -> bool {
        if (canvas_w == 0u || canvas_h == 0u) {
            return false;
        }
        u64 area = (u64)canvas_w * (u64)canvas_h;
        // Payload bits should never exceed a reasonable multiple of the image area.
        if (values.page_bits == 0u || values.page_bits > area * 64u) {
            return false;
        }
        if (values.page_count == 0u || values.page_index == 0u || values.page_index > values.page_count) {
            return false;
        }
        if (values.footer_rows > canvas_h) {
            return false;
        }
        return true;
    };
    u32 footer_rows_hint = state.has_footer_rows ? (u32)state.footer_rows_value : 0u;
    if (footer_rows_hint > (u32)height) {
        footer_rows_hint = 0u;
    }
    u32 data_height_hint = (footer_rows_hint > 0u && footer_rows_hint < (u32)height) ? ((u32)height - footer_rows_hint) : (u32)height;
    if (!(disable_tile_env && disable_tile_env[0]) && width <= 0xFFFFFFFFull && height <= 0xFFFFFFFFull) {
        // Try a few plausible data heights in case the footer height (text-only) was mis-estimated.
        const u32 fallback_offsets[] = {0u, 8u, 16u, 24u, 32u};
        for (u32 i = 0u; i < sizeof(fallback_offsets) / sizeof(fallback_offsets[0]); ++i) {
            u32 data_height_test = data_height_hint;
            if (fallback_offsets[i] < data_height_test) {
                data_height_test -= fallback_offsets[i];
            }
            MetadataTile::Placement placement = MetadataTile::compute_tile_placement((u32)width, data_height_test);
            if (!placement.valid) {
                continue;
            }
            if (MetadataTile::decode_tile(pixel_data,
                                          (u32)width,
                                          (u32)height,
                                          data_height_test,
                                          placement,
                                          tile_values,
                                          tile_palette_text)) {
                if (!metadata_tile_plausible(tile_values, (u32)width, (u32)height)) {
                    continue;
                }
                tile_available = true;
                apply_metadata_tile_metadata(state, tile_values, tile_palette_text);
                if (debug_logging_enabled()) {
                    char bits_buf[32];
                    char count_buf[32];
                    char index_buf[32];
                    u64_to_ascii(tile_values.page_bits, bits_buf, sizeof(bits_buf));
                    u64_to_ascii(tile_values.page_count, count_buf, sizeof(count_buf));
                    u64_to_ascii(tile_values.page_index, index_buf, sizeof(index_buf));
                    console_write(2, "debug metadata tile: bits=");
                    console_write(2, bits_buf);
                    console_write(2, " page=");
                    console_write(2, index_buf);
                    console_write(2, "/");
                    console_line(2, count_buf);
                }
                break;
            }
        }
    }
    // If the tile is present but the page was scaled/rotated, the axis-aligned 1px/module sampler
    // won't see it. Fall back to an affine tile decode centered near the expected location.
    if (!tile_available &&
        !(disable_tile_env && disable_tile_env[0]) &&
        width <= 0xFFFFFFFFull &&
        height <= 0xFFFFFFFFull) {
        if (debug_logging_enabled()) {
            console_line(2, "debug metadata tile: starting affine search");
        }
        MetadataTile::AffineParams found_affine = {};
        MetadataTile::AffineParams* found_ptr = debug_logging_enabled() ? &found_affine : (MetadataTile::AffineParams*)0;
        if (MetadataTile::search_decode_tile_affine(pixel_data,
                                                    (u32)width,
                                                    (u32)height,
                                                    data_height_hint,
                                                    5.0,
                                                    tile_values,
                                                    tile_palette_text,
                                                    found_ptr)) {
            if (metadata_tile_plausible(tile_values, (u32)width, (u32)height)) {
                tile_available = true;
                apply_metadata_tile_metadata(state, tile_values, tile_palette_text);
                if (found_ptr) {
                    state.has_tile_pitch = true;
                    state.tile_pitch_value = found_affine.pitch_pixels;
                }
            }
        } else if (debug_logging_enabled()) {
            console_line(2, "debug metadata tile: affine search failed");
        }
    }

    FooterStripe::Values stripe_values = {};
    bool stripe_available = false;
    if (kFooterStripeEnabled && width <= 0xFFFFFFFFull && height <= 0xFFFFFFFFull) {
        if (!tile_available) {
            stripe_available = FooterStripe::decode_v3(pixel_data, (u32)width, (u32)height, stripe_values);
            if (!stripe_available) {
                stripe_available = FooterStripe::decode(FooterStripe::SPEC_V2, pixel_data, (u32)width, (u32)height, stripe_values);
            }
            if (!stripe_available) {
                stripe_available = FooterStripe::decode(FooterStripe::SPEC_V1, pixel_data, (u32)width, (u32)height, stripe_values);
            }
            if (!stripe_available) {
                u64 logical_guess = estimate_square_page_from_image(width, height);
                if (logical_guess && logical_guess <= 0xFFFFFFFFull) {
                    AffineTransform scale_affine = {};
                    scale_affine.a00 = (double)width / (double)logical_guess;
                    scale_affine.a11 = (double)height / (double)logical_guess;
                    scale_affine.a01 = 0.0;
                    scale_affine.a10 = 0.0;
                    scale_affine.tx = 0.0;
                    scale_affine.ty = 0.0;
                    u32 footer_hint = state.has_footer_rows ? (u32)state.footer_rows_value : 0u;
                    stripe_available = FooterStripe::decode_v3_affine(pixel_data,
                                                                      (u32)width,
                                                                      (u32)height,
                                                                      scale_affine,
                                                                      0.0,
                                                                      (double)logical_guess,
                                                                      (u32)logical_guess,
                                                                      (u32)logical_guess,
                                                                      footer_hint,
                                                                      stripe_values);
                }
            }
        }
    }
    // If both metadata tile and footer stripe are missing, try a simple nearest-neighbor
    // downsample to an estimated logical square page size, then retry metadata tile decode.
        if (!tile_available && !stripe_available) {
        bool downsample_buffer_ready = false;
        u32 downsample_buffer_w = 0u;
        u32 downsample_buffer_h = 0u;
        makocode::ByteBuffer best_downsample;
        double best_downsample_score = 1e30;
        u32 best_downsample_w = 0u;
        u32 best_downsample_h = 0u;
        auto try_decode_shifted_tile = [&](const u8* pixels,
                                           u32 canvas_w,
                                           u32 canvas_h,
                                           const char* label) -> bool {
            MetadataTile::Placement placement = MetadataTile::compute_tile_placement(canvas_w, canvas_h);
            if (!placement.valid) return false;
            const int kMaxShift = 12;
            for (int dy = -kMaxShift; dy <= kMaxShift; ++dy) {
                for (int dx = -kMaxShift; dx <= kMaxShift; ++dx) {
                    MetadataTile::Placement p = placement;
                    int sx = (int)p.x0 + dx;
                    int sy = (int)p.y0 + dy;
                    if (sx < 0 || sy < 0) continue;
                    if ((u32)sx + MetadataTile::TILE_SIDE > canvas_w) continue;
                    if ((u32)sy + MetadataTile::TILE_SIDE > canvas_h) continue;
                    p.x0 = (u32)sx;
                    p.y0 = (u32)sy;
                    if (MetadataTile::decode_tile(pixels,
                                                  canvas_w,
                                                  canvas_h,
                                                  canvas_h,
                                                  p,
                                                  tile_values,
                                                  tile_palette_text)) {
                        if (!metadata_tile_plausible(tile_values, canvas_w, canvas_h)) {
                            if (debug_logging_enabled()) {
                                console_write(2, "debug metadata tile: implausible after ");
                                console_line(2, label);
                            }
                            continue;
                        }
                        if (debug_logging_enabled() && (dx != 0 || dy != 0)) {
                            console_write(2, "debug metadata tile: offset ");
                            char bdx[16], bdy[16];
                            u64_to_ascii((u64)(dx), bdx, sizeof(bdx));
                            u64_to_ascii((u64)(dy), bdy, sizeof(bdy));
                            console_write(2, bdx);
                            console_write(2, ",");
                            console_line(2, bdy);
                        }
                        return true;
                    }
                }
            }
            return false;
        };
        u64 logical_guess = estimate_square_page_from_image(base_width, base_height);
        if (debug_logging_enabled()) {
            console_write(2, "debug downsample entry guess=");
            char buf[32];
            u64_to_ascii(logical_guess, buf, sizeof(buf));
            console_line(2, buf);
        }
        auto binarize_downsampled = [&](u8* buffer, u32 target_w, u32 target_h) {
            if (!buffer || target_w == 0u || target_h == 0u) return;
            double min_l = 255.0;
            double max_l = 0.0;
            usize total_px = (usize)target_w * (usize)target_h;
            for (usize i = 0u; i < total_px; ++i) {
                u8 r = buffer[i * 3u + 0u];
                u8 g = buffer[i * 3u + 1u];
                u8 b = buffer[i * 3u + 2u];
                double l = 0.2126 * (double)r + 0.7152 * (double)g + 0.0722 * (double)b;
                if (l < min_l) min_l = l;
                if (l > max_l) max_l = l;
            }
            if (!(max_l > min_l + 32.0)) {
                return;
            }
            double threshold = (min_l + max_l) * 0.5;
            for (usize i = 0u; i < total_px; ++i) {
                u8 r = buffer[i * 3u + 0u];
                u8 g = buffer[i * 3u + 1u];
                u8 b = buffer[i * 3u + 2u];
                double l = 0.2126 * (double)r + 0.7152 * (double)g + 0.0722 * (double)b;
                u8 v = (l < threshold) ? 0u : 255u;
                buffer[i * 3u + 0u] = v;
                buffer[i * 3u + 1u] = v;
                buffer[i * 3u + 2u] = v;
            }
        };
        auto fill_downsample = [&](u32 target_w, u32 target_h) -> bool {
            if (!downsampled_pixels.ensure((usize)target_w * (usize)target_h * 3u)) {
                return false;
            }
            downsampled_pixels.size = (usize)target_w * (usize)target_h * 3u;
            for (u32 y = 0u; y < target_h; ++y) {
                double y0 = ((double)y * (double)base_height) / (double)target_h;
                double y1 = ((double)(y + 1u) * (double)base_height) / (double)target_h;
                u32 iy0 = (u32)floor(y0);
                u32 iy1 = (u32)ceil(y1);
                if (iy1 > base_height) iy1 = (u32)base_height;
                for (u32 x = 0u; x < target_w; ++x) {
                    double x0 = ((double)x * (double)base_width) / (double)target_w;
                    double x1 = ((double)(x + 1u) * (double)base_width) / (double)target_w;
                    u32 ix0 = (u32)floor(x0);
                    u32 ix1 = (u32)ceil(x1);
                    if (ix1 > base_width) ix1 = (u32)base_width;
                    u64 sum_r = 0u, sum_g = 0u, sum_b = 0u;
                    u64 count = 0u;
                    for (u32 sy = iy0; sy < iy1; ++sy) {
                        double cy = (double)sy + 0.5;
                        if (cy < y0 || cy >= y1) continue;
                        for (u32 sx = ix0; sx < ix1; ++sx) {
                            double cx = (double)sx + 0.5;
                            if (cx < x0 || cx >= x1) continue;
                            usize src_idx = ((usize)sy * (usize)base_width + (usize)sx) * 3u;
                            sum_r += (u64)pixel_buffer.data[src_idx + 0u];
                            sum_g += (u64)pixel_buffer.data[src_idx + 1u];
                            sum_b += (u64)pixel_buffer.data[src_idx + 2u];
                            ++count;
                        }
                    }
                    if (count == 0u) {
                        count = 1u;
                    }
                    usize dst_idx = ((usize)y * (usize)target_w + (usize)x) * 3u;
                    downsampled_pixels.data[dst_idx + 0u] = (u8)((sum_r + (count / 2u)) / count);
                    downsampled_pixels.data[dst_idx + 1u] = (u8)((sum_g + (count / 2u)) / count);
                    downsampled_pixels.data[dst_idx + 2u] = (u8)((sum_b + (count / 2u)) / count);
                }
            }
            binarize_downsampled(downsampled_pixels.data, target_w, target_h);
            return true;
        };
        auto attempt_downsample = [&](u32 target_w, u32 target_h, const char* label) -> bool {
            if (target_w < MetadataTile::TILE_SIDE || target_h < MetadataTile::TILE_SIDE) {
                return false;
            }
            if (!fill_downsample(target_w, target_h)) {
                return false;
            }
            downsample_buffer_ready = true;
            downsample_buffer_w = target_w;
            downsample_buffer_h = target_h;
            double candidate_score = fabs((double)target_w - (double)target_h);
            if (logical_guess > 0u) {
                double lg = (double)logical_guess;
                candidate_score += fabs((double)target_w - lg) * 0.5;
            }
            if (candidate_score < best_downsample_score &&
                best_downsample.ensure((usize)target_w * (usize)target_h * 3u)) {
                best_downsample.size = (usize)target_w * (usize)target_h * 3u;
                memcpy(best_downsample.data, downsampled_pixels.data, best_downsample.size);
                best_downsample_score = candidate_score;
                best_downsample_w = target_w;
                best_downsample_h = target_h;
                downsample_buffer_w = target_w;
                downsample_buffer_h = target_h;
            }
            if (try_decode_shifted_tile(downsampled_pixels.data, target_w, target_h, label)) {
                pixel_data = downsampled_pixels.data;
                width = target_w;
                height = target_h;
                data_height_hint = target_h;
                tile_available = true;
                apply_metadata_tile_metadata(state, tile_values, tile_palette_text);
                if (debug_logging_enabled()) {
                    console_write(2, "debug metadata tile: decoded after ");
                    console_line(2, label);
                }
                return true;
            }
            return false;
        };
        if (logical_guess > 0u && logical_guess < base_width && logical_guess < base_height) {
            u32 target_w = (u32)logical_guess;
            u32 target_h = (u32)logical_guess;
            if (target_w >= MetadataTile::TILE_SIDE && target_h >= MetadataTile::TILE_SIDE) {
                if (attempt_downsample(target_w, target_h, "logical downsample")) {
                    if (debug_logging_enabled()) {
                        console_write(2, "debug downsample logical guess=");
                        char guess_buf[32];
                        u64_to_ascii(logical_guess, guess_buf, sizeof(guess_buf));
                        console_line(2, guess_buf);
                    }
                }
            }
        }
        // Sweep around the best logical guess to catch non-integer scale factors (e.g., 3.03x upscales)
        // before falling back to coarse factor guesses.
        if (!tile_available && logical_guess > 0u) {
            u32 sweep_min = logical_guess > 0u ? (u32)((logical_guess * 60ull) / 100ull) : MetadataTile::TILE_SIDE;
            u32 sweep_max = logical_guess > 0u ? (u32)((logical_guess * 115ull) / 100ull) : (u32)base_width;
            if (sweep_min < MetadataTile::TILE_SIDE) sweep_min = MetadataTile::TILE_SIDE;
            if (sweep_max > base_width) sweep_max = (u32)base_width;
            for (u32 target_w = sweep_min; target_w <= sweep_max && !tile_available; target_w += 20u) {
                if (target_w > base_height) break;
                if (debug_logging_enabled()) {
                    console_write(2, "debug downsample sweep size=");
                    char bufw[32];
                    u64_to_ascii(target_w, bufw, sizeof(bufw));
                    console_line(2, bufw);
                }
                attempt_downsample(target_w, target_w, "logical sweep");
            }
        }
        // Try simple downsample factors (integer and common fractional) when guessing fails to reveal metadata.
        if (!tile_available) {
            const double factors[] = {1.75, 2.0, 2.25, 2.4, 2.5, 2.6, 2.75, 3.0};
            bool factor_success = false;
            for (u32 fx = 0u; fx < sizeof(factors) / sizeof(factors[0]); ++fx) {
                for (u32 fy = 0u; fy < sizeof(factors) / sizeof(factors[0]); ++fy) {
                    double factor_x = factors[fx];
                    double factor_y = factors[fy];
                    if (factor_x <= 1.0 || factor_y <= 1.0) continue;
                    u32 target_w = (u32)floor(((double)base_width / factor_x) + 0.5);
                    u32 target_h = (u32)floor(((double)base_height / factor_y) + 0.5);
                    if (debug_logging_enabled()) {
                        console_write(2, "debug downsample factor attempt=");
                        char bufx[32], bufy[32];
                        u64_to_ascii((u64)(factor_x * 100.0 + 0.5), bufx, sizeof(bufx));
                        u64_to_ascii((u64)(factor_y * 100.0 + 0.5), bufy, sizeof(bufy));
                        console_write(2, bufx);
                        console_write(2, "/");
                        console_line(2, bufy);
                    }
                    if (attempt_downsample(target_w, target_h, "factor downsample")) {
                        factor_success = true;
                        break;
                    }
                }
                if (factor_success) break;
            }
        }
        if (!tile_available && downsample_buffer_ready) {
            u8* chosen = downsampled_pixels.data;
            if (best_downsample.size > 0u && best_downsample.data) {
                chosen = best_downsample.data;
                pixel_data = chosen;
                width = best_downsample_w ? best_downsample_w : downsample_buffer_w;
                height = best_downsample_h ? best_downsample_h : downsample_buffer_h;
                data_height_hint = height;
            } else {
                pixel_data = chosen;
                width = downsample_buffer_w;
                height = downsample_buffer_h;
                data_height_hint = downsample_buffer_h;
            }
        }
        // If metadata was found via downsample, revert to full-resolution pixels for payload sampling.
        if (tile_available) {
            pixel_data = pixel_buffer.data;
            width = base_width;
            height = base_height;
            data_height_hint = (u32)((state.has_footer_rows && state.footer_rows_value < base_height)
                                         ? (base_height - state.footer_rows_value)
                                         : base_height);
        }
    }
    if (stripe_available) {
        bool sane = (stripe_values.page_bits > 0u) &&
                    (stripe_values.footer_rows > 0u) &&
                    (stripe_values.page_index > 0u) &&
                    (stripe_values.page_count > 0u) &&
                    (stripe_values.page_width_pixels > 0u) &&
                    (stripe_values.page_height_pixels > 0u);
        if (!sane) {
            stripe_available = false;
        }
    }
    if (stripe_available) {
        state.has_footer_stripe = true;
        state.footer_stripe_values = stripe_values;
        apply_footer_stripe_metadata(state, stripe_values);
        if (debug_logging_enabled()) {
            console_write(2, "debug footer stripe: ecc=");
            console_write(2, stripe_values.ecc_enabled ? "1" : "0");
            console_write(2, " block_data=");
            char buf_block[32];
            char buf_parity[32];
            char buf_blocks[32];
            char buf_orig[32];
            u64_to_ascii((u64)stripe_values.ecc_block_data, buf_block, sizeof(buf_block));
            u64_to_ascii((u64)stripe_values.ecc_parity, buf_parity, sizeof(buf_parity));
            u64_to_ascii(stripe_values.ecc_block_count, buf_blocks, sizeof(buf_blocks));
            u64_to_ascii(stripe_values.ecc_original_bytes, buf_orig, sizeof(buf_orig));
            console_write(2, buf_block);
            console_write(2, " parity=");
            console_write(2, buf_parity);
            console_write(2, " blocks=");
            console_write(2, buf_blocks);
            console_write(2, " orig=");
            console_line(2, buf_orig);
        }
    } else if (!tile_available) {
        // No metadata tile (and footer stripes are disabled): cannot recover layout.
        if (debug_logging_enabled() && pixel_buffer.data && base_width <= 0xFFFFFFFFull && base_height <= 0xFFFFFFFFull) {
            u32 base_data_height = (u32)((state.has_footer_rows && state.footer_rows_value < base_height)
                                             ? (base_height - state.footer_rows_value)
                                             : base_height);
            debug_probe_metadata_tile_affine(pixel_buffer.data, (u32)base_width, (u32)base_height, base_data_height);
        }
        console_line(1, "decode: metadata tile missing; aborting (no metadata available)");
        return 1;
    }
    if (!state.has_footer_rows && !tile_available && !stripe_available) {
        auto row_black_count = [&](u64 row_index) -> u64 {
            if (!pixel_data || row_index >= height || width == 0u) return 0u;
            u64 count = 0u;
            const u8* row_ptr = pixel_data + ((usize)row_index * (usize)width) * 3u;
            for (u64 col = 0u; col < width; ++col) {
                u8 r = row_ptr[col * 3u + 0u];
                u8 g = row_ptr[col * 3u + 1u];
                u8 b = row_ptr[col * 3u + 2u];
                // Simple luminance threshold at mid-range.
                if ((u16)r * 2126u + (u16)g * 7152u + (u16)b * 722u < 1280000u) {
                    ++count;
                }
            }
            return count;
        };
        double mid_sum = 0.0;
        u64 mid_rows = 0u;
        u64 mid_start = height / 4u;
        u64 mid_end = (height * 3u) / 4u;
        for (u64 row = mid_start; row < mid_end && row < height; ++row) {
            mid_sum += (double)row_black_count(row);
            ++mid_rows;
        }
        if (mid_rows > 0u) {
            double mid_mean = mid_sum / (double)mid_rows;
            u64 footer_guess = 0u;
            for (u64 row = height; row-- > 0u;) {
                u64 black = row_black_count(row);
                if (black < mid_mean * 0.6) {
                    ++footer_guess;
                } else {
                    break;
                }
                if (footer_guess >= 256u) {
                    break;
                }
            }
            if (footer_guess > 64u) {
                footer_guess = 64u;
            }
            if (footer_guess > 0u) {
                state.has_footer_rows = true;
                state.footer_rows_value = footer_guess;
            }
        }
        if (!state.has_footer_rows) {
            u64 fallback_footer = (height >= 256u) ? 32u : (height / 8u);
            if (fallback_footer > 0u) {
                state.has_footer_rows = true;
                state.footer_rows_value = fallback_footer;
            }
        }
    }
    // Snap obvious two-color pages to strict black/white to reduce overlay and binarization noise.
    auto binarize_monochrome_image = [&](u8* buffer, u64 w, u64 h) {
        if (!buffer || w == 0u || h == 0u) return;
        double min_l = 255.0;
        double max_l = 0.0;
        u64 pixels = w * h;
        for (u64 i = 0u; i < pixels; ++i) {
            u8 r = buffer[(usize)i * 3u + 0u];
            u8 g = buffer[(usize)i * 3u + 1u];
            u8 b = buffer[(usize)i * 3u + 2u];
            double l = 0.2126 * (double)r + 0.7152 * (double)g + 0.0722 * (double)b;
            if (l < min_l) min_l = l;
            if (l > max_l) max_l = l;
        }
        if (!(max_l > min_l + 20.0)) {
            return;
        }
        double threshold = (min_l + max_l) * 0.5;
        for (u64 i = 0u; i < pixels; ++i) {
            u8 r = buffer[(usize)i * 3u + 0u];
            u8 g = buffer[(usize)i * 3u + 1u];
            u8 b = buffer[(usize)i * 3u + 2u];
            double l = 0.2126 * (double)r + 0.7152 * (double)g + 0.0722 * (double)b;
            u8 v = (l < threshold) ? 0u : 255u;
            buffer[(usize)i * 3u + 0u] = v;
            buffer[(usize)i * 3u + 1u] = v;
            buffer[(usize)i * 3u + 2u] = v;
        }
    };
    bool has_custom_palette_text = (tile_palette_text.size > 0u) || state.has_palette_text;
    bool force_monochrome = false;
    if (tile_available && tile_values.palette_count <= 2u) {
        force_monochrome = true;
    } else if (!tile_available && !stripe_available && !has_custom_palette_text) {
        // Default palette is White/Black when no metadata or stripe is present.
        force_monochrome = true;
    }
    if (force_monochrome && pixel_data && width > 0u && height > 0u) {
        binarize_monochrome_image(pixel_data, width, height);
    }
    bool has_rotation = false;
    unsigned rotated_width = (unsigned)width;
    unsigned rotated_height = (unsigned)height;
    unsigned rotation_width = 0u;
    unsigned rotation_height = 0u;
    double rotation_margin = 4.0;
    double rotation_radians = 0.0;
    double rotation_cos = 1.0;
    double rotation_sin = 0.0;
    double rotation_center_x = 0.0;
    double rotation_center_y = 0.0;
    double rotation_offset_x = 0.0;
    double rotation_offset_y = 0.0;
    auto refresh_rotation_state = [&]() {
        has_rotation = state.has_rotation_degrees &&
                        state.rotation_degrees_value != 0.0 &&
                        state.has_rotation_width &&
                        state.has_rotation_height;
        if (has_rotation && fabs(state.rotation_degrees_value) < 0.25) {
            // Treat extremely small rotation hints as noise; they block simpler decode paths.
            state.has_rotation_degrees = false;
            state.rotation_degrees_value = 0.0;
            has_rotation = false;
        }
        if (!has_rotation) {
            rotation_width = 0u;
            rotation_height = 0u;
            rotation_margin = (state.has_rotation_margin && state.rotation_margin_value > 0.0)
                                  ? state.rotation_margin_value
                                  : 4.0;
            if (rotation_margin < 0.0) {
                rotation_margin = 0.0;
            }
            rotation_radians = 0.0;
            rotation_cos = 1.0;
            rotation_sin = 0.0;
            rotation_center_x = 0.0;
            rotation_center_y = 0.0;
            rotation_offset_x = 0.0;
            rotation_offset_y = 0.0;
            return;
        }
        rotation_width = (unsigned)state.rotation_width_value;
        rotation_height = (unsigned)state.rotation_height_value;
        rotation_margin = state.has_rotation_margin ? state.rotation_margin_value : 4.0;
        if (rotation_margin < 0.0) {
            rotation_margin = 0.0;
        }
        rotation_radians = state.rotation_degrees_value * (3.14159265358979323846 / 180.0);
        rotation_cos = cos(rotation_radians);
        rotation_sin = sin(rotation_radians);
        rotation_center_x = ((double)rotation_width - 1.0) * 0.5;
        rotation_center_y = ((double)rotation_height - 1.0) * 0.5;
        double min_x = 0.0;
        double max_x = 0.0;
        double min_y = 0.0;
        double max_y = 0.0;
        for (int i = 0; i < 4; ++i) {
            double corner_x = (i & 1) ? (double)(rotation_width - 1u) : 0.0;
            double corner_y = (i & 2) ? (double)(rotation_height - 1u) : 0.0;
            double dx = corner_x - rotation_center_x;
            double dy = corner_y - rotation_center_y;
            double rx = dx * rotation_cos - dy * rotation_sin;
            double ry = dx * rotation_sin + dy * rotation_cos;
            if (i == 0) {
                min_x = max_x = rx;
                min_y = max_y = ry;
            } else {
                if (rx < min_x) min_x = rx;
                if (rx > max_x) max_x = rx;
                if (ry < min_y) min_y = ry;
                if (ry > max_y) max_y = ry;
            }
        }
        rotation_offset_x = -min_x + rotation_margin;
        rotation_offset_y = -min_y + rotation_margin;
    };
    refresh_rotation_state();
    bool has_skew = false;
    u64 skew_src_width = 0u;
    u64 skew_src_height = 0u;
    double skew_margin = 0.0;
    double skew_top = 0.0;
    double skew_bottom = 0.0;
    auto recompute_skew_flags = [&]() {
        bool active = !state.has_affine_transform &&
                      state.has_skew_src_width &&
                      state.has_skew_src_height &&
                      ((state.has_skew_margin_x && state.has_skew_x_pixels) || state.has_skew_y_pixels);
        skew_src_width = active ? state.skew_src_width_value : 0u;
        skew_src_height = active ? state.skew_src_height_value : 0u;
        skew_margin = active ? state.skew_margin_x_value : 0.0;
        skew_top = active ? state.skew_x_pixels_value : 0.0;
        skew_bottom = active && state.has_skew_bottom_x ? state.skew_bottom_x_value : 0.0;
        if (active) {
            if (skew_src_width == 0u || skew_src_height == 0u) {
                active = false;
            }
            if (active && fabs(skew_top) < 2.0 && fabs(skew_bottom) < 2.0 &&
                (!state.has_skew_y_pixels || fabs(state.skew_y_pixels_value) < 0.5)) {
                active = false;
            }
        }
        has_skew = active;
    };
    recompute_skew_flags();
    ImageMappingConfig active_mapping = overrides;
    if (active_mapping.palette_set) {
        if (!image_mapping_build_custom_palette(active_mapping, "decode")) {
            return false;
        }
    } else if (state.has_palette_text && state.palette_text_length) {
        if (!image_mapping_set_palette_text(active_mapping,
                                            state.palette_text,
                                            state.palette_text_length,
                                            "decode")) {
            return false;
        }
        if (!image_mapping_build_custom_palette(active_mapping, "decode")) {
            return false;
        }
    }
    // Downgrade metadata-driven palettes that exactly match built-in palettes to the
    // simpler fixed modes, so we avoid the custom palette digit pipeline for
    // standard black/white or CMY(W)/RGB palettes.
    if (active_mapping.palette_set && active_mapping.custom_palette_valid) {
        auto palette_matches = [&](const PaletteColor* builtin, u32 count) -> bool {
            if (!builtin || count == 0u || active_mapping.custom_palette_count != count) {
                return false;
            }
            for (u32 i = 0u; i < count; ++i) {
                const PaletteColor& a = active_mapping.custom_palette[i];
                const PaletteColor& b = builtin[i];
                if (a.r != b.r || a.g != b.g || a.b != b.b) {
                    return false;
                }
            }
            return true;
        };
        if (palette_matches(PALETTE_GRAY, (u32)(sizeof(PALETTE_GRAY) / sizeof(PALETTE_GRAY[0])))) {
            active_mapping.color_channels = 1u;
            active_mapping.custom_palette_valid = false;
        } else if (palette_matches(PALETTE_CMYW, (u32)(sizeof(PALETTE_CMYW) / sizeof(PALETTE_CMYW[0])))) {
            active_mapping.color_channels = 2u;
            active_mapping.custom_palette_valid = false;
        } else if (palette_matches(PALETTE_RGB_CMY_WB, (u32)(sizeof(PALETTE_RGB_CMY_WB) / sizeof(PALETTE_RGB_CMY_WB[0])))) {
            active_mapping.color_channels = 3u;
            active_mapping.custom_palette_valid = false;
        }
    }
    u8 detection_color_mode = active_mapping.color_channels;
    if (detection_color_mode == 0u || detection_color_mode > 3u) {
        detection_color_mode = 1u;
    }
    double scale_x = 1.0;
    double scale_y = 1.0;
    bool scale_x_integer = true;
    bool scale_y_integer = true;
    u64 scale_x_int = 1u;
    u64 scale_y_int = 1u;
    bool width_known = false;
    bool height_known = false;
    u64 expected_width = 0u;
    u64 expected_height = 0u;
    if (overrides.page_width_set && overrides.page_width_pixels) {
        expected_width = overrides.page_width_pixels;
        width_known = true;
    } else if (state.has_page_width_pixels && state.page_width_pixels_value) {
        expected_width = state.page_width_pixels_value;
        width_known = true;
    }
    if (overrides.page_height_set && overrides.page_height_pixels) {
        expected_height = overrides.page_height_pixels;
        height_known = true;
    } else if (state.has_page_height_pixels && state.page_height_pixels_value) {
        expected_height = state.page_height_pixels_value;
        height_known = true;
    }
	    if (!width_known && !height_known) {
	        u64 inferred_width = 0u;
	        u64 inferred_height = 0u;
	        if (state.has_fiducial_col_offsets && state.fiducial_col_offset_count >= 2u) {
	            u64 last = state.fiducial_col_offsets[state.fiducial_col_offset_count - 1u];
	            if (last) {
	                inferred_width = last;
	            }
	        }
	        if (state.has_fiducial_row_offsets && state.fiducial_row_offset_count >= 2u) {
	            u64 last = state.fiducial_row_offsets[state.fiducial_row_offset_count - 1u];
	            if (last) {
	                inferred_height = last;
	                if (state.has_footer_rows && state.footer_rows_value) {
	                    inferred_height += state.footer_rows_value;
	                }
	            }
	        }
	        if (inferred_width && inferred_height) {
	            expected_width = inferred_width;
	            expected_height = inferred_height;
	            width_known = true;
	            height_known = true;
	            state.has_page_width_pixels = true;
	            state.page_width_pixels_value = inferred_width;
	            state.has_page_height_pixels = true;
	            state.page_height_pixels_value = inferred_height;
	            if (debug_logging_enabled()) {
	                char buf_w[32];
	                char buf_h[32];
	                u64_to_ascii(inferred_width, buf_w, sizeof(buf_w));
	                u64_to_ascii(inferred_height, buf_h, sizeof(buf_h));
	                console_write(2, "debug: inferred page size from fiducials ");
	                console_write(2, buf_w);
	                console_write(2, "x");
	                console_line(2, buf_h);
	            }
	        }
	    }
	    if (!width_known && !height_known) {
	        u64 guessed = estimate_square_page_from_image(width, height);
	        if (guessed) {
	            expected_width = guessed;
	            expected_height = guessed;
	            width_known = true;
	            height_known = true;
            state.has_page_width_pixels = true;
            state.page_width_pixels_value = guessed;
            state.has_page_height_pixels = true;
            state.page_height_pixels_value = guessed;
            if (debug_logging_enabled()) {
                char buf[32];
                u64_to_ascii(guessed, buf, sizeof(buf));
                console_write(2, "debug: estimated page size ");
                console_line(2, buf);
            }
        }
    }
    bool fiducial_rotation_detected = false;

struct RotationEstimateCandidate {
        bool valid;
        double angle_deg;
        u64 width;
        u64 height;
        double margin;
        bool from_fiducials;
        bool has_affine;
        AffineTransform affine;

        RotationEstimateCandidate()
            : valid(false),
              angle_deg(0.0),
              width(0u),
              height(0u),
              margin(0.0),
              from_fiducials(false),
              has_affine(false),
              affine() {}
    };

    RotationEstimateCandidate auto_candidate;
    RotationEstimateCandidate gradient_candidate;
    RotationEstimateCandidate fiducial_candidate;

    auto assign_rotation_candidate = [&](RotationEstimateCandidate& candidate,
                                         double angle,
                                         u64 width_est,
                                         u64 height_est,
                                         double margin_est,
                                         bool from_fiducials,
                                         const AffineTransform* affine_opt) {
        candidate.valid = true;
        candidate.angle_deg = angle;
        candidate.width = width_est;
        candidate.height = height_est;
        candidate.margin = margin_est;
        candidate.from_fiducials = from_fiducials;
        candidate.has_affine = (from_fiducials && affine_opt);
        if (candidate.has_affine) {
            candidate.affine = *affine_opt;
        }
    };

    auto clamp_candidate_scale = [&](RotationEstimateCandidate& candidate,
                                     u64 expected_width_px,
                                     u64 expected_height_px) {
        if (!candidate.valid || expected_width_px == 0u || expected_height_px == 0u) {
            return;
        }
        double sx = (double)candidate.width / (double)expected_width_px;
        double sy = (double)candidate.height / (double)expected_height_px;
        if (!(sx > 0.0) || !(sy > 0.0)) {
            return;
        }
        double diff = fabs(sx - sy);
        double worst = (sx > sy) ? sx : sy;
        if (worst > 0.0) {
            double rel = diff / worst;
            // Instead of discarding high anisotropy (common with rotated crops),
            // clamp both axes to the mean scale.
            if (rel > 0.03) {
                double mean = (sx + sy) * 0.5;
                candidate.width  = (u64)((double)expected_width_px  * mean + 0.5);
                candidate.height = (u64)((double)expected_height_px * mean + 0.5);
                if (candidate.width == 0u) candidate.width = 1u;
                if (candidate.height == 0u) candidate.height = 1u;
                if (debug_logging_enabled()) {
                    char rel_buf[32];
                    char mean_buf[32];
                    format_fixed_3(rel * 100.0, rel_buf, sizeof(rel_buf));
                    format_fixed_3(mean, mean_buf, sizeof(mean_buf));
                    console_write(2, "debug rotation: anisotropy ");
                    console_write(2, rel_buf);
                    console_write(2, "%; clamped scale=");
                    console_line(2, mean_buf);
                }
            }
        }
        // Snap to nearest integer magnification when close (all magnifications, not just ~1x).
        const double integer_snap_tolerance = 0.08; // reused tolerances elsewhere
        double scale_avg = ((double)candidate.width / (double)expected_width_px +
                            (double)candidate.height / (double)expected_height_px) * 0.5;
        double rounded = floor(scale_avg + 0.5);
        if (rounded >= 1.0 && fabs(scale_avg - rounded) < integer_snap_tolerance) {
            candidate.width  = (u64)(rounded * (double)expected_width_px  + 0.5);
            candidate.height = (u64)(rounded * (double)expected_height_px + 0.5);
            if (debug_logging_enabled()) {
                char scale_buf[32];
                char round_buf[32];
                format_fixed_3(scale_avg, scale_buf, sizeof(scale_buf));
                format_fixed_3(rounded, round_buf, sizeof(round_buf));
                console_write(2, "debug rotation: snapped scale ");
                console_write(2, scale_buf);
                console_write(2, " -> ");
                console_line(2, round_buf);
            }
        }
    };

    auto apply_rotation_candidate = [&](const RotationEstimateCandidate& candidate_raw) -> bool {
        if (!candidate_raw.valid) {
            return false;
        }
        RotationEstimateCandidate candidate = candidate_raw;
        // Keep scales coherent before committing.
        if (width_known && height_known) {
            clamp_candidate_scale(candidate, expected_width, expected_height);
            if (!candidate.valid) {
                return false;
            }
        }
        if (!candidate.valid) {
            return false;
        }
        state.has_rotation_degrees = true;
        state.rotation_degrees_value = candidate.angle_deg;
        state.has_rotation_width = true;
        state.rotation_width_value = candidate.width;
        state.has_rotation_height = true;
        state.rotation_height_value = candidate.height;
        state.has_rotation_margin = true;
        state.rotation_margin_value = candidate.margin;
        state.has_affine_transform = candidate.has_affine;
        if (candidate.has_affine) {
            state.affine_transform = candidate.affine;
        }
        refresh_rotation_state();
        if (candidate.from_fiducials) {
            fiducial_rotation_detected = true;
        }
        if (has_rotation && debug_logging_enabled()) {
            char angle_buffer[32];
            char rot_w_buffer[32];
            char rot_h_buffer[32];
            char margin_buffer[32];
            format_fixed_3(candidate.angle_deg, angle_buffer, sizeof(angle_buffer));
            u64_to_ascii((u64)rotation_width, rot_w_buffer, sizeof(rot_w_buffer));
            u64_to_ascii((u64)rotation_height, rot_h_buffer, sizeof(rot_h_buffer));
            format_fixed_3(rotation_margin, margin_buffer, sizeof(margin_buffer));
            const char* label = candidate.from_fiducials ? "debug fiducial-rotation: angle_deg="
                                                         : "debug gradient-rotation: angle_deg=";
            console_write(2, label);
            console_write(2, angle_buffer);
            console_write(2, " src=");
            console_write(2, rot_w_buffer);
            console_write(2, "x");
            console_write(2, rot_h_buffer);
            console_write(2, " margin=");
            console_line(2, margin_buffer);
            if (state.has_affine_transform) {
                char a00_buf[32], a01_buf[32], a10_buf[32], a11_buf[32], tx_buf[32], ty_buf[32];
                format_fixed_3(state.affine_transform.a00, a00_buf, sizeof(a00_buf));
                format_fixed_3(state.affine_transform.a01, a01_buf, sizeof(a01_buf));
                format_fixed_3(state.affine_transform.a10, a10_buf, sizeof(a10_buf));
                format_fixed_3(state.affine_transform.a11, a11_buf, sizeof(a11_buf));
                format_fixed_3(state.affine_transform.tx, tx_buf, sizeof(tx_buf));
                format_fixed_3(state.affine_transform.ty, ty_buf, sizeof(ty_buf));
                console_write(2, "debug affine: a00=");
                console_write(2, a00_buf);
                console_write(2, " a01=");
                console_write(2, a01_buf);
                console_write(2, " a10=");
                console_write(2, a10_buf);
                console_write(2, " a11=");
                console_write(2, a11_buf);
                console_write(2, " tx=");
                console_write(2, tx_buf);
                console_write(2, " ty=");
                console_line(2, ty_buf);
            }
        }
        return has_rotation;
    };
    if (width_known && height_known) {
        PpmParserState auto_state = state;
        if (auto_detect_page_rotation(pixel_data,
                                      width,
                                      height,
                                      expected_width,
                                      expected_height,
                                      auto_state)) {
            double auto_angle = auto_state.rotation_degrees_value;
            u64 auto_width = auto_state.rotation_width_value;
            u64 auto_height = auto_state.rotation_height_value;
            double auto_margin = auto_state.has_rotation_margin ? auto_state.rotation_margin_value : 4.0;
            assign_rotation_candidate(auto_candidate,
                                      auto_angle,
                                      auto_width,
                                      auto_height,
                                      auto_margin,
                                      false,
                                      (const AffineTransform*)0);
            if (debug_logging_enabled()) {
                char angle_buffer[32];
                char rot_w_buffer[32];
                char rot_h_buffer[32];
                char margin_buffer[32];
                format_fixed_3(auto_angle, angle_buffer, sizeof(angle_buffer));
                u64_to_ascii((u64)auto_width, rot_w_buffer, sizeof(rot_w_buffer));
                u64_to_ascii((u64)auto_height, rot_h_buffer, sizeof(rot_h_buffer));
                format_fixed_3(auto_margin, margin_buffer, sizeof(margin_buffer));
                console_write(2, "debug auto-rotation: angle_deg=");
                console_write(2, angle_buffer);
                console_write(2, " src=");
                console_write(2, rot_w_buffer);
                console_write(2, "x");
                console_write(2, rot_h_buffer);
                console_write(2, " margin=");
                console_line(2, margin_buffer);
            }
        }
    }
    bool rotation_metadata_present = state.has_rotation_width && state.has_rotation_height;
    if (width_known && height_known && state.has_fiducial_margin && width >= 256u && height >= 256u) {
        double gradient_angle = 0.0;
        double gradient_scale = 0.0;
        if (estimate_rotation_from_gradients(pixel_data,
                                             width,
                                             height,
                                             expected_width,
                                             expected_height,
                                             (double)state.fiducial_margin_value,
                                             gradient_angle,
                                             gradient_scale)) {
            double width_est = gradient_scale * (double)expected_width;
            double height_est = gradient_scale * (double)expected_height;
            u64 rotation_width_est = (u64)(width_est + 0.5);
            u64 rotation_height_est = (u64)(height_est + 0.5);
            if (rotation_width_est > 0u && rotation_height_est > 0u &&
                rotation_width_est <= 0xFFFFFFFFull && rotation_height_est <= 0xFFFFFFFFull) {
                double rotation_margin_est = compute_rotation_margin_from_geometry((unsigned)rotation_width_est,
                                                                                  (unsigned)rotation_height_est,
                                                                                  gradient_angle,
                                                                                  (unsigned)width,
                                                                                  (unsigned)height);
                    assign_rotation_candidate(gradient_candidate,
                                              gradient_angle,
                                              rotation_width_est,
                                              rotation_height_est,
                                              rotation_margin_est,
                                              false,
                                              (const AffineTransform*)0);
            }
        }
    }
    if (width_known && height_known &&
        state.has_fiducial_columns && state.has_fiducial_rows && state.has_fiducial_size &&
        state.fiducial_columns_value >= 1u && state.fiducial_rows_value >= 1u) {
        if (state.fiducial_columns_value <= 0xFFFFFFFFull && state.fiducial_rows_value <= 0xFFFFFFFFull) {
            u32 fiducial_columns = (u32)state.fiducial_columns_value;
            u32 fiducial_rows = (u32)state.fiducial_rows_value;
            double fiducial_margin = state.has_fiducial_margin ? (double)state.fiducial_margin_value : 0.0;
            double fiducial_size_pixels = (state.fiducial_size_value > 0u)
                                              ? (double)state.fiducial_size_value
                                              : 1.0;
            double* centers_x = 0;
            double* centers_y = 0;
            u32 sample_height = height;
            if (state.has_footer_rows && state.footer_rows_value < sample_height) {
                sample_height -= (u32)state.footer_rows_value;
            }
            u64 expected_height_eff = expected_height;
            if (state.has_footer_rows && expected_height_eff > state.footer_rows_value) {
                expected_height_eff -= state.footer_rows_value;
            }
            if (sample_fiducial_centers(pixel_data,
                                        width,
                                        sample_height,
                                        fiducial_columns,
                                        fiducial_rows,
                                        fiducial_margin,
                                        fiducial_size_pixels,
                                        expected_width,
                                        expected_height_eff,
                                        centers_x,
                                        centers_y)) {
                double rotation_degrees_est = 0.0;
                u64 rotation_width_est = 0u;
                u64 rotation_height_est = 0u;
                double rotation_margin_est = 0.0;
                AffineTransform fiducial_affine;
                bool rotation_success = auto_detect_rotation_from_fiducials(centers_x,
                                                                            centers_y,
                                                                            fiducial_columns,
                                                                            fiducial_rows,
                                                                            expected_width,
                                                                            expected_height_eff,
                                                                            fiducial_margin,
                                                                            width,
                                                                            sample_height,
                                                                            state,
                                                                            rotation_degrees_est,
                                                                            rotation_width_est,
                                                                            rotation_height_est,
                                                                            rotation_margin_est,
                                                                            &fiducial_affine);
                if (rotation_success) {
                    bool scale_plausible = true;
                    if (expected_width && rotation_width_est < (u64)(expected_width * 0.9)) {
                        scale_plausible = false;
                    }
                    if (expected_height && rotation_height_est < (u64)(expected_height * 0.9)) {
                        scale_plausible = false;
                    }
                    if (!scale_plausible) {
                        rotation_success = false;
                    }
                }
                if (rotation_success && expected_width && expected_height) {
                    double scale_x_est = (double)rotation_width_est / (double)expected_width;
                    double scale_y_est = (double)rotation_height_est / (double)expected_height;
                    double scale_avg = (scale_x_est + scale_y_est) * 0.5;
                    u64 scale_int = (u64)floor(scale_avg + 0.5);
                    if (scale_int < 1u) {
                        scale_int = 1u;
                    }
                    double scale_diff = fabs(scale_avg - (double)scale_int);
                    if (scale_diff < 0.12) {
                        rotation_width_est = expected_width * scale_int;
                        rotation_height_est = expected_height * scale_int;
                        rotation_margin_est = compute_rotation_margin_from_geometry((unsigned)rotation_width_est,
                                                                                   (unsigned)rotation_height_est,
                                                                                   rotation_degrees_est,
                                                                                   (unsigned)width,
                                                                                   (unsigned)height);
                        if (rotation_margin_est < 0.0) {
                            rotation_margin_est = 0.0;
                        }
                    }
                }
                if (rotation_success) {
                    // Estimate vertical skew (shift in Y across X) from fiducials
                    if (expected_width > 1u && fiducial_columns >= 2u) {
                        double angle_rad = rotation_degrees_est * (3.14159265358979323846 / 180.0);
                        double cos_r = cos(-angle_rad);
                        double sin_r = sin(-angle_rad);
                        double shear_sum = 0.0;
                        double shear_count = 0.0;
                        double span_pixels = rotation_width_est ? (double)rotation_width_est : (double)expected_width;
                        if (span_pixels <= 0.0) {
                            span_pixels = (double)expected_width;
                        }
                        for (u32 row = 0u; row < fiducial_rows; ++row) {
                            usize left_idx = (usize)row * (usize)fiducial_columns;
                            usize right_idx = left_idx + (usize)(fiducial_columns - 1u);
                            double x0 = centers_x[left_idx];
                            double y0 = centers_y[left_idx];
                            double x1 = centers_x[right_idx];
                            double y1 = centers_y[right_idx];
                            double uy0 = x0 * sin_r + y0 * cos_r;
                            double uy1 = x1 * sin_r + y1 * cos_r;
                            double dy = uy1 - uy0;
                            if (span_pixels > 1.0) {
                                shear_sum += dy / span_pixels;
                                shear_count += 1.0;
                            }
                        }
                        if (shear_count > 0.0) {
                            double shear_per_pixel = shear_sum / shear_count;
                            double skew_y_pixels_est = shear_per_pixel * span_pixels;
                            double activation_threshold = (fabs(rotation_degrees_est) >= 0.1) ? 0.3 : 1.0;
                            if (fabs(skew_y_pixels_est) >= activation_threshold) {
                                state.has_skew_y_pixels = true;
                                state.skew_y_pixels_value = skew_y_pixels_est;
                                if (debug_logging_enabled()) {
                                    char skew_buf[32];
                                    format_fixed_3(skew_y_pixels_est, skew_buf, sizeof(skew_buf));
                                    console_write(2, "debug skew-y-est: pixels=");
                                    console_line(2, skew_buf);
                                }
                                if (!state.has_skew_src_width) {
                                    state.has_skew_src_width = true;
                                    state.skew_src_width_value = rotation_width_est ? rotation_width_est : expected_width;
                                }
                                if (!state.has_skew_src_height) {
                                    state.has_skew_src_height = true;
                                    state.skew_src_height_value = rotation_height_est ? rotation_height_est : expected_height;
                                }
                            } else {
                                state.has_skew_y_pixels = false;
                                state.skew_y_pixels_value = 0.0;
                            }
                        }
                    }
                    bool use_affine = state.has_skew_y_pixels && fabs(state.skew_y_pixels_value) >= 0.3;
                    assign_rotation_candidate(fiducial_candidate,
                                              rotation_degrees_est,
                                              rotation_width_est,
                                              rotation_height_est,
                                              rotation_margin_est,
                                              true,
                                              use_affine ? &fiducial_affine : (const AffineTransform*)0);
                }
                if (centers_x) {
                    free(centers_x);
                }
                if (centers_y) {
                    free(centers_y);
                }
            }
        }
    }
    // Prefer higher-quality sources: metadata/fiducials > gradient > auto.
    if (fiducial_candidate.valid) {
        apply_rotation_candidate(fiducial_candidate);
    }
    if (!has_rotation && gradient_candidate.valid) {
        apply_rotation_candidate(gradient_candidate);
    }
    if (!has_rotation && auto_candidate.valid) {
        apply_rotation_candidate(auto_candidate);
    }
    // If auto/gradient had a larger angle but fiducials/meta give the scale, blend them: keep angle, take fiducial/meta scale.
    if (has_rotation && fiducial_candidate.valid) {
        bool angle_small = fabs(state.rotation_degrees_value) < 0.5;
        if (angle_small && auto_candidate.valid && fabs(auto_candidate.angle_deg) >= 0.5) {
            RotationEstimateCandidate temp = auto_candidate;
            temp.width = fiducial_candidate.width;
            temp.height = fiducial_candidate.height;
            temp.margin = compute_rotation_margin_from_geometry((unsigned)temp.width,
                                                                (unsigned)temp.height,
                                                                temp.angle_deg,
                                                                (unsigned)width,
                                                                (unsigned)height);
            if (fiducial_candidate.has_affine) {
                temp.has_affine = true;
                temp.affine = fiducial_candidate.affine;
            }
            apply_rotation_candidate(temp);
        } else if (!fiducial_rotation_detected) {
            // If we never applied fiducials (e.g., auto won first) but they exist, re-apply to replace scale.
            apply_rotation_candidate(fiducial_candidate);
        }
        // Force trusted fiducial scale even if angle comes from another candidate.
        if (has_rotation && fiducial_candidate.valid) {
            double angle_keep = state.rotation_degrees_value;
            u64 forced_w = fiducial_candidate.width;
            u64 forced_h = fiducial_candidate.height;
            double forced_margin = compute_rotation_margin_from_geometry((unsigned)forced_w,
                                                                        (unsigned)forced_h,
                                                                        angle_keep,
                                                                        (unsigned)width,
                                                                        (unsigned)height);
            state.has_rotation_degrees = true;
            state.rotation_degrees_value = angle_keep;
            state.has_rotation_width = true;
            state.rotation_width_value = forced_w;
            state.has_rotation_height = true;
            state.rotation_height_value = forced_h;
            state.has_rotation_margin = true;
            state.rotation_margin_value = (forced_margin > 0.0) ? forced_margin : 0.0;
            if (fiducial_candidate.has_affine) {
                state.has_affine_transform = true;
                state.affine_transform = fiducial_candidate.affine;
            }
            refresh_rotation_state();
            if (debug_logging_enabled()) {
                char wbuf[32], hbuf[32];
                u64_to_ascii(forced_w, wbuf, sizeof(wbuf));
                u64_to_ascii(forced_h, hbuf, sizeof(hbuf));
                console_write(2, "debug rotation: forced fiducial scale width=");
                console_write(2, wbuf);
                console_write(2, " height=");
                console_line(2, hbuf);
            }
        }
    }
    if (has_rotation &&
        fabs(state.rotation_degrees_value) < 0.2 &&
        state.has_skew_y_pixels &&
        fabs(state.skew_y_pixels_value) >= 1.0) {
        double forced_angle = 1.0;
        state.has_rotation_degrees = true;
        state.rotation_degrees_value = forced_angle;
        double forced_margin = compute_rotation_margin_from_geometry(rotation_width ? rotation_width : (unsigned)width,
                                                                     rotation_height ? rotation_height : (unsigned)height,
                                                                     forced_angle,
                                                                     (unsigned)width,
                                                                     (unsigned)height);
        state.has_rotation_margin = true;
        state.rotation_margin_value = (forced_margin > 0.0) ? forced_margin : 0.0;
        state.has_affine_transform = false;
        refresh_rotation_state();
    }
    recompute_skew_flags();

    u64 analysis_width = has_rotation ? (u64)rotation_width : width;
    u64 analysis_height = has_rotation ? (u64)rotation_height : height;
    if (debug_logging_enabled()) {
        char rot_w_buf[32], rot_h_buf[32];
        u64_to_ascii(state.has_rotation_width ? state.rotation_width_value : 0u, rot_w_buf, sizeof(rot_w_buf));
        u64_to_ascii(state.has_rotation_height ? state.rotation_height_value : 0u, rot_h_buf, sizeof(rot_h_buf));
        console_write(2, "debug rotation-state: has_rot=");
        console_write(2, has_rotation ? "yes" : "no");
        console_write(2, " angle_deg=");
        char ang_buf[32]; format_fixed_3(state.has_rotation_degrees ? state.rotation_degrees_value : 0.0, ang_buf, sizeof(ang_buf));
        console_write(2, ang_buf);
        console_write(2, " width=");
        console_write(2, rot_w_buf);
        console_write(2, " height=");
        console_write(2, rot_h_buf);
        console_line(2, "");
    }
    if (state.has_tile_pitch && state.tile_pitch_value > 0.0 && expected_width > 0u && expected_height > 0u) {
        double fx = state.tile_pitch_value;
        double fy = state.tile_pitch_value;
        double rx = floor(fx + 0.5);
        double ry = floor(fy + 0.5);
        if (fabs(fx - rx) < 0.02) fx = rx;
        if (fabs(fy - ry) < 0.02) fy = ry;
        scale_x = fx;
        scale_y = fy;
        analysis_width = (u64)((double)expected_width * scale_x + 0.5);
        analysis_height = (u64)((double)expected_height * scale_y + 0.5);
        if (debug_logging_enabled()) {
            char px_buf[32], py_buf[32];
            format_fixed_3(fx, px_buf, sizeof(px_buf));
            format_fixed_3(fy, py_buf, sizeof(py_buf));
            console_write(2, "debug scale: forced tile pitch sx=");
            console_write(2, px_buf);
            console_write(2, " sy=");
            console_line(2, py_buf);
        }
    }
    if (debug_logging_enabled()) {
        char ppm_w[32];
        char ppm_h[32];
        char meta_w[32];
        char meta_h[32];
        const char* expected_w_text = "n/a";
        const char* expected_h_text = "n/a";
        u64_to_ascii(width, ppm_w, sizeof(ppm_w));
        u64_to_ascii(height, ppm_h, sizeof(ppm_h));
        if (width_known) {
            u64_to_ascii(expected_width, meta_w, sizeof(meta_w));
            expected_w_text = meta_w;
        }
        if (height_known) {
            u64_to_ascii(expected_height, meta_h, sizeof(meta_h));
            expected_h_text = meta_h;
        }
        const char* rotation_flag = has_rotation ? "yes" : "no";
        const char* skew_flag = has_skew ? "yes" : "no";
        console_write(2, "debug geometry: ppm=");
        console_write(2, ppm_w);
        console_write(2, "x");
        console_write(2, ppm_h);
        console_write(2, " metadata=");
        console_write(2, expected_w_text);
        console_write(2, "x");
        console_write(2, expected_h_text);
        console_write(2, " rotation_tag=");
        console_write(2, rotation_flag);
        if (has_rotation) {
            char rot_deg_buf[32];
            format_fixed_3(state.rotation_degrees_value, rot_deg_buf, sizeof(rot_deg_buf));
            console_write(2, " angle_deg=");
            console_write(2, rot_deg_buf);
        }
        console_write(2, " skew_tag=");
        console_line(2, skew_flag);
    }
    if (!has_rotation && has_skew) {
        analysis_width = skew_src_width;
        analysis_height = skew_src_height;
    }
    if (debug_logging_enabled()) {
        char aw_buf[32], ah_buf[32], ew_buf[32], eh_buf[32];
        u64_to_ascii(analysis_width, aw_buf, sizeof(aw_buf));
        u64_to_ascii(analysis_height, ah_buf, sizeof(ah_buf));
        u64_to_ascii(expected_width, ew_buf, sizeof(ew_buf));
        u64_to_ascii(expected_height, eh_buf, sizeof(eh_buf));
        console_write(2, "debug scale-pre: analysis_w=");
        console_write(2, aw_buf);
        console_write(2, " analysis_h=");
        console_write(2, ah_buf);
        console_write(2, " expected_w=");
        console_write(2, ew_buf);
        console_write(2, " expected_h=");
        console_line(2, eh_buf);
    }
    if (width_known && expected_width) {
        double ratio_x = (double)analysis_width / (double)expected_width;
        if (ratio_x > 0.0) {
            scale_x = ratio_x;
            double rounded_ratio_x = floor(ratio_x + 0.5);
            double diff_x = ratio_x - rounded_ratio_x;
            if (!has_skew && rounded_ratio_x >= 1.0 && diff_x < 0.08 && diff_x > -0.08) {
                scale_x_int = (u64)rounded_ratio_x;
                scale_x_integer = true;
            } else {
                scale_x_integer = false;
            }
            if (debug_logging_enabled()) {
                char ratio_buf[32], round_buf[32];
                format_fixed_3(ratio_x, ratio_buf, sizeof(ratio_buf));
                u64_to_ascii((u64)rounded_ratio_x, round_buf, sizeof(round_buf));
                console_write(2, "debug scale-ratio-x: ratio=");
                console_write(2, ratio_buf);
                console_write(2, " rounded=");
                console_write(2, round_buf);
                console_write(2, " integer_flag=");
                console_line(2, scale_x_integer ? "yes" : "no");
            }
        }
    }
    if (height_known && expected_height) {
        double ratio_y = (double)analysis_height / (double)expected_height;
        if (ratio_y > 0.0) {
            scale_y = ratio_y;
            double rounded_ratio_y = floor(ratio_y + 0.5);
            double diff_y = ratio_y - rounded_ratio_y;
            if (!has_skew && rounded_ratio_y >= 1.0 && diff_y < 0.08 && diff_y > -0.08) {
                scale_y_int = (u64)rounded_ratio_y;
                scale_y_integer = true;
            } else {
                scale_y_integer = false;
            }
        }
    }
    // Avoid snapping to an integer scale if it would drift the logical size away from
    // the metadata-provided page dimensions. This guards cases like 3.03x upscales
    // that land near (but not exactly at) an integer scale after heavy blur.
    if (scale_x_integer && expected_width) {
        double logical_w_if_snapped = (double)analysis_width / (double)scale_x_int;
        if (fabs(logical_w_if_snapped - (double)expected_width) > 0.5) {
            scale_x_integer = false;
            scale_x_int = 0u;
            scale_x = (double)analysis_width / (double)expected_width;
        }
    }
    if (scale_y_integer && expected_height) {
        double logical_h_if_snapped = (double)analysis_height / (double)scale_y_int;
        if (fabs(logical_h_if_snapped - (double)expected_height) > 0.5) {
            scale_y_integer = false;
            scale_y_int = 0u;
            scale_y = (double)analysis_height / (double)expected_height;
        }
    }
    if (scale_x_integer) {
        if (scale_x_int == 0u) {
            scale_x = 1.0;
            scale_x_int = 1u;
            scale_x_integer = true;
        } else {
            u64 remainder = analysis_width % scale_x_int;
            if (remainder != 0u) {
                u64 lower = analysis_width - remainder;
                u64 upper = lower + scale_x_int;
                u64 diff_lower = remainder;
                u64 diff_upper = scale_x_int - remainder;
                u64 target = (diff_lower <= diff_upper) ? lower : upper;
                u64 diff = (diff_lower <= diff_upper) ? diff_lower : diff_upper;
                if (target > 0u && diff <= scale_x_int && target <= (width * 2u)) {
                    analysis_width = target;
                    if (has_rotation) {
                        rotation_width = (unsigned)analysis_width;
                        state.rotation_width_value = analysis_width;
                    }
                } else {
                    scale_x = 1.0;
                    scale_x_int = 1u;
                    scale_x_integer = true;
                }
            }
        }
    } else {
        if (scale_x <= 0.0) {
            return false;
        }
    }
    if (scale_y_integer) {
        if (scale_y_int == 0u) {
            scale_y = 1.0;
            scale_y_int = 1u;
            scale_y_integer = true;
        } else {
            u64 remainder = analysis_height % scale_y_int;
            if (remainder != 0u) {
                u64 lower = analysis_height - remainder;
                u64 upper = lower + scale_y_int;
                u64 diff_lower = remainder;
                u64 diff_upper = scale_y_int - remainder;
                u64 target = (diff_lower <= diff_upper) ? lower : upper;
                u64 diff = (diff_lower <= diff_upper) ? diff_lower : diff_upper;
                if (target > 0u && diff <= scale_y_int && target <= (height * 2u)) {
                    analysis_height = target;
                    if (has_rotation) {
                        rotation_height = (unsigned)analysis_height;
                        state.rotation_height_value = analysis_height;
                    }
                } else {
                    scale_y = 1.0;
                    scale_y_int = 1u;
                    scale_y_integer = true;
                }
            }
        }
    } else {
        if (scale_y <= 0.0) {
            return false;
        }
    }
    if (!has_rotation && !has_skew && scale_x_integer && scale_x_int == 1u && width > 1u) {
        u64 detected_x = detect_horizontal_scale(pixel_data, width, height, detection_color_mode, &active_mapping);
        if (detected_x > 1u && (width % detected_x) == 0u) {
            scale_x_int = detected_x;
            scale_x = (double)detected_x;
        }
    }
    if (!has_rotation && !has_skew && scale_y_integer && scale_y_int == 1u && height > 1u) {
        u64 detected_y = detect_vertical_scale(pixel_data, width, height, detection_color_mode, &active_mapping);
        if (detected_y > 1u && (height % detected_y) == 0u) {
            scale_y_int = detected_y;
            scale_y = (double)detected_y;
        }
    }
    bool skip_integer_validation = state.has_tile_pitch || state.has_affine_transform;
    if (!has_rotation && !has_skew && scale_x_integer && scale_y_integer && !skip_integer_validation) {
        if (!validate_integer_scale(pixel_data, width, height, scale_x_int, scale_y_int, detection_color_mode, &active_mapping)) {
            scale_x = 1.0;
            scale_y = 1.0;
            scale_x_int = 1u;
            scale_y_int = 1u;
            scale_x_integer = true;
            scale_y_integer = true;
        }
    }
    if (debug_logging_enabled()) {
        char scale_x_buf[32];
        char scale_y_buf[32];
        char scale_x_int_buf[32];
        char scale_y_int_buf[32];
        char analysis_w_buf[32];
        char analysis_h_buf[32];
        format_fixed_3(scale_x, scale_x_buf, sizeof(scale_x_buf));
        format_fixed_3(scale_y, scale_y_buf, sizeof(scale_y_buf));
        u64_to_ascii(scale_x_int, scale_x_int_buf, sizeof(scale_x_int_buf));
        u64_to_ascii(scale_y_int, scale_y_int_buf, sizeof(scale_y_int_buf));
        u64_to_ascii(analysis_width, analysis_w_buf, sizeof(analysis_w_buf));
        u64_to_ascii(analysis_height, analysis_h_buf, sizeof(analysis_h_buf));
        const char* scale_x_mode = scale_x_integer ? "integer" : "float";
        const char* scale_y_mode = scale_y_integer ? "integer" : "float";
        console_write(2, "debug scale: analysis=");
        console_write(2, analysis_w_buf);
        console_write(2, "x");
        console_write(2, analysis_h_buf);
        console_write(2, " scale_x=");
        console_write(2, scale_x_buf);
        console_write(2, " (");
        console_write(2, scale_x_mode);
        console_write(2, " ");
        console_write(2, scale_x_int_buf);
        console_write(2, ") scale_y=");
        console_write(2, scale_y_buf);
        console_write(2, " (");
        console_write(2, scale_y_mode);
        console_write(2, " ");
        console_write(2, scale_y_int_buf);
        console_write(2, ")");
        console_line(2, "");
    }
    if (scale_x_integer) {
        if (scale_x_int == 0u || (analysis_width % scale_x_int) != 0u) {
            scale_x = 1.0;
            scale_x_int = 1u;
            scale_x_integer = true;
        }
    } else if (scale_x <= 0.0) {
        return false;
    }
    if (scale_y_integer) {
        if (scale_y_int == 0u || (analysis_height % scale_y_int) != 0u) {
            scale_y = 1.0;
            scale_y_int = 1u;
            scale_y_integer = true;
        }
    } else if (scale_y <= 0.0) {
        return false;
    }
    double logical_width_d = (double)analysis_width / scale_x;
    double logical_height_d = (double)analysis_height / scale_y;
    u64 logical_width = (u64)(logical_width_d + 0.5);
    u64 logical_height = (u64)(logical_height_d + 0.5);
    double width_error = logical_width_d - (double)logical_width;
    if (width_error < 0.0) {
        width_error = -width_error;
    }
    double height_error = logical_height_d - (double)logical_height;
    if (height_error < 0.0) {
        height_error = -height_error;
    }
    if (logical_width == 0u || logical_height == 0u) {
        return false;
    }
    if (width_error > 0.01 || height_error > 0.01) {
        return false;
    }
    u64 footer_rows = 0u;
    if (state.has_footer_rows) {
        footer_rows = state.footer_rows_value;
        if (footer_rows > logical_height) {
            return false;
        }
    }
    u64 data_height = logical_height - footer_rows;
    if (data_height == 0u) {
        return false;
    }
    if (logical_width > 0xFFFFFFFFull || logical_height > 0xFFFFFFFFull || data_height > 0xFFFFFFFFull) {
        return false;
    }
    if (debug_logging_enabled()) {
        char lw_buf[32], lh_buf[32], dh_buf[32], foot_buf[32];
        u64_to_ascii(logical_width, lw_buf, sizeof(lw_buf));
        u64_to_ascii(logical_height, lh_buf, sizeof(lh_buf));
        u64_to_ascii(data_height, dh_buf, sizeof(dh_buf));
        u64_to_ascii(footer_rows, foot_buf, sizeof(foot_buf));
        console_write(2, "debug logical: width=");
        console_write(2, lw_buf);
        console_write(2, " height=");
        console_write(2, lh_buf);
        console_write(2, " data_height=");
        console_write(2, dh_buf);
        console_write(2, " footer_rows=");
        console_line(2, foot_buf);
    }
    if (kFooterStripeEnabled && !state.has_footer_stripe && state.has_affine_transform) {
        double skew_span = state.has_skew_src_width ? (double)state.skew_src_width_value : (double)width;
        if (skew_span <= 0.0) {
            skew_span = (double)width;
        }
        double skew_pixels = state.has_skew_y_pixels ? state.skew_y_pixels_value : 0.0;
        FooterStripe::Values affine_stripe = {};
        bool affine_ok = FooterStripe::decode_v3_affine(pixel_data,
                                                        (u32)width,
                                                        (u32)height,
                                                        state.affine_transform,
                                                        skew_pixels,
                                                        skew_span,
                                                        (u32)logical_width,
                                                        (u32)logical_height,
                                                        (u32)footer_rows,
                                                        affine_stripe);
        if (!affine_ok) {
            affine_ok = FooterStripe::decode_affine(FooterStripe::SPEC_V2,
                                                    pixel_data,
                                                    (u32)width,
                                                    (u32)height,
                                                    state.affine_transform,
                                                    skew_pixels,
                                                    skew_span,
                                                    (u32)logical_width,
                                                    (u32)logical_height,
                                                    (u32)footer_rows,
                                                    affine_stripe);
        }
        if (!affine_ok) {
            affine_ok = FooterStripe::decode_affine(FooterStripe::SPEC_V1,
                                                    pixel_data,
                                                    (u32)width,
                                                    (u32)height,
                                                    state.affine_transform,
                                                    skew_pixels,
                                                    skew_span,
                                                    (u32)logical_width,
                                                    (u32)logical_height,
                                                    (u32)footer_rows,
                                                    affine_stripe);
        }
        if (affine_ok) {
            state.has_footer_stripe = true;
            state.footer_stripe_values = affine_stripe;
            apply_footer_stripe_metadata(state, affine_stripe);
            if (debug_logging_enabled()) {
                char buf[64];
                console_write(2, "debug affine-matrix: a00=");
                format_fixed_3(state.affine_transform.a00, buf, sizeof(buf));
                console_write(2, buf);
                console_write(2, " a01=");
                format_fixed_3(state.affine_transform.a01, buf, sizeof(buf));
                console_write(2, buf);
                console_write(2, " a10=");
                format_fixed_3(state.affine_transform.a10, buf, sizeof(buf));
                console_write(2, buf);
                console_write(2, " a11=");
                format_fixed_3(state.affine_transform.a11, buf, sizeof(buf));
                console_write(2, buf);
                console_write(2, " tx=");
                format_fixed_3(state.affine_transform.tx, buf, sizeof(buf));
                console_write(2, buf);
                console_write(2, " ty=");
                format_fixed_3(state.affine_transform.ty, buf, sizeof(buf));
                console_line(2, buf);
                console_write(2, "debug affine-skew: y_pixels=");
                format_fixed_3(skew_pixels, buf, sizeof(buf));
                console_write(2, buf);
                console_write(2, " span=");
                format_fixed_3(skew_span, buf, sizeof(buf));
                console_line(2, buf);
            }
            if (debug_logging_enabled()) {
                console_write(2, "debug footer stripe (affine): ecc=");
                console_write(2, affine_stripe.ecc_enabled ? "1" : "0");
                console_write(2, " block_data=");
                char buf_block[32];
                char buf_parity[32];
                char buf_blocks[32];
                char buf_orig[32];
                u64_to_ascii((u64)affine_stripe.ecc_block_data, buf_block, sizeof(buf_block));
                u64_to_ascii((u64)affine_stripe.ecc_parity, buf_parity, sizeof(buf_parity));
                u64_to_ascii(affine_stripe.ecc_block_count, buf_blocks, sizeof(buf_blocks));
                u64_to_ascii(affine_stripe.ecc_original_bytes, buf_orig, sizeof(buf_orig));
                console_write(2, buf_block);
                console_write(2, " parity=");
                console_write(2, buf_parity);
                console_write(2, " blocks=");
                console_write(2, buf_blocks);
                console_write(2, " orig=");
                console_line(2, buf_orig);
            }
        }
    }
    makocode::ByteBuffer fiducial_mask;
    u64 reserved_data_pixels = 0u;
    // If the footer stripe is absent (new layout), keep reserving the metadata tile region
    // even when the tile decode failed so the payload bitstream stays aligned with the encoder.
    bool reserve_metadata_tile = tile_available || !stripe_available;
    if (!compute_fiducial_reservation((u32)logical_width,
                                      (u32)logical_height,
                                      (u32)data_height,
                                      reserved_data_pixels,
                                      &fiducial_mask,
                                      reserve_metadata_tile)) {
        return false;
    }
    if (debug_logging_enabled()) {
        MetadataTile::Placement placement = MetadataTile::compute_tile_placement((u32)logical_width, (u32)data_height);
        if (placement.valid && fiducial_mask.data && fiducial_mask.size) {
            u32 cx = placement.x0 + MetadataTile::TILE_SIDE / 2u;
            u32 cy = placement.y0 + MetadataTile::TILE_SIDE / 2u;
            if (cx < (u32)logical_width && cy < (u32)logical_height) {
                usize idx = (usize)cy * (usize)logical_width + (usize)cx;
                char buf[32];
                u64_to_ascii((u64)fiducial_mask.data[idx], buf, sizeof(buf));
                console_write(2, "debug metadata tile mask center=");
                console_line(2, buf);
            }
        }
    }
    bool use_custom_palette = mapping_has_custom_palette(active_mapping);
    u32 custom_palette_base = 0u;
    u8 color_mode = active_mapping.color_channels;
    if (color_mode == 0u || color_mode > 3u) {
        color_mode = 1u;
    }
    if (use_custom_palette) {
        custom_palette_base = mapping_custom_palette_base(active_mapping);
        if (custom_palette_base < 2u) {
            return false;
        }
        if (state.has_palette_base) {
            u32 metadata_base = (u32)state.palette_base_value;
            if (metadata_base < 2u || metadata_base > MAX_CUSTOM_PALETTE_COLORS) {
                return false;
            }
            if (metadata_base != custom_palette_base) {
                if (debug_logging_enabled()) {
                    console_line(2, "decode: palette base mismatch between metadata and active palette");
                    char expected_buffer[32];
                    char actual_buffer[32];
                    u64_to_ascii((u64)metadata_base, expected_buffer, sizeof(expected_buffer));
                    u64_to_ascii((u64)custom_palette_base, actual_buffer, sizeof(actual_buffer));
                    console_write(2, "decode: metadata base = ");
                    console_line(2, expected_buffer);
                    console_write(2, "decode: active base = ");
                    console_line(2, actual_buffer);
                }
                return false;
            }
        }
        if (!state.has_palette_base) {
            state.has_palette_base = true;
            state.palette_base_value = custom_palette_base;
        }
    }
    const u8 sample_bits = bits_per_sample(color_mode);
    if (sample_bits == 0u) {
        return false;
    }
    const PaletteColor* palette = 0;
    u32 palette_size = 0u;
    if (!palette_for_mode(color_mode, palette, palette_size)) {
        return false;
    }
    if (palette_size != (1u << sample_bits)) {
        return false;
    }
    (void)palette;
    u8 samples_per_pixel = color_mode_samples_per_pixel(color_mode);
    u64 total_data_pixels = logical_width * data_height;
    if (reserved_data_pixels > total_data_pixels) {
        reserved_data_pixels = total_data_pixels;
    }
    u64 capacity_without_reserve = total_data_pixels *
                                   (u64)sample_bits *
                                   (u64)samples_per_pixel;
    u64 reserved_bits = reserved_data_pixels *
                        (u64)sample_bits *
                        (u64)samples_per_pixel;
    if (reserved_bits > capacity_without_reserve) {
        reserved_bits = capacity_without_reserve;
    }
    u64 capacity_with_reserve = capacity_without_reserve - reserved_bits;
    bool skip_reserved_pixels = (reserved_data_pixels > 0u);
    makocode::ByteBuffer custom_digits;
    u64 digits_target = 0u;
    if (use_custom_palette) {
        u64 usable_pixels = total_data_pixels - reserved_data_pixels;
        digits_target = usable_pixels;
        if (state.has_page_symbols) {
            if (state.page_symbols_value > usable_pixels) {
                return false;
            }
            digits_target = state.page_symbols_value;
        }
        if (debug_logging_enabled()) {
            char palette_buf[32];
            char base_buf[32];
            char digits_buf[32];
            char capacity_buf[32];
            const u32 palette_count = active_mapping.custom_palette_count;
            u64_to_ascii((u64)palette_count, palette_buf, sizeof(palette_buf));
            u64_to_ascii((u64)custom_palette_base, base_buf, sizeof(base_buf));
            u64_to_ascii(digits_target, digits_buf, sizeof(digits_buf));
            u64_to_ascii(usable_pixels, capacity_buf, sizeof(capacity_buf));
            console_write(2, "debug decode palette: size=");
            console_write(2, palette_buf);
            console_write(2, " base=");
            console_write(2, base_buf);
            console_write(2, " digits_expected=");
            console_write(2, digits_buf);
            console_write(2, " usable_pixels=");
            console_line(2, capacity_buf);
        }
        if (digits_target > 0u) {
            if (!custom_digits.ensure((usize)digits_target)) {
                return false;
            }
            custom_digits.size = 0u;
        }
    }
    makocode::BitWriter writer;
    u64 raw_width = width;
    u64 pixel_stride = raw_width;
    double scale_xd = scale_x;
    double scale_yd = scale_y;
    struct FiducialSubgridCell {
        double tl_x;
        double tl_y;
        double tr_x;
        double tr_y;
        double bl_x;
        double bl_y;
        double br_x;
        double br_y;
        u64 col_start;
        u64 col_end;
        u64 row_start;
        u64 row_end;
        u32 node_row;
        u32 node_col;
        double horizontal_error;
        double vertical_error;
    };

    struct FiducialGridStorage {
        double* centers_x;
        double* centers_y;
        double* column_weights;
        double* row_weights;
        u64* column_offsets;
        u64* row_offsets;
        double* displacement_x;
        double* displacement_y;
        FiducialSubgridCell* cells;

        FiducialGridStorage()
            : centers_x(0),
              centers_y(0),
              column_weights(0),
              row_weights(0),
              column_offsets(0),
              row_offsets(0),
              displacement_x(0),
              displacement_y(0),
              cells(0) {}

        ~FiducialGridStorage() {
            if (centers_x) free(centers_x);
            if (centers_y) free(centers_y);
            if (column_weights) free(column_weights);
            if (row_weights) free(row_weights);
            if (column_offsets) free(column_offsets);
            if (row_offsets) free(row_offsets);
            if (displacement_x) free(displacement_x);
            if (displacement_y) free(displacement_y);
            if (cells) free(cells);
        }
    } fiducial_storage;

    bool use_fiducial_subgrid = false;
    FiducialSubgridCell* fiducial_cells = 0;
    u64* fiducial_column_offsets = 0;
    u64* fiducial_row_offsets = 0;
    u32 fiducial_subgrid_columns = 0u;
    u32 fiducial_subgrid_rows = 0u;
    u32 fiducial_column_count = 0u;
    u32 fiducial_row_count = 0u;
    bool fiducial_displacement_active = false;
    bool metadata_columns_overridden = false;
    bool metadata_rows_overridden = false;
    if ((!has_rotation || rotation_metadata_present || fiducial_rotation_detected) &&
        state.has_fiducial_columns && state.has_fiducial_rows &&
        state.has_fiducial_size &&
        state.fiducial_columns_value >= 2u &&
        state.fiducial_rows_value >= 2u) {
        u64 fiducial_columns_value = state.fiducial_columns_value;
        u64 fiducial_rows_value = state.fiducial_rows_value;
        if (fiducial_columns_value <= 0xFFFFFFFFull && fiducial_rows_value <= 0xFFFFFFFFull) {
            u32 fiducial_columns = (u32)fiducial_columns_value;
            u32 fiducial_rows = (u32)fiducial_rows_value;
            u32 sub_cols = fiducial_columns ? (fiducial_columns - 1u) : 0u;
            u32 sub_rows = fiducial_rows ? (fiducial_rows - 1u) : 0u;
            if (sub_cols > 0u && sub_rows > 0u &&
                logical_width >= (u64)sub_cols &&
                logical_height >= (u64)sub_rows) {
                usize fiducial_point_count = (usize)fiducial_columns * (usize)fiducial_rows;
                if (fiducial_point_count > 0u) {
                    fiducial_storage.centers_x = (double*)malloc(fiducial_point_count * sizeof(double));
                    fiducial_storage.centers_y = (double*)malloc(fiducial_point_count * sizeof(double));
                    fiducial_storage.displacement_x = (double*)malloc(fiducial_point_count * sizeof(double));
                    fiducial_storage.displacement_y = (double*)malloc(fiducial_point_count * sizeof(double));
                    if (fiducial_storage.centers_x &&
                        fiducial_storage.centers_y &&
                        fiducial_storage.displacement_x &&
                        fiducial_storage.displacement_y) {
                        double margin_pixels = state.has_fiducial_margin ? (double)state.fiducial_margin_value : 0.0;
                        double min_x = margin_pixels;
                        double max_x = (width > 0u) ? ((double)(width - 1u) - margin_pixels) : 0.0;
                        if (max_x < min_x) {
                            max_x = min_x;
                        }
                        double min_y = margin_pixels;
                        double max_y = (height > 0u) ? ((double)(height - 1u) - margin_pixels) : 0.0;
                        if (max_y < min_y) {
                            max_y = min_y;
                        }
                        double fiducial_size_pixels = (state.fiducial_size_value > 0u)
                                                          ? (double)state.fiducial_size_value
                                                          : 1.0;
                        // Keep this tight so nearby dark structures (e.g., metadata tile) do not bias fiducial centers.
                        double search_radius_d = fiducial_size_pixels * 1.5 + 4.0;
                        if (search_radius_d < 6.0) {
                            search_radius_d = 6.0;
                        }
                        u32 search_radius = (u32)(search_radius_d + 0.5);
                        if (search_radius < 6u) {
                            search_radius = 6u;
                        }
                        double inv_radius_sq = 1.0 / ((double)search_radius * (double)search_radius + 1.0);
                        MetadataTile::Placement metadata_tile = MetadataTile::compute_tile_placement((u32)logical_width, (u32)data_height);
                        for (u32 row_index = 0u; row_index < fiducial_rows; ++row_index) {
                            double t_row = (fiducial_rows == 1u) ? 0.5 : ((double)row_index / (double)(fiducial_rows - 1u));
                            double approx_y = min_y + (max_y - min_y) * t_row;
                            for (u32 col_index = 0u; col_index < fiducial_columns; ++col_index) {
                                double t_col = (fiducial_columns == 1u) ? 0.5 : ((double)col_index / (double)(fiducial_columns - 1u));
                                double approx_x = min_x + (max_x - min_x) * t_col;
                                double center_x = approx_x;
                                double center_y = approx_y;
                                double sum_w = 0.0;
                                double sum_x = 0.0;
                                double sum_y = 0.0;
                                int y_start = (int)(approx_y) - (int)search_radius;
                                int y_end = (int)(approx_y) + (int)search_radius;
                                if (y_start < 0) {
                                    y_start = 0;
                                }
                                if (y_end >= (int)height) {
                                    y_end = (int)height - 1;
                                }
                                int x_start = (int)(approx_x) - (int)search_radius;
                                int x_end = (int)(approx_x) + (int)search_radius;
                                if (x_start < 0) {
                                    x_start = 0;
                                }
                                if (x_end >= (int)width) {
                                    x_end = (int)width - 1;
                                }
                                for (int sample_y_idx = y_start; sample_y_idx <= y_end; ++sample_y_idx) {
                                    for (int sample_x_idx = x_start; sample_x_idx <= x_end; ++sample_x_idx) {
                                        if (metadata_tile.valid) {
                                            if ((u32)sample_x_idx >= metadata_tile.x0 &&
                                                (u32)sample_x_idx < metadata_tile.x0 + MetadataTile::TILE_SIDE &&
                                                (u32)sample_y_idx >= metadata_tile.y0 &&
                                                (u32)sample_y_idx < metadata_tile.y0 + MetadataTile::TILE_SIDE) {
                                                continue;
                                            }
                                        }
                                        usize sample_index = ((usize)sample_y_idx * (usize)width + (usize)sample_x_idx) * 3u;
                                        u32 r_val = pixel_data[sample_index + 0u];
                                        u32 g_val = pixel_data[sample_index + 1u];
                                        u32 b_val = pixel_data[sample_index + 2u];
                                        double intensity = ((double)r_val + (double)g_val + (double)b_val) / 3.0;
                                        if (intensity >= 140.0) {
                                            double weight = intensity - 139.0;
                                            double dx = (double)sample_x_idx - approx_x;
                                            double dy = (double)sample_y_idx - approx_y;
                                            double distance_sq = dx * dx + dy * dy;
                                            double falloff = 1.0 / (1.0 + distance_sq * inv_radius_sq);
                                            weight *= falloff;
                                            sum_w += weight;
                                            sum_x += weight * (double)sample_x_idx;
                                            sum_y += weight * (double)sample_y_idx;
                                        }
                                    }
                                }
                                if (sum_w > 0.0) {
                                    center_x = sum_x / sum_w;
                                    center_y = sum_y / sum_w;
                                }
                                usize point_index = (usize)row_index * (usize)fiducial_columns + (usize)col_index;
                                fiducial_storage.centers_x[point_index] = center_x;
                                fiducial_storage.centers_y[point_index] = center_y;
                            }
                        }

                        if (fiducial_storage.centers_x &&
                            fiducial_storage.centers_y &&
                            fiducial_storage.displacement_x &&
                            fiducial_storage.displacement_y) {
                            if (!has_rotation && rotation_metadata_present && width_known && height_known) {
                                double rotation_degrees_est = 0.0;
                                u64 rotation_width_est = 0u;
                                u64 rotation_height_est = 0u;
                                double rotation_margin_est = 0.0;
                                AffineTransform fiducial_affine;
                                bool rotation_success = auto_detect_rotation_from_fiducials(fiducial_storage.centers_x,
                                                                                           fiducial_storage.centers_y,
                                                                                           fiducial_columns,
                                                                                           fiducial_rows,
                                                                                            expected_width,
                                                                                            expected_height,
                                                                                            margin_pixels,
                                                                                            width,
                                                                                            height,
                                                                                           state,
                                                                                           rotation_degrees_est,
                                                                                           rotation_width_est,
                                                                                           rotation_height_est,
                                                                                            rotation_margin_est,
                                                                                            &fiducial_affine);
                                if (rotation_success) {
                                    RotationEstimateCandidate candidate;
                                    bool use_affine = state.has_skew_y_pixels && fabs(state.skew_y_pixels_value) >= 0.3;
                                    assign_rotation_candidate(candidate,
                                                              rotation_degrees_est,
                                                              rotation_width_est,
                                                              rotation_height_est,
                                                              rotation_margin_est,
                                                              true,
                                                              use_affine ? &fiducial_affine : (const AffineTransform*)0);
                                    apply_rotation_candidate(candidate);
                                }
                            }
                            for (u32 row_index = 0u; row_index < fiducial_rows; ++row_index) {
                                double t_row = (fiducial_rows == 1u) ? 0.5 : ((double)row_index / (double)(fiducial_rows - 1u));
                                double expected_y = min_y + (max_y - min_y) * t_row;
                                for (u32 col_index = 0u; col_index < fiducial_columns; ++col_index) {
                                    double t_col = (fiducial_columns == 1u) ? 0.5 : ((double)col_index / (double)(fiducial_columns - 1u));
                                    double expected_x = min_x + (max_x - min_x) * t_col;
                                    usize point_index = (usize)row_index * (usize)fiducial_columns + (usize)col_index;
                                    fiducial_storage.displacement_x[point_index] = fiducial_storage.centers_x[point_index] - expected_x;
                                    fiducial_storage.displacement_y[point_index] = fiducial_storage.centers_y[point_index] - expected_y;
                                }
                            }
                            double bias_x = 0.0;
                            double bias_y = 0.0;
                            double max_disp = 0.0;
                            if (fiducial_point_count > 0u) {
                                double accum_x = 0.0;
                                double accum_y = 0.0;
                                for (usize i = 0u; i < fiducial_point_count; ++i) {
                                    accum_x += fiducial_storage.displacement_x[i];
                                    accum_y += fiducial_storage.displacement_y[i];
                                    double dx = fiducial_storage.displacement_x[i];
                                    double dy = fiducial_storage.displacement_y[i];
                                    double dist = sqrt(dx * dx + dy * dy);
                                    if (dist > max_disp) {
                                        max_disp = dist;
                                    }
                                }
                                bias_x = accum_x / (double)fiducial_point_count;
                                bias_y = accum_y / (double)fiducial_point_count;
                                for (usize i = 0u; i < fiducial_point_count; ++i) {
                                    fiducial_storage.displacement_x[i] -= bias_x;
                                    fiducial_storage.displacement_y[i] -= bias_y;
                                }
                                if (max_disp > 0.0) {
                                    const double activation_threshold = 15.0;
                                    if (max_disp >= activation_threshold) {
                                        fiducial_displacement_active = true;
                                    }
                                }
                            }
                        }

                        fiducial_storage.column_weights = (double*)malloc((usize)sub_cols * sizeof(double));
                        fiducial_storage.row_weights = (double*)malloc((usize)sub_rows * sizeof(double));
                        fiducial_storage.column_offsets = (u64*)malloc(((usize)sub_cols + 1u) * sizeof(u64));
                        fiducial_storage.row_offsets = (u64*)malloc(((usize)sub_rows + 1u) * sizeof(u64));
                        usize cell_total = (usize)sub_cols * (usize)sub_rows;
                        fiducial_storage.cells = (cell_total > 0u)
                                                    ? (FiducialSubgridCell*)malloc(cell_total * sizeof(FiducialSubgridCell))
                                                    : (FiducialSubgridCell*)0;

                        if (fiducial_storage.column_weights && fiducial_storage.row_weights &&
                            fiducial_storage.column_offsets && fiducial_storage.row_offsets &&
                            fiducial_storage.cells && cell_total) {
                            for (u32 col_index = 0u; col_index < sub_cols; ++col_index) {
                                fiducial_storage.column_weights[col_index] = 0.0;
                            }
                            for (u32 row_index = 0u; row_index < sub_rows; ++row_index) {
                                fiducial_storage.row_weights[row_index] = 0.0;
                            }

                            for (u32 row_index = 0u; row_index < sub_rows; ++row_index) {
                                for (u32 col_index = 0u; col_index < sub_cols; ++col_index) {
                                    usize cell_index = (usize)row_index * (usize)sub_cols + (usize)col_index;
                                    FiducialSubgridCell& cell = fiducial_storage.cells[cell_index];
                                    cell.node_row = row_index;
                                    cell.node_col = col_index;
                                    usize top_left_index = (usize)row_index * (usize)fiducial_columns + (usize)col_index;
                                    usize top_right_index = top_left_index + 1u;
                                    usize bottom_left_index = top_left_index + (usize)fiducial_columns;
                                    usize bottom_right_index = bottom_left_index + 1u;
                                    double ax = fiducial_storage.centers_x[top_left_index];
                                    double ay = fiducial_storage.centers_y[top_left_index];
                                    double bx = fiducial_storage.centers_x[top_right_index];
                                    double by = fiducial_storage.centers_y[top_right_index];
                                    double cx = fiducial_storage.centers_x[bottom_left_index];
                                    double cy = fiducial_storage.centers_y[bottom_left_index];
                                    double dx = fiducial_storage.centers_x[bottom_right_index];
                                    double dy = fiducial_storage.centers_y[bottom_right_index];

                                    double vec_top_x = bx - ax;
                                    double vec_top_y = by - ay;
                                    double vec_left_x = cx - ax;
                                    double vec_left_y = cy - ay;
                                    double vec_right_x = dx - bx;
                                    double vec_right_y = dy - by;
                                    double vec_bottom_x = dx - cx;
                                    double vec_bottom_y = dy - cy;

                                    const double half = 0.5;
                                    cell.tl_x = ax - half * vec_top_x - half * vec_left_x;
                                    cell.tl_y = ay - half * vec_top_y - half * vec_left_y;
                                    cell.tr_x = bx - half * vec_top_x - half * vec_right_x;
                                    cell.tr_y = by - half * vec_top_y - half * vec_right_y;
                                    cell.bl_x = cx - half * vec_left_x - half * vec_bottom_x;
                                    cell.bl_y = cy - half * vec_left_y - half * vec_bottom_y;
                                    cell.br_x = dx - half * vec_bottom_x - half * vec_right_x;
                                    cell.br_y = dy - half * vec_bottom_y - half * vec_right_y;

                                    double top_len = sqrt((cell.tr_x - cell.tl_x) * (cell.tr_x - cell.tl_x) +
                                                          (cell.tr_y - cell.tl_y) * (cell.tr_y - cell.tl_y));
                                    double bottom_len = sqrt((cell.br_x - cell.bl_x) * (cell.br_x - cell.bl_x) +
                                                             (cell.br_y - cell.bl_y) * (cell.br_y - cell.bl_y));
                                    double avg_width = 0.5 * (top_len + bottom_len);
                                    fiducial_storage.column_weights[col_index] += avg_width;

                                    double left_len = sqrt((cell.bl_x - cell.tl_x) * (cell.bl_x - cell.tl_x) +
                                                           (cell.bl_y - cell.tl_y) * (cell.bl_y - cell.tl_y));
                                    double right_len = sqrt((cell.br_x - cell.tr_x) * (cell.br_x - cell.tr_x) +
                                                            (cell.br_y - cell.tr_y) * (cell.br_y - cell.tr_y));
                                    double avg_height = 0.5 * (left_len + right_len);
                                    fiducial_storage.row_weights[row_index] += avg_height;
                                    double expected_width = (double)(cell.col_end - cell.col_start);
                                    double expected_height = (double)(cell.row_end - cell.row_start);
                                    if (expected_width > 0.0) {
                                        double width_error = fabs(avg_width - expected_width) / expected_width;
                                        cell.horizontal_error = width_error;
                                    } else {
                                        cell.horizontal_error = 0.0;
                                    }
                                    if (expected_height > 0.0) {
                                        double height_error = fabs(avg_height - expected_height) / expected_height;
                                        cell.vertical_error = height_error;
                                    } else {
                                        cell.vertical_error = 0.0;
                                    }

                                }
                            }

                            double total_phys_width = 0.0;
                            for (u32 col_index = 0u; col_index < sub_cols; ++col_index) {
                                double avg_width = fiducial_storage.column_weights[col_index] / (double)sub_rows;
                                if (avg_width <= 0.0) {
                                    avg_width = 1.0;
                                }
                                fiducial_storage.column_weights[col_index] = avg_width;
                                total_phys_width += avg_width;
                            }
                            if (total_phys_width <= 0.0) {
                                total_phys_width = (double)sub_cols;
                            }

                            double total_phys_height = 0.0;
                            for (u32 row_index = 0u; row_index < sub_rows; ++row_index) {
                                double avg_height = fiducial_storage.row_weights[row_index] / (double)sub_cols;
                                if (avg_height <= 0.0) {
                                    avg_height = 1.0;
                                }
                                fiducial_storage.row_weights[row_index] = avg_height;
                                total_phys_height += avg_height;
                            }
                            if (total_phys_height <= 0.0) {
                                total_phys_height = (double)sub_rows;
                            }

                            fiducial_storage.column_offsets[0] = 0u;
                            double width_accum = 0.0;
                            double width_scale = (double)logical_width / total_phys_width;
                            u64 assigned_columns = 0u;
                            for (u32 col_index = 0u; col_index < sub_cols; ++col_index) {
                                width_accum += fiducial_storage.column_weights[col_index] * width_scale;
                                u64 target = (u64)(width_accum + 0.5);
                                if (target <= assigned_columns) {
                                    target = assigned_columns + 1u;
                                }
                                if ((col_index + 1u) == sub_cols) {
                                    target = logical_width;
                                } else if (target > logical_width) {
                                    target = logical_width;
                                }
                                fiducial_storage.column_offsets[col_index + 1u] = target;
                                assigned_columns = target;
                            }
                            if (fiducial_storage.column_offsets[sub_cols] != logical_width) {
                                fiducial_storage.column_offsets[sub_cols] = logical_width;
                            }

                            fiducial_storage.row_offsets[0] = 0u;
                            double height_accum = 0.0;
                            double height_scale = (double)logical_height / total_phys_height;
                            u64 assigned_rows = 0u;
                            for (u32 row_index = 0u; row_index < sub_rows; ++row_index) {
                                height_accum += fiducial_storage.row_weights[row_index] * height_scale;
                                u64 target = (u64)(height_accum + 0.5);
                                if (target <= assigned_rows) {
                                    target = assigned_rows + 1u;
                                }
                                if ((row_index + 1u) == sub_rows) {
                                    target = logical_height;
                                } else if (target > logical_height) {
                                    target = logical_height;
                                }
                                fiducial_storage.row_offsets[row_index + 1u] = target;
                                assigned_rows = target;
                            }
                            if (fiducial_storage.row_offsets[sub_rows] != logical_height) {
                                fiducial_storage.row_offsets[sub_rows] = logical_height;
                            }

                            if (state.has_fiducial_col_offsets &&
                                state.fiducial_col_offset_count == (u32)(sub_cols + 1u)) {
                                bool valid = true;
                                for (u32 i = 0u; i <= sub_cols; ++i) {
                                    u64 value = state.fiducial_col_offsets[i];
                                    if (i == 0u) {
                                        if (value != 0u) {
                                            valid = false;
                                            break;
                                        }
                                    } else {
                                        u64 prev = state.fiducial_col_offsets[i - 1u];
                                        if (value <= prev || value > logical_width) {
                                            valid = false;
                                            break;
                                        }
                                    }
                                }
                                if (valid) {
                                    for (u32 i = 0u; i <= sub_cols; ++i) {
                                        fiducial_storage.column_offsets[i] = state.fiducial_col_offsets[i];
                                    }
                                    metadata_columns_overridden = true;
                                }
                            }
                            if (state.has_fiducial_row_offsets &&
                                state.fiducial_row_offset_count == (u32)(sub_rows + 1u)) {
                                bool valid = true;
                                for (u32 i = 0u; i <= sub_rows; ++i) {
                                    u64 value = state.fiducial_row_offsets[i];
                                    if (i == 0u) {
                                        if (value != 0u) {
                                            valid = false;
                                            break;
                                        }
                                    } else {
                                        u64 prev = state.fiducial_row_offsets[i - 1u];
                                        if (value <= prev || value > logical_height) {
                                            valid = false;
                                            break;
                                        }
                                    }
                                }
                                if (valid) {
                                    for (u32 i = 0u; i <= sub_rows; ++i) {
                                        fiducial_storage.row_offsets[i] = state.fiducial_row_offsets[i];
                                    }
                                    metadata_rows_overridden = true;
                                }
                            }

                            for (u32 row_index = 0u; row_index < sub_rows; ++row_index) {
                                for (u32 col_index = 0u; col_index < sub_cols; ++col_index) {
                                    usize cell_index = (usize)row_index * (usize)sub_cols + (usize)col_index;
                                    FiducialSubgridCell& cell = fiducial_storage.cells[cell_index];
                                    cell.row_start = fiducial_storage.row_offsets[row_index];
                                    cell.row_end = fiducial_storage.row_offsets[row_index + 1u];
                                    cell.col_start = fiducial_storage.column_offsets[col_index];
                                    cell.col_end = fiducial_storage.column_offsets[col_index + 1u];
                                }
                            }

                            use_fiducial_subgrid = true;
                            fiducial_cells = fiducial_storage.cells;
                            fiducial_column_offsets = fiducial_storage.column_offsets;
                            fiducial_row_offsets = fiducial_storage.row_offsets;
                            fiducial_subgrid_columns = sub_cols;
                            fiducial_subgrid_rows = sub_rows;
                            fiducial_column_count = fiducial_columns;
                            fiducial_row_count = fiducial_rows;
                        }
                    } else {
                        if (fiducial_storage.centers_x) free(fiducial_storage.centers_x);
                        if (fiducial_storage.centers_y) free(fiducial_storage.centers_y);
                        if (fiducial_storage.displacement_x) free(fiducial_storage.displacement_x);
                        if (fiducial_storage.displacement_y) free(fiducial_storage.displacement_y);
                        fiducial_storage.centers_x = 0;
                        fiducial_storage.centers_y = 0;
                        fiducial_storage.displacement_x = 0;
                        fiducial_storage.displacement_y = 0;
                    }
                }
            }
        }
    }

    if (debug_logging_enabled()) {
        char column_buf[32];
        char row_buf[32];
        u64_to_ascii(state.has_fiducial_columns ? state.fiducial_columns_value : 0u, column_buf, sizeof(column_buf));
        u64_to_ascii(state.has_fiducial_rows ? state.fiducial_rows_value : 0u, row_buf, sizeof(row_buf));
        console_write(2, "debug fiducials: metadata_cols=");
        console_write(2, column_buf);
        console_write(2, " metadata_rows=");
        console_write(2, row_buf);
        console_write(2, " subgrid_active=");
        console_write(2, use_fiducial_subgrid ? "yes" : "no");
        console_write(2, " overrides=");
        console_write(2, metadata_columns_overridden ? "cols" : "-");
        console_write(2, "/");
        console_write(2, metadata_rows_overridden ? "rows" : "-");
        console_write(2, " displacement=");
        console_line(2, fiducial_displacement_active ? "yes" : "no");
    }
    bool prefer_nearest_sampling = false;
    if (use_fiducial_subgrid && metadata_columns_overridden && metadata_rows_overridden) {
        prefer_nearest_sampling = true;
    }

    if (force_disable_fiducial_subgrid) {
        use_fiducial_subgrid = false;
        prefer_nearest_sampling = false;
    }

    bool simple_page = (!has_rotation &&
                        !has_skew &&
                        !state.has_affine_transform &&
                        scale_x_integer && scale_y_integer &&
                        scale_x_int == 1u && scale_y_int == 1u);
    if (simple_page) {
        use_fiducial_subgrid = false;
        fiducial_displacement_active = false;
        prefer_nearest_sampling = false;
    }

    u32 active_row_cell = 0u;
    u64 active_row_start = use_fiducial_subgrid ? fiducial_row_offsets[0] : 0u;
    u64 active_row_end = use_fiducial_subgrid && fiducial_subgrid_rows > 0u
                             ? fiducial_row_offsets[1]
                             : data_height;
    const u8* reservation_mask = (skip_reserved_pixels && fiducial_mask.data)
                                     ? fiducial_mask.data
                                     : (const u8*)0;
    usize reservation_size = reservation_mask ? fiducial_mask.size : 0u;

    for (u64 logical_row = 0u; logical_row < data_height; ++logical_row) {
        if (use_fiducial_subgrid) {
            while (active_row_cell + 1u < fiducial_subgrid_rows && logical_row >= active_row_end) {
                ++active_row_cell;
                active_row_start = fiducial_row_offsets[active_row_cell];
                active_row_end = fiducial_row_offsets[active_row_cell + 1u];
            }
            if (active_row_end <= active_row_start) {
                active_row_end = active_row_start + 1u;
            }
        }

        u32 active_col_cell = 0u;
        u64 active_col_start = use_fiducial_subgrid ? fiducial_column_offsets[0] : 0u;
        u64 active_col_end = use_fiducial_subgrid && fiducial_subgrid_columns > 0u
                                 ? fiducial_column_offsets[1]
                                 : logical_width;
        FiducialSubgridCell* row_cells = use_fiducial_subgrid
                                             ? (fiducial_cells + ((usize)active_row_cell * (usize)fiducial_subgrid_columns))
                                             : (FiducialSubgridCell*)0;

        for (u64 logical_col = 0u; logical_col < logical_width; ++logical_col) {
            if (use_fiducial_subgrid) {
                while (active_col_cell + 1u < fiducial_subgrid_columns && logical_col >= active_col_end) {
                    ++active_col_cell;
                    active_col_start = fiducial_column_offsets[active_col_cell];
                    active_col_end = fiducial_column_offsets[active_col_cell + 1u];
                }
                if (active_col_end <= active_col_start) {
                    active_col_end = active_col_start + 1u;
                }
            }
            bool reserved_pixel = false;
            if (reservation_mask) {
                usize mask_index = ((usize)logical_row * (usize)logical_width) + (usize)logical_col;
                if (mask_index < reservation_size && reservation_mask[mask_index]) {
                    reserved_pixel = true;
                }
            }
            if (reserved_pixel) {
                continue;
            }

            double base_sample_row = ((double)logical_row + 0.5) * scale_yd - 0.5;
            double base_sample_col = ((double)logical_col + 0.5) * scale_xd - 0.5;
            double sample_row = base_sample_row;
            double sample_col = base_sample_col;
            if (use_fiducial_subgrid &&
                fiducial_displacement_active &&
                fiducial_storage.displacement_x &&
                fiducial_storage.displacement_y &&
                fiducial_column_count > 1u &&
                fiducial_row_count > 1u) {
                FiducialSubgridCell& cell = row_cells[active_col_cell];
                double local_u = 0.5;
                double local_v = 0.5;
                if (cell.col_end > cell.col_start) {
                    local_u = (((double)(logical_col - cell.col_start) + 0.5) /
                               (double)(cell.col_end - cell.col_start));
                }
                if (cell.row_end > cell.row_start) {
                    local_v = (((double)(logical_row - cell.row_start) + 0.5) /
                               (double)(cell.row_end - cell.row_start));
                }
                double clamp_margin_u = prefer_nearest_sampling
                                            ? ((cell.col_end > cell.col_start)
                                                   ? (0.5 / (double)(cell.col_end - cell.col_start))
                                                   : 0.0005)
                                            : 0.0005;
                double clamp_margin_v = prefer_nearest_sampling
                                            ? ((cell.row_end > cell.row_start)
                                                   ? (0.5 / (double)(cell.row_end - cell.row_start))
                                                   : 0.0005)
                                            : 0.0005;
                if (clamp_margin_u > 0.2) clamp_margin_u = 0.2;
                if (clamp_margin_v > 0.2) clamp_margin_v = 0.2;
                double max_u = 1.0 - clamp_margin_u;
                double max_v = 1.0 - clamp_margin_v;
                if (local_u < clamp_margin_u) local_u = clamp_margin_u;
                if (local_u > max_u) local_u = max_u;
                if (local_v < clamp_margin_v) local_v = clamp_margin_v;
                if (local_v > max_v) local_v = max_v;
                u32 node_row = cell.node_row;
                u32 node_col = cell.node_col;
                double horizontal_threshold = prefer_nearest_sampling ? 0.03 : 0.02;
                double vertical_threshold = prefer_nearest_sampling ? 0.03 : 0.02;
                double horiz_strength = 0.0;
                double vert_strength = 0.0;
                if (horizontal_threshold > 0.0) {
                    horiz_strength = cell.horizontal_error / horizontal_threshold;
                    if (horiz_strength > 1.0) horiz_strength = 1.0;
                }
                if (vertical_threshold > 0.0) {
                    vert_strength = cell.vertical_error / vertical_threshold;
                    if (vert_strength > 1.0) vert_strength = 1.0;
                }
                if (node_row + 1u < fiducial_row_count && node_col + 1u < fiducial_column_count) {
                    usize idx_tl = (usize)node_row * (usize)fiducial_column_count + (usize)node_col;
                    usize idx_tr = idx_tl + 1u;
                    usize idx_bl = idx_tl + (usize)fiducial_column_count;
                    usize idx_br = idx_bl + 1u;
                    double disp_tl_x = fiducial_storage.displacement_x[idx_tl];
                    double disp_tr_x = fiducial_storage.displacement_x[idx_tr];
                    double disp_bl_x = fiducial_storage.displacement_x[idx_bl];
                    double disp_br_x = fiducial_storage.displacement_x[idx_br];
                    double disp_tl_y = fiducial_storage.displacement_y[idx_tl];
                    double disp_tr_y = fiducial_storage.displacement_y[idx_tr];
                    double disp_bl_y = fiducial_storage.displacement_y[idx_bl];
                    double disp_br_y = fiducial_storage.displacement_y[idx_br];
                    double top_disp_x = disp_tl_x * (1.0 - local_u) + disp_tr_x * local_u;
                    double bottom_disp_x = disp_bl_x * (1.0 - local_u) + disp_br_x * local_u;
                    double top_disp_y = disp_tl_y * (1.0 - local_u) + disp_tr_y * local_u;
                    double bottom_disp_y = disp_bl_y * (1.0 - local_u) + disp_br_y * local_u;
                    double disp_x = (top_disp_x * (1.0 - local_v) + bottom_disp_x * local_v) * horiz_strength;
                    double disp_y = (top_disp_y * (1.0 - local_v) + bottom_disp_y * local_v) * vert_strength;
                    sample_col = base_sample_col + disp_x;
                    sample_row = base_sample_row + disp_y;
                }
            }
            double warp_dx = sample_col - base_sample_col;
            double warp_dy = sample_row - base_sample_row;

            const u8* rgb = 0;
            u8 affine_rgb[3];
            u8 rotated_rgb[3];
            u8 skew_rgb[3];
            u8 averaged_rgb[3];
            // Fast path: undistorted scale-only pages benefit from box averaging over each
            // logical cell to survive print/scan blur (e.g., 2.5x stretch in case 0016).
            if (!has_rotation &&
                !has_skew &&
                !state.has_affine_transform &&
                scale_xd > 1.01 &&
                scale_yd > 1.01 &&
                analysis_width > 0u &&
                analysis_height > 0u) {
                double cell_x0 = (double)logical_col * scale_xd;
                double cell_x1 = (double)(logical_col + 1u) * scale_xd;
                double cell_y0 = (double)logical_row * scale_yd;
                double cell_y1 = (double)(logical_row + 1u) * scale_yd;
                int xi0 = (int)floor(cell_x0);
                int xi1 = (int)ceil(cell_x1);
                int yi0 = (int)floor(cell_y0);
                int yi1 = (int)ceil(cell_y1);
                if (xi0 < 0) xi0 = 0;
                if (yi0 < 0) yi0 = 0;
                if (xi1 > (int)analysis_width) xi1 = (int)analysis_width;
                if (yi1 > (int)analysis_height) yi1 = (int)analysis_height;
                u64 sum_r = 0u, sum_g = 0u, sum_b = 0u;
                u64 count = 0u;
                for (int yy = yi0; yy < yi1; ++yy) {
                    double cy = (double)yy + 0.5;
                    if (cy < cell_y0 || cy >= cell_y1) continue;
                    for (int xx = xi0; xx < xi1; ++xx) {
                        double cx = (double)xx + 0.5;
                        if (cx < cell_x0 || cx >= cell_x1) continue;
                        usize idx = ((usize)yy * (usize)pixel_stride + (usize)xx) * 3u;
                        sum_r += (u64)pixel_data[idx + 0u];
                        sum_g += (u64)pixel_data[idx + 1u];
                        sum_b += (u64)pixel_data[idx + 2u];
                        ++count;
                    }
                }
                if (count > 0u) {
                    averaged_rgb[0] = (u8)((sum_r + (count / 2u)) / count);
                    averaged_rgb[1] = (u8)((sum_g + (count / 2u)) / count);
                    averaged_rgb[2] = (u8)((sum_b + (count / 2u)) / count);
                    rgb = averaged_rgb;
                }
            }

            if (state.has_affine_transform) {
                double lx = ((double)logical_col + 0.5);
                double ly = ((double)logical_row + 0.5);
                double sample_x = state.affine_transform.a00 * lx +
                                  state.affine_transform.a01 * ly +
                                  state.affine_transform.tx + warp_dx;
                double sample_y = state.affine_transform.a10 * lx +
                                  state.affine_transform.a11 * ly +
                                  state.affine_transform.ty + warp_dy;
                if (state.has_skew_y_pixels) {
                    double span = state.has_skew_src_width ? (double)state.skew_src_width_value : (double)width;
                    if (span < 1.0) {
                        span = (double)width;
                    }
                    if (span > 1.0) {
                        double norm_col = sample_x / span;
                        if (norm_col < 0.0) norm_col = 0.0;
                        if (norm_col > 1.0) norm_col = 1.0;
                        sample_y += state.skew_y_pixels_value * norm_col;
                    }
                }
                if (sample_x < 0.0) sample_x = 0.0;
                if (sample_y < 0.0) sample_y = 0.0;
                double max_sample_x = (width > 0u) ? (double)(width - 1u) : 0.0;
                double max_sample_y = (height > 0u) ? (double)(height - 1u) : 0.0;
                if (sample_x > max_sample_x) sample_x = max_sample_x;
                if (sample_y > max_sample_y) sample_y = max_sample_y;
                unsigned x0 = (unsigned)floor(sample_x);
                unsigned y0 = (unsigned)floor(sample_y);
                unsigned x1 = (x0 + 1u < width) ? (x0 + 1u) : x0;
                unsigned y1 = (y0 + 1u < height) ? (y0 + 1u) : y0;
                double fx = sample_x - (double)x0;
                double fy = sample_y - (double)y0;
                usize idx00 = ((usize)y0 * (usize)width + (usize)x0) * 3u;
                usize idx10 = ((usize)y0 * (usize)width + (usize)x1) * 3u;
                usize idx01 = ((usize)y1 * (usize)width + (usize)x0) * 3u;
                usize idx11 = ((usize)y1 * (usize)width + (usize)x1) * 3u;
                for (u32 channel = 0u; channel < 3u; ++channel) {
                    double v00 = (double)pixel_data[idx00 + channel];
                    double v10 = (double)pixel_data[idx10 + channel];
                    double v01 = (double)pixel_data[idx01 + channel];
                    double v11 = (double)pixel_data[idx11 + channel];
                    double top = v00 + (v10 - v00) * fx;
                    double bottom = v01 + (v11 - v01) * fx;
                    double value = top + (bottom - top) * fy;
                    if (value < 0.0) {
                        value = 0.0;
                    }
                    if (value > 255.0) {
                        value = 255.0;
                    }
                    affine_rgb[channel] = (u8)(value + 0.5);
                }
                rgb = affine_rgb;
            } else if (has_rotation) {
                if (rotation_width == 0u || rotation_height == 0u || rotated_width == 0u || rotated_height == 0u) {
                    return false;
                }
                double local_sample_col = sample_col;
                double local_sample_row = sample_row;
                if (has_skew) {
                    double normalized_row = (skew_src_height > 1u)
                                                ? (local_sample_row / (double)(skew_src_height - 1u))
                                                : 0.0;
                    double row_shift = state.has_skew_x_pixels
                                           ? (skew_top * (1.0 - normalized_row) + skew_bottom * normalized_row)
                                           : 0.0;
                    double normalized_col = (skew_src_width > 1u)
                                                ? (local_sample_col / (double)(skew_src_width - 1u))
                                                : 0.0;
                    double col_shift = state.has_skew_y_pixels
                                           ? (state.skew_y_pixels_value * normalized_col)
                                           : 0.0;
                    local_sample_col += state.has_skew_margin_x ? (skew_margin + row_shift) : row_shift;
                    local_sample_row += col_shift;
                }
                double dx = local_sample_col - rotation_center_x;
                double dy = local_sample_row - rotation_center_y;
                double sample_x = dx * rotation_cos - dy * rotation_sin + rotation_offset_x;
                double sample_y = dx * rotation_sin + dy * rotation_cos + rotation_offset_y;
                if (sample_x < 0.0) sample_x = 0.0;
                if (sample_y < 0.0) sample_y = 0.0;
                double max_sample_x = (rotated_width > 0u) ? (double)(rotated_width - 1u) : 0.0;
                double max_sample_y = (rotated_height > 0u) ? (double)(rotated_height - 1u) : 0.0;
                if (sample_x > max_sample_x) sample_x = max_sample_x;
                if (sample_y > max_sample_y) sample_y = max_sample_y;
                unsigned x0 = (unsigned)floor(sample_x);
                unsigned y0 = (unsigned)floor(sample_y);
                unsigned x1 = (x0 + 1u < rotated_width) ? (x0 + 1u) : x0;
                unsigned y1 = (y0 + 1u < rotated_height) ? (y0 + 1u) : y0;
                double fx = sample_x - (double)x0;
                double fy = sample_y - (double)y0;
                usize idx00 = ((usize)y0 * (usize)rotated_width + (usize)x0) * 3u;
                usize idx10 = ((usize)y0 * (usize)rotated_width + (usize)x1) * 3u;
                usize idx01 = ((usize)y1 * (usize)rotated_width + (usize)x0) * 3u;
                usize idx11 = ((usize)y1 * (usize)rotated_width + (usize)x1) * 3u;
                for (u32 channel = 0u; channel < 3u; ++channel) {
                    double v00 = (double)pixel_data[idx00 + channel];
                    double v10 = (double)pixel_data[idx10 + channel];
                    double v01 = (double)pixel_data[idx01 + channel];
                    double v11 = (double)pixel_data[idx11 + channel];
                    double top = v00 + (v10 - v00) * fx;
                    double bottom = v01 + (v11 - v01) * fx;
                    double value = top + (bottom - top) * fy;
                    if (value < 0.0) {
                        value = 0.0;
                    }
                    if (value > 255.0) {
                        value = 255.0;
                    }
                    rotated_rgb[channel] = (u8)(value + 0.5);
                }
                rgb = rotated_rgb;
            } else if (has_skew) {
                if (sample_row < 0.0) sample_row = 0.0;
                if (sample_col < 0.0) sample_col = 0.0;
                double max_row = (analysis_height > 0u) ? (double)(analysis_height - 1u) : 0.0;
                double max_col = (analysis_width > 0u) ? (double)(analysis_width - 1u) : 0.0;
                if (sample_row > max_row) sample_row = max_row;
                if (sample_col > max_col) sample_col = max_col;
                double normalized_row = (skew_src_height > 1u) ? (sample_row / (double)(skew_src_height - 1u)) : 0.0;
                double row_shift = state.has_skew_x_pixels
                                       ? (skew_top * (1.0 - normalized_row) + skew_bottom * normalized_row)
                                       : 0.0;
                double normalized_col = (skew_src_width > 1u) ? (sample_col / (double)(skew_src_width - 1u)) : 0.0;
                double col_shift = state.has_skew_y_pixels
                                       ? (state.skew_y_pixels_value * normalized_col)
                                       : 0.0;
                double dest_x = sample_col + (state.has_skew_margin_x ? (skew_margin + row_shift) : row_shift);
                double dest_y = sample_row + col_shift + 0.5;
                if (dest_x < 0.0) dest_x = 0.0;
                if (dest_y < 0.0) dest_y = 0.0;
                double max_dest_x = (width > 0u) ? (double)(width - 1u) : 0.0;
                double max_dest_y = (height > 0u) ? (double)(height - 1u) : 0.0;
                if (dest_x > max_dest_x) dest_x = max_dest_x;
                if (dest_y > max_dest_y) dest_y = max_dest_y;
                unsigned nearest_x = (unsigned)(dest_x + 0.5);
                unsigned nearest_y = (unsigned)(dest_y + 0.5);
                if (nearest_x >= width) {
                    nearest_x = width - 1u;
                }
                if (nearest_y >= height) {
                    nearest_y = height - 1u;
                }
                usize idx = ((usize)nearest_y * (usize)width + (usize)nearest_x) * 3u;
                for (u32 channel = 0u; channel < 3u; ++channel) {
                    skew_rgb[channel] = pixel_data[idx + channel];
                }
                rgb = skew_rgb;
            } else {
                if (sample_row < 0.0) sample_row = 0.0;
                if (sample_col < 0.0) sample_col = 0.0;
                double max_row = (analysis_height > 0u) ? (double)(analysis_height - 1u) : 0.0;
                double max_col = (analysis_width > 0u) ? (double)(analysis_width - 1u) : 0.0;
                if (sample_row > max_row) sample_row = max_row;
                if (sample_col > max_col) sample_col = max_col;
                if (use_fiducial_subgrid) {
                    if (prefer_nearest_sampling) {
                        u64 raw_row = (u64)(sample_row + 0.5);
                        u64 raw_col = (u64)(sample_col + 0.5);
                        if (raw_row >= (u64)analysis_height) {
                            raw_row = (analysis_height > 0u) ? (analysis_height - 1u) : 0u;
                        }
                        if (raw_col >= (u64)analysis_width) {
                            raw_col = (analysis_width > 0u) ? (analysis_width - 1u) : 0u;
                        }
                        u64 pixel_index = (raw_row * pixel_stride) + raw_col;
                        if (pixel_index >= raw_pixel_count) {
                            return false;
                        }
                        rgb = pixel_data + (usize)(pixel_index * 3u);
                    } else {
                        unsigned x0 = (unsigned)floor(sample_col);
                        unsigned y0 = (unsigned)floor(sample_row);
                        unsigned x1 = (x0 + 1u < analysis_width) ? (x0 + 1u) : x0;
                        unsigned y1 = (y0 + 1u < analysis_height) ? (y0 + 1u) : y0;
                        double fx = sample_col - (double)x0;
                        double fy = sample_row - (double)y0;
                        usize idx00 = ((usize)y0 * (usize)pixel_stride + (usize)x0) * 3u;
                        usize idx10 = ((usize)y0 * (usize)pixel_stride + (usize)x1) * 3u;
                        usize idx01 = ((usize)y1 * (usize)pixel_stride + (usize)x0) * 3u;
                        usize idx11 = ((usize)y1 * (usize)pixel_stride + (usize)x1) * 3u;
                        u8 interp_rgb[3];
                        for (u32 channel = 0u; channel < 3u; ++channel) {
                            double v00 = (double)pixel_data[idx00 + channel];
                            double v10 = (double)pixel_data[idx10 + channel];
                            double v01 = (double)pixel_data[idx01 + channel];
                            double v11 = (double)pixel_data[idx11 + channel];
                            double top = v00 + (v10 - v00) * fx;
                            double bottom = v01 + (v11 - v01) * fx;
                            double value = top + (bottom - top) * fy;
                            if (value < 0.0) value = 0.0;
                            if (value > 255.0) value = 255.0;
                            interp_rgb[channel] = (u8)(value + 0.5);
                        }
                        rgb = interp_rgb;
                    }
                } else {
                    u64 raw_row = (u64)(sample_row + 0.5);
                    u64 raw_col = (u64)(sample_col + 0.5);
                    u64 pixel_index = (raw_row * pixel_stride) + raw_col;
                    if (pixel_index >= raw_pixel_count) {
                        return false;
                    }
                    rgb = pixel_data + (usize)(pixel_index * 3u);
                }
            }

            if (use_custom_palette) {
                if (digits_target > 0u && custom_digits.size >= (usize)digits_target) {
                    continue;
                }
                u32 symbol = 0u;
                if (!map_rgb_to_custom_symbol(active_mapping, rgb, symbol)) {
                    return false;
                }
                if (digits_target > 0u) {
                    custom_digits.data[custom_digits.size++] = (u8)symbol;
                }
                continue;
            }
            u32 samples_raw[3] = {0u, 0u, 0u};
            if (!map_rgb_to_samples(color_mode, rgb, samples_raw)) {
                return false;
            }
            for (u8 sample_index = 0u; sample_index < samples_per_pixel; ++sample_index) {
                u32 sample = samples_raw[sample_index];
                if (!writer.write_bits(sample, sample_bits)) {
                    return false;
                }
            }
        }
    }
    if (use_custom_palette) {
        u64 digits_available = (u64)custom_digits.size;
        if (digits_target > 0u && digits_available == 0u) {
            return false;
        }
        if (state.has_page_symbols && digits_target > 0u && digits_available < digits_target) {
            return false;
        }
        if (!state.has_page_symbols && digits_available > 0u) {
            state.has_page_symbols = true;
            state.page_symbols_value = digits_available;
        }
        const u8* digit_data_ptr = digits_available ? custom_digits.data : (const u8*)0;
        u64 bit_target = capacity_with_reserve;
        if (state.has_page_bits && state.page_bits_value > 0u && state.page_bits_value <= bit_target) {
            bit_target = state.page_bits_value;
        }
        u32 digits_base = custom_palette_base ? custom_palette_base : mapping_custom_palette_base(active_mapping);
        if (digits_base < 2u) {
            return false;
        }
        if (!base_digits_to_bits(digit_data_ptr,
                                 digits_available,
                                 digits_base,
                                 bit_target,
                                 frame_bits)) {
            return false;
        }
        u64 frame_bits_effective = bit_target;
        if (frame_bits_effective == 0u) {
            frame_bits_effective = (u64)frame_bits.size * 8u;
        }
        frame_bit_count = frame_bits_effective;
        if (color_mode == 3u && frame_bits.size) {
            for (usize i = 0u; i < frame_bits.size; ++i) {
                u8 rotate = (u8)((i % 3u) + 1u);
                frame_bits.data[i] = rotate_right_u8(frame_bits.data[i], rotate);
            }
        }
        metadata_out = state;
        metadata_out.data = 0;
        metadata_out.size = 0u;
        metadata_out.cursor = 0u;
        return true;
    }
    // Do not force byte alignment here. The multi-page assembly code consumes
    // `page_bit_count` bits exactly; padding to a byte boundary would inject
    // extra bits between pages and corrupt the global bitstream when page
    // capacity is not a multiple of 8.
    if (color_mode == 3u) {
        usize total_bytes = writer.byte_size();
        if (total_bytes) {
            u8* data_bytes = writer.buffer.data;
            if (!data_bytes && total_bytes) {
                return false;
            }
            for (usize i = 0u; i < total_bytes; ++i) {
                u8 rotate = (u8)((i % 3u) + 1u);
                data_bytes[i] = rotate_right_u8(data_bytes[i], rotate);
            }
        }
    }
    frame_bit_count = writer.bit_size();
    usize frame_bytes = writer.byte_size();
    frame_bits.release();
    if (frame_bytes && !frame_bits.ensure(frame_bytes)) {
        return false;
    }
    const u8* writer_data = writer.data();
    for (usize i = 0u; i < frame_bytes; ++i) {
        frame_bits.data[i] = writer_data ? writer_data[i] : 0u;
    }
    frame_bits.size = frame_bytes;

    // Fallback: if the reconstructed header appears empty on an undistorted page, rebuild
    // the frame bits with a direct raster walk (skipping only the reservation mask).
    auto preview_header_bits = [&](const makocode::ByteBuffer& buffer, u64 bits) -> u64 {
        if (!buffer.data || bits == 0u) return 0u;
        makocode::BitReader preview_reader;
        preview_reader.reset(buffer.data, bits);
        return preview_reader.read_bits((bits >= 64u) ? 64u : bits);
    };
    u64 header_preview = preview_header_bits(frame_bits, frame_bit_count);
    bool simple_raster_allowed = (!use_custom_palette &&
                                  scale_x_integer && scale_y_integer &&
                                  scale_x_int == 1u && scale_y_int == 1u);
    u64 expected_payload_bits = (state.has_page_bits && state.page_bits_value > 0u)
                                    ? state.page_bits_value
                                    : 0u;
    // Rebuild the frame bits using a direct raster walk when the header appears
    // empty or when the sampled bitstream is shorter than the nominal capacity.
    if (simple_raster_allowed &&
        (header_preview == 0u ||
         (capacity_with_reserve > 0u && frame_bit_count < capacity_with_reserve) ||
         (expected_payload_bits > 0u && header_preview > 0u && header_preview != expected_payload_bits))) {
        makocode::BitWriter simple_writer;
        for (u64 logical_row = 0u; logical_row < data_height; ++logical_row) {
            for (u64 logical_col = 0u; logical_col < logical_width; ++logical_col) {
                bool reserved_pixel = false;
                if (reservation_mask) {
                    usize mask_index = ((usize)logical_row * (usize)logical_width) + (usize)logical_col;
                    if (mask_index < reservation_size && reservation_mask[mask_index]) {
                        reserved_pixel = true;
                    }
                }
                if (reserved_pixel) {
                    continue;
                }
                usize pixel_index = ((usize)logical_row * (usize)raw_width + (usize)logical_col) * 3u;
                u32 samples_raw[3] = {0u, 0u, 0u};
                if (!map_rgb_to_samples(color_mode, pixel_data + pixel_index, samples_raw)) {
                    continue;
                }
                for (u8 sample_index = 0u; sample_index < samples_per_pixel; ++sample_index) {
                    u32 sample = samples_raw[sample_index];
                    if (!simple_writer.write_bits(sample, sample_bits)) {
                        return false;
                    }
                }
            }
        }
        frame_bit_count = simple_writer.bit_size();
        usize simple_bytes = simple_writer.byte_size();
        frame_bits.release();
        if (simple_bytes && !frame_bits.ensure(simple_bytes)) {
            return false;
        }
        const u8* simple_data = simple_writer.data();
        for (usize i = 0u; i < simple_bytes; ++i) {
            frame_bits.data[i] = simple_data ? simple_data[i] : 0u;
        }
        frame_bits.size = simple_bytes;
    }
    if (debug_logging_enabled() && frame_bit_count >= 1u) {
        makocode::BitReader header_reader;
        header_reader.reset(frame_bits.data, frame_bit_count);
        u64 raw_header = header_reader.read_bits((frame_bit_count >= 64u) ? 64u : frame_bit_count);
        char header_buf[32];
        u64_to_ascii(raw_header, header_buf, sizeof(header_buf));
        console_write(2, "debug extracted frame header=");
        console_line(2, header_buf);
    }
    metadata_out = state;
    metadata_out.data = 0;
    metadata_out.size = 0u;
    metadata_out.cursor = 0u;
    return true;
}

static bool append_bits_from_buffer(makocode::BitWriter& writer,
                                    const u8* data,
                                    u64 bit_count) {
    for (u64 bit_index = 0u; bit_index < bit_count; ++bit_index) {
        u8 bit_value = 0u;
        if (data) {
            usize byte_index = (usize)(bit_index >> 3u);
            u8 mask = (u8)(1u << (bit_index & 7u));
            bit_value = (data[byte_index] & mask) ? 1u : 0u;
        }
        if (!writer.write_bit(bit_value)) {
            return false;
        }
    }
    return true;
}

static void log_footer_stripe_mismatch(const char* label,
                                       u64 first_value,
                                       u64 second_value) {
    if (!debug_logging_enabled()) {
        return;
    }
    char first_buffer[32];
    char second_buffer[32];
    u64_to_ascii(first_value, first_buffer, sizeof(first_buffer));
    u64_to_ascii(second_value, second_buffer, sizeof(second_buffer));
    console_write(2, "debug footer stripe mismatch ");
    console_write(2, label);
    console_write(2, ": first=");
    console_write(2, first_buffer);
    console_write(2, " second=");
    console_line(2, second_buffer);
}

static bool footer_stripe_values_equal(const FooterStripe::Values& a,
                                       const FooterStripe::Values& b) {
    if (a.page_bits != b.page_bits) {
        log_footer_stripe_mismatch("page_bits", a.page_bits, b.page_bits);
        return false;
    }
    if (a.page_count != b.page_count) {
        log_footer_stripe_mismatch("page_count", a.page_count, b.page_count);
        return false;
    }
    if (a.page_width_pixels != b.page_width_pixels) {
        log_footer_stripe_mismatch("page_width_px", a.page_width_pixels, b.page_width_pixels);
        return false;
    }
    if (a.page_height_pixels != b.page_height_pixels) {
        log_footer_stripe_mismatch("page_height_px", a.page_height_pixels, b.page_height_pixels);
        return false;
    }
	if (a.footer_rows != b.footer_rows) {
	    log_footer_stripe_mismatch("footer_rows", a.footer_rows, b.footer_rows);
	    return false;
	}
	if (a.fiducial_marker_size_pixels != b.fiducial_marker_size_pixels) {
	    log_footer_stripe_mismatch("fiducial_marker_size_px", a.fiducial_marker_size_pixels, b.fiducial_marker_size_pixels);
	    return false;
	}
		if (a.ecc_enabled != b.ecc_enabled) {
		    log_footer_stripe_mismatch("ecc", a.ecc_enabled ? 1ull : 0ull, b.ecc_enabled ? 1ull : 0ull);
		    return false;
		}
    if (a.ecc_block_data != b.ecc_block_data) {
        log_footer_stripe_mismatch("ecc_block_data", a.ecc_block_data, b.ecc_block_data);
        return false;
    }
    if (a.ecc_parity != b.ecc_parity) {
        log_footer_stripe_mismatch("ecc_parity", a.ecc_parity, b.ecc_parity);
        return false;
    }
    if (a.ecc_block_count != b.ecc_block_count) {
        log_footer_stripe_mismatch("ecc_block_count", a.ecc_block_count, b.ecc_block_count);
        return false;
    }
    if (a.ecc_original_bytes != b.ecc_original_bytes) {
        log_footer_stripe_mismatch("ecc_original_bytes", a.ecc_original_bytes, b.ecc_original_bytes);
        return false;
    }
    if (a.has_palette != b.has_palette) {
        log_footer_stripe_mismatch("palette_flag", a.has_palette ? 1ull : 0ull, b.has_palette ? 1ull : 0ull);
        return false;
    }
    if (a.has_palette) {
        if (a.palette_base != b.palette_base) {
            log_footer_stripe_mismatch("palette_base", a.palette_base, b.palette_base);
            return false;
        }
        if (a.palette_length != b.palette_length) {
            log_footer_stripe_mismatch("palette_length", a.palette_length, b.palette_length);
            return false;
        }
        for (u16 i = 0u; i < a.palette_length && i < b.palette_length; ++i) {
            if (a.palette_bytes[i] != b.palette_bytes[i]) {
                log_footer_stripe_mismatch("palette_bytes", a.palette_bytes[i], b.palette_bytes[i]);
                return false;
            }
        }
    }
    return true;
}

static void stripe_metadata_log_mismatch(const char* label,
                                         u64 header_value,
                                         u64 stripe_value) {
    if (!debug_logging_enabled()) {
        return;
    }
    char header_buffer[32];
    char stripe_buffer[32];
    u64_to_ascii(header_value, header_buffer, sizeof(header_buffer));
    u64_to_ascii(stripe_value, stripe_buffer, sizeof(stripe_buffer));
    console_write(2, "debug footer stripe mismatch ");
    console_write(2, label);
    console_write(2, ": header=");
    console_write(2, header_buffer);
    console_write(2, " stripe=");
    console_line(2, stripe_buffer);
}

static void update_stripe_metadata_field(const char* label,
                                         bool& flag,
                                         u64& target,
                                         u64 value) {
    if (flag && target != value) {
        stripe_metadata_log_mismatch(label, target, value);
    }
    flag = true;
    target = value;
}

static void apply_footer_stripe_metadata(PpmParserState& state,
                                         const FooterStripe::Values& values) {
    // The footer stripe stores the payload bit-count that appears in the 64-bit frame
    // header. This lets us recover payload length without relying on PPM comments, and
    // still derive the total frame bit-count (payload + 64 header bits) for page
    // extraction heuristics.
    const u64 payload_bits = values.page_bits;
    const u64 frame_bits = payload_bits + 64u;
    update_stripe_metadata_field("MAKOCODE_BITS", state.has_bits, state.bits_value, payload_bits);
    update_stripe_metadata_field("MAKOCODE_PAGE_BITS", state.has_page_bits, state.page_bits_value, frame_bits);
    update_stripe_metadata_field("page_count", state.has_page_count, state.page_count_value, values.page_count);
    update_stripe_metadata_field("page_index", state.has_page_index, state.page_index_value, values.page_index);
	    update_stripe_metadata_field("page_width_px", state.has_page_width_pixels, state.page_width_pixels_value, values.page_width_pixels);
	    update_stripe_metadata_field("page_height_px", state.has_page_height_pixels, state.page_height_pixels_value, values.page_height_pixels);
	    update_stripe_metadata_field("MAKOCODE_FOOTER_ROWS", state.has_footer_rows, state.footer_rows_value, values.footer_rows);
	    if (values.fiducial_marker_size_pixels > 0u) {
	        update_stripe_metadata_field("MAKOCODE_FIDUCIAL_SIZE",
	                                     state.has_fiducial_size,
	                                     state.fiducial_size_value,
	                                     (u64)values.fiducial_marker_size_pixels);
	        // Derive the remaining fiducial grid metadata deterministically from the
	        // page geometry and compiled defaults. This keeps the footer stripe small
	        // (more decodable after scaling) while staying print/scan safe.
	        u32 marker_size = values.fiducial_marker_size_pixels;
	        if (marker_size == 0u) {
	            marker_size = 1u;
	        }
	        u32 spacing = g_fiducial_defaults.spacing_pixels;
	        if (spacing == 0u) {
	            spacing = marker_size;
	        }
	        u32 margin = g_fiducial_defaults.margin_pixels;
	        u32 expected_width = values.page_width_pixels;
	        u32 expected_height = values.page_height_pixels;
	        if (expected_width > 0u && expected_height > 0u) {
	            u32 footer_rows = (values.footer_rows <= 0xFFFFFFFFull) ? (u32)values.footer_rows : 0u;
	            u32 data_height = (expected_height > footer_rows) ? (expected_height - footer_rows) : expected_height;
	            double min_x = (margin < expected_width) ? (double)margin : 0.0;
	            double max_x = (expected_width > margin)
	                               ? (double)(expected_width - 1u - margin)
	                               : (expected_width ? (double)(expected_width - 1u) : 0.0);
	            if (max_x < min_x) max_x = min_x;
	            double min_y = (margin < data_height) ? (double)margin : 0.0;
	            double max_y = (data_height > margin)
	                               ? (double)(data_height - 1u - margin)
	                               : (data_height ? (double)(data_height - 1u) : 0.0);
	            if (max_y < min_y) max_y = min_y;
	            double available_width = (max_x >= min_x) ? (max_x - min_x) : 0.0;
	            double available_height = (max_y >= min_y) ? (max_y - min_y) : 0.0;
	            u32 columns = 1u;
	            if (spacing > 0u && available_width > 0.0) {
	                double span = available_width / (double)spacing;
	                if (span < 0.0) span = 0.0;
	                u64 additional = (u64)span;
	                if (additional > 0xFFFFFFFFull - 1ull) additional = 0xFFFFFFFFull - 1ull;
	                columns = (u32)(additional + 1ull);
	            }
	            if (columns == 0u) columns = 1u;
	            u32 rows = 1u;
	            if (spacing > 0u && available_height > 0.0) {
	                double span = available_height / (double)spacing;
	                if (span < 0.0) span = 0.0;
	                u64 additional = (u64)span;
	                if (additional > 0xFFFFFFFFull - 1ull) additional = 0xFFFFFFFFull - 1ull;
	                rows = (u32)(additional + 1ull);
	            }
	            if (rows == 0u) rows = 1u;
	            if (columns > 1u) {
	                double span = (double)spacing * (double)(columns - 1u);
	                while (columns > 1u && span > available_width + 1e-6) {
	                    --columns;
	                    span = (double)spacing * (double)(columns - 1u);
	                }
	            }
	            if (rows > 1u) {
	                double span = (double)spacing * (double)(rows - 1u);
	                while (rows > 1u && span > available_height + 1e-6) {
	                    --rows;
	                    span = (double)spacing * (double)(rows - 1u);
	                }
	            }
	            update_stripe_metadata_field("MAKOCODE_FIDUCIAL_MARGIN",
	                                         state.has_fiducial_margin,
	                                         state.fiducial_margin_value,
	                                         (u64)margin);
	            update_stripe_metadata_field("MAKOCODE_FIDUCIAL_COLUMNS",
	                                         state.has_fiducial_columns,
	                                         state.fiducial_columns_value,
	                                         (u64)columns);
		            update_stripe_metadata_field("MAKOCODE_FIDUCIAL_ROWS",
		                                         state.has_fiducial_rows,
		                                         state.fiducial_rows_value,
		                                         (u64)rows);

                    // Reconstruct the subgrid offsets deterministically. These were previously
                    // communicated via PPM comment headers, but print/scan will not preserve
                    // them. Without offsets the fiducial subgrid transform assumes control
                    // points span the full image, which can distort pristine images.
                    u32 sub_cols = (columns > 0u) ? (columns - 1u) : 0u;
                    if (sub_cols > 0u && (sub_cols + 1u) <= MAX_FIDUCIAL_SUBGRID_ENTRIES) {
                        double total_phys_width = available_width;
                        if (total_phys_width <= 0.0) {
                            total_phys_width = (double)sub_cols;
                        }
                        double width_scale = (double)expected_width / total_phys_width;
                        double physical_span = (sub_cols > 0u) ? (available_width / (double)sub_cols) : 0.0;
                        if (physical_span <= 0.0) {
                            physical_span = 1.0;
                        }
                        u64 assigned = 0u;
                        state.has_fiducial_col_offsets = true;
                        state.fiducial_col_offset_count = sub_cols + 1u;
                        state.fiducial_col_offsets[0u] = 0u;
                        for (u32 i = 0u; i < sub_cols; ++i) {
                            double scaled = physical_span * width_scale;
                            double accum = (double)assigned + scaled;
                            u64 target = (u64)(accum + 0.5);
                            if (target <= assigned) {
                                target = assigned + 1u;
                            }
                            if ((i + 1u) == sub_cols || target > (u64)expected_width) {
                                target = (u64)expected_width;
                            }
                            state.fiducial_col_offsets[i + 1u] = target;
                            assigned = target;
                        }
                    }

                    u32 sub_rows = (rows > 0u) ? (rows - 1u) : 0u;
                    if (sub_rows > 0u && (sub_rows + 1u) <= MAX_FIDUCIAL_SUBGRID_ENTRIES) {
                        double total_phys_height = available_height;
                        if (total_phys_height <= 0.0) {
                            total_phys_height = (double)sub_rows;
                        }
                        double height_scale = (double)data_height / total_phys_height;
                        double physical_span = (sub_rows > 0u) ? (available_height / (double)sub_rows) : 0.0;
                        if (physical_span <= 0.0) {
                            physical_span = 1.0;
                        }
                        u64 assigned = 0u;
                        state.has_fiducial_row_offsets = true;
                        state.fiducial_row_offset_count = sub_rows + 1u;
                        state.fiducial_row_offsets[0u] = 0u;
                        for (u32 i = 0u; i < sub_rows; ++i) {
                            double scaled = physical_span * height_scale;
                            double accum = (double)assigned + scaled;
                            u64 target = (u64)(accum + 0.5);
                            if (target <= assigned) {
                                target = assigned + 1u;
                            }
                            if ((i + 1u) == sub_rows || target > (u64)data_height) {
                                target = (u64)data_height;
                            }
                            state.fiducial_row_offsets[i + 1u] = target;
                            assigned = target;
                        }
                    }
		        }
		    }
		    update_stripe_metadata_field("MAKOCODE_ECC", state.has_ecc_flag, state.ecc_flag_value, values.ecc_enabled ? 1ull : 0ull);
		    if (values.ecc_enabled) {
	        update_stripe_metadata_field("MAKOCODE_ECC_BLOCK_DATA", state.has_ecc_block_data, state.ecc_block_data_value, (u64)values.ecc_block_data);
	        update_stripe_metadata_field("MAKOCODE_ECC_PARITY", state.has_ecc_parity, state.ecc_parity_value, (u64)values.ecc_parity);
        update_stripe_metadata_field("MAKOCODE_ECC_BLOCK_COUNT", state.has_ecc_block_count, state.ecc_block_count_value, values.ecc_block_count);
        update_stripe_metadata_field("MAKOCODE_ECC_ORIGINAL_BYTES", state.has_ecc_original_bytes, state.ecc_original_bytes_value, values.ecc_original_bytes);
    }
    if (values.has_palette) {
        update_stripe_metadata_field("MAKOCODE_PALETTE_BASE", state.has_palette_base, state.palette_base_value, (u64)values.palette_base);
        usize copy_length = values.palette_length;
        if (copy_length >= MAX_CUSTOM_PALETTE_TEXT) {
            copy_length = MAX_CUSTOM_PALETTE_TEXT - 1u;
        }
        for (usize i = 0u; i < copy_length; ++i) {
            state.palette_text[i] = (char)values.palette_bytes[i];
        }
        state.palette_text[copy_length] = '\0';
        state.palette_text_length = copy_length;
        state.has_palette_text = (copy_length > 0u);
    }
}

static void apply_metadata_tile_metadata(PpmParserState& state,
                                         const MetadataTile::Values& values,
                                         const makocode::ByteBuffer& palette_text) {
    const u64 payload_bits = values.page_bits;
    const u64 frame_bits = payload_bits + 64u;
    update_stripe_metadata_field("MAKOCODE_BITS", state.has_bits, state.bits_value, payload_bits);
    update_stripe_metadata_field("MAKOCODE_PAGE_BITS", state.has_page_bits, state.page_bits_value, frame_bits);
    update_stripe_metadata_field("page_count", state.has_page_count, state.page_count_value, values.page_count);
    update_stripe_metadata_field("page_index", state.has_page_index, state.page_index_value, values.page_index);
    update_stripe_metadata_field("page_width_px", state.has_page_width_pixels, state.page_width_pixels_value, values.page_width_pixels);
    update_stripe_metadata_field("page_height_px", state.has_page_height_pixels, state.page_height_pixels_value, values.page_height_pixels);
    update_stripe_metadata_field("MAKOCODE_FOOTER_ROWS", state.has_footer_rows, state.footer_rows_value, (u64)values.footer_rows);
    update_stripe_metadata_field("MAKOCODE_ECC", state.has_ecc_flag, state.ecc_flag_value, values.ecc_enabled ? 1ull : 0ull);
    if (values.ecc_enabled) {
        update_stripe_metadata_field("MAKOCODE_ECC_BLOCK_DATA",
                                     state.has_ecc_block_data,
                                     state.ecc_block_data_value,
                                     (u64)values.ecc_block_data);
        update_stripe_metadata_field("MAKOCODE_ECC_PARITY",
                                     state.has_ecc_parity,
                                     state.ecc_parity_value,
                                     (u64)values.ecc_parity);
        update_stripe_metadata_field("MAKOCODE_ECC_BLOCK_COUNT",
                                     state.has_ecc_block_count,
                                     state.ecc_block_count_value,
                                     values.ecc_block_count);
        update_stripe_metadata_field("MAKOCODE_ECC_ORIGINAL_BYTES",
                                     state.has_ecc_original_bytes,
                                     state.ecc_original_bytes_value,
                                     values.ecc_original_bytes);
    }

    if (values.fiducial_marker_size_pixels > 0u) {
        update_stripe_metadata_field("MAKOCODE_FIDUCIAL_SIZE",
                                     state.has_fiducial_size,
                                     state.fiducial_size_value,
                                     (u64)values.fiducial_marker_size_pixels);
        // Mirror the footer-stripe behavior: deterministically derive the rest of the fiducial metadata
        // from page geometry + compiled defaults so it survives print/scan (no comment reliance).
        u32 marker_size = values.fiducial_marker_size_pixels;
        if (marker_size == 0u) marker_size = 1u;
        u32 spacing = g_fiducial_defaults.spacing_pixels;
        if (spacing == 0u) spacing = marker_size;
        u32 margin = g_fiducial_defaults.margin_pixels;
        u32 expected_width = values.page_width_pixels;
        u32 expected_height = values.page_height_pixels;
        if (expected_width > 0u && expected_height > 0u) {
            u32 footer_rows = (values.footer_rows < 0xFFFFFFFFu) ? values.footer_rows : 0u;
            u32 data_height = (expected_height > footer_rows) ? (expected_height - footer_rows) : expected_height;
            double min_x = (margin < expected_width) ? (double)margin : 0.0;
            double max_x = (expected_width > margin)
                               ? (double)(expected_width - 1u - margin)
                               : (expected_width ? (double)(expected_width - 1u) : 0.0);
            if (max_x < min_x) max_x = min_x;
            double min_y = (margin < data_height) ? (double)margin : 0.0;
            double max_y = (data_height > margin)
                               ? (double)(data_height - 1u - margin)
                               : (data_height ? (double)(data_height - 1u) : 0.0);
            if (max_y < min_y) max_y = min_y;
            double available_width = (max_x >= min_x) ? (max_x - min_x) : 0.0;
            double available_height = (max_y >= min_y) ? (max_y - min_y) : 0.0;
            u32 columns = 1u;
            if (spacing > 0u && available_width > 0.0) {
                u64 additional = (u64)(available_width / (double)spacing);
                if (additional > 0xFFFFFFFFull - 1ull) additional = 0xFFFFFFFFull - 1ull;
                columns = (u32)(additional + 1ull);
            }
            if (columns == 0u) columns = 1u;
            u32 rows = 1u;
            if (spacing > 0u && available_height > 0.0) {
                u64 additional = (u64)(available_height / (double)spacing);
                if (additional > 0xFFFFFFFFull - 1ull) additional = 0xFFFFFFFFull - 1ull;
                rows = (u32)(additional + 1ull);
            }
            if (rows == 0u) rows = 1u;
            if (columns > 1u) {
                double span = (double)spacing * (double)(columns - 1u);
                while (columns > 1u && span > available_width + 1e-6) {
                    --columns;
                    span = (double)spacing * (double)(columns - 1u);
                }
            }
            if (rows > 1u) {
                double span = (double)spacing * (double)(rows - 1u);
                while (rows > 1u && span > available_height + 1e-6) {
                    --rows;
                    span = (double)spacing * (double)(rows - 1u);
                }
            }
            update_stripe_metadata_field("MAKOCODE_FIDUCIAL_COLUMNS",
                                         state.has_fiducial_columns,
                                         state.fiducial_columns_value,
                                         (u64)columns);
            update_stripe_metadata_field("MAKOCODE_FIDUCIAL_ROWS",
                                         state.has_fiducial_rows,
                                         state.fiducial_rows_value,
                                         (u64)rows);
            update_stripe_metadata_field("MAKOCODE_FIDUCIAL_MARGIN",
                                         state.has_fiducial_margin,
                                         state.fiducial_margin_value,
                                         (u64)margin);
        }
    }

    update_stripe_metadata_field("MAKOCODE_ECC", state.has_ecc_flag, state.ecc_flag_value, values.ecc_enabled ? 1ull : 0ull);
    if (values.ecc_enabled) {
        update_stripe_metadata_field("MAKOCODE_ECC_BLOCK_DATA", state.has_ecc_block_data, state.ecc_block_data_value, (u64)values.ecc_block_data);
        update_stripe_metadata_field("MAKOCODE_ECC_PARITY", state.has_ecc_parity, state.ecc_parity_value, (u64)values.ecc_parity);
        update_stripe_metadata_field("MAKOCODE_ECC_BLOCK_COUNT", state.has_ecc_block_count, state.ecc_block_count_value, values.ecc_block_count);
        update_stripe_metadata_field("MAKOCODE_ECC_ORIGINAL_BYTES", state.has_ecc_original_bytes, state.ecc_original_bytes_value, values.ecc_original_bytes);
    }

    // Provide palette text for existing decode path (hex tokens).
    if (palette_text.data && palette_text.size > 0u) {
        usize copy_length = palette_text.size;
        if (copy_length >= MAX_CUSTOM_PALETTE_TEXT) {
            copy_length = MAX_CUSTOM_PALETTE_TEXT - 1u;
        }
        for (usize i = 0u; i < copy_length; ++i) {
            state.palette_text[i] = (char)palette_text.data[i];
        }
        state.palette_text[copy_length] = '\0';
        state.palette_text_length = copy_length ? (copy_length - 1u) : 0u;
        state.has_palette_text = (state.palette_text_length > 0u);
    }
}

static bool merge_parser_state(PpmParserState& dest, const PpmParserState& src) {
    if (src.has_bytes) {
        if (dest.has_bytes && dest.bytes_value != src.bytes_value) {
            return false;
        }
        dest.has_bytes = true;
        dest.bytes_value = src.bytes_value;
    }
    if (src.has_bits) {
        if (dest.has_bits && dest.bits_value != src.bits_value) {
            return false;
        }
        dest.has_bits = true;
        dest.bits_value = src.bits_value;
    }
    if (src.has_ecc_flag) {
        if (dest.has_ecc_flag && dest.ecc_flag_value != src.ecc_flag_value) {
            return false;
        }
        dest.has_ecc_flag = true;
        dest.ecc_flag_value = src.ecc_flag_value;
    }
    if (src.has_ecc_block_data) {
        if (dest.has_ecc_block_data && dest.ecc_block_data_value != src.ecc_block_data_value) {
            return false;
        }
        dest.has_ecc_block_data = true;
        dest.ecc_block_data_value = src.ecc_block_data_value;
    }
    if (src.has_ecc_parity) {
        if (dest.has_ecc_parity && dest.ecc_parity_value != src.ecc_parity_value) {
            return false;
        }
        dest.has_ecc_parity = true;
        dest.ecc_parity_value = src.ecc_parity_value;
    }
    if (src.has_ecc_block_count) {
        if (dest.has_ecc_block_count && dest.ecc_block_count_value != src.ecc_block_count_value) {
            return false;
        }
        dest.has_ecc_block_count = true;
        dest.ecc_block_count_value = src.ecc_block_count_value;
    }
    if (src.has_ecc_original_bytes) {
        if (dest.has_ecc_original_bytes && dest.ecc_original_bytes_value != src.ecc_original_bytes_value) {
            return false;
        }
        dest.has_ecc_original_bytes = true;
        dest.ecc_original_bytes_value = src.ecc_original_bytes_value;
    }
    if (src.has_palette_text) {
        if (dest.has_palette_text) {
            if (dest.palette_text_length != src.palette_text_length) {
                return false;
            }
            for (usize i = 0u; i < dest.palette_text_length; ++i) {
                if (dest.palette_text[i] != src.palette_text[i]) {
                    return false;
                }
            }
        } else {
            dest.has_palette_text = true;
            usize copy_length = src.palette_text_length;
            if (copy_length >= MAX_CUSTOM_PALETTE_TEXT) {
                copy_length = MAX_CUSTOM_PALETTE_TEXT - 1u;
            }
            for (usize i = 0u; i < copy_length; ++i) {
                dest.palette_text[i] = src.palette_text[i];
            }
            dest.palette_text[copy_length] = '\0';
            dest.palette_text_length = copy_length;
        }
    }
    if (src.has_palette_base) {
        if (dest.has_palette_base && dest.palette_base_value != src.palette_base_value) {
            return false;
        }
        dest.has_palette_base = true;
        dest.palette_base_value = src.palette_base_value;
    }
    if (src.has_page_symbols) {
        if (dest.has_page_symbols && dest.page_symbols_value != src.page_symbols_value) {
            return false;
        }
        dest.has_page_symbols = true;
        dest.page_symbols_value = src.page_symbols_value;
    }
    if (src.has_fiducial_size) {
        if (dest.has_fiducial_size && dest.fiducial_size_value != src.fiducial_size_value) {
            return false;
        }
        dest.has_fiducial_size = true;
        dest.fiducial_size_value = src.fiducial_size_value;
    }
    if (src.has_fiducial_columns) {
        if (dest.has_fiducial_columns && dest.fiducial_columns_value != src.fiducial_columns_value) {
            return false;
        }
        dest.has_fiducial_columns = true;
        dest.fiducial_columns_value = src.fiducial_columns_value;
    }
    if (src.has_fiducial_rows) {
        if (dest.has_fiducial_rows && dest.fiducial_rows_value != src.fiducial_rows_value) {
            return false;
        }
        dest.has_fiducial_rows = true;
        dest.fiducial_rows_value = src.fiducial_rows_value;
    }
    if (src.has_fiducial_margin) {
        if (dest.has_fiducial_margin && dest.fiducial_margin_value != src.fiducial_margin_value) {
            return false;
        }
        dest.has_fiducial_margin = true;
        dest.fiducial_margin_value = src.fiducial_margin_value;
    }
    if (src.has_fiducial_col_offsets) {
        if (src.fiducial_col_offset_count > MAX_FIDUCIAL_SUBGRID_ENTRIES) {
            return false;
        }
        if (dest.has_fiducial_col_offsets) {
            if (dest.fiducial_col_offset_count != src.fiducial_col_offset_count) {
                return false;
            }
            for (u32 i = 0u; i < src.fiducial_col_offset_count; ++i) {
                if (dest.fiducial_col_offsets[i] != src.fiducial_col_offsets[i]) {
                    return false;
                }
            }
        }
        dest.has_fiducial_col_offsets = true;
        dest.fiducial_col_offset_count = src.fiducial_col_offset_count;
        for (u32 i = 0u; i < src.fiducial_col_offset_count; ++i) {
            dest.fiducial_col_offsets[i] = src.fiducial_col_offsets[i];
        }
    }
    if (src.has_fiducial_row_offsets) {
        if (src.fiducial_row_offset_count > MAX_FIDUCIAL_SUBGRID_ENTRIES) {
            return false;
        }
        if (dest.has_fiducial_row_offsets) {
            if (dest.fiducial_row_offset_count != src.fiducial_row_offset_count) {
                return false;
            }
            for (u32 i = 0u; i < src.fiducial_row_offset_count; ++i) {
                if (dest.fiducial_row_offsets[i] != src.fiducial_row_offsets[i]) {
                    return false;
                }
            }
        }
        dest.has_fiducial_row_offsets = true;
        dest.fiducial_row_offset_count = src.fiducial_row_offset_count;
        for (u32 i = 0u; i < src.fiducial_row_offset_count; ++i) {
            dest.fiducial_row_offsets[i] = src.fiducial_row_offsets[i];
        }
    }
    if (src.has_page_width_pixels) {
        if (dest.has_page_width_pixels && dest.page_width_pixels_value != src.page_width_pixels_value) {
            return false;
        }
        dest.has_page_width_pixels = true;
        dest.page_width_pixels_value = src.page_width_pixels_value;
    }
    if (src.has_page_height_pixels) {
        if (dest.has_page_height_pixels && dest.page_height_pixels_value != src.page_height_pixels_value) {
            return false;
        }
        dest.has_page_height_pixels = true;
        dest.page_height_pixels_value = src.page_height_pixels_value;
    }
    if (src.has_page_count) {
        if (dest.has_page_count && dest.page_count_value != src.page_count_value) {
            return false;
        }
        dest.has_page_count = true;
        dest.page_count_value = src.page_count_value;
    }
    if (src.has_page_bits) {
        if (dest.has_page_bits && dest.page_bits_value != src.page_bits_value) {
            return false;
        }
        dest.has_page_bits = true;
        dest.page_bits_value = src.page_bits_value;
    }
    if (src.has_footer_rows) {
        if (dest.has_footer_rows && dest.footer_rows_value != src.footer_rows_value) {
            return false;
        }
        dest.has_footer_rows = true;
        dest.footer_rows_value = src.footer_rows_value;
    }
    if (src.has_footer_stripe) {
        if (dest.has_footer_stripe && !footer_stripe_values_equal(dest.footer_stripe_values, src.footer_stripe_values)) {
            return false;
        }
        dest.has_footer_stripe = true;
        dest.footer_stripe_values = src.footer_stripe_values;
    }
    if (src.has_skew_src_width) {
        if (dest.has_skew_src_width && dest.skew_src_width_value != src.skew_src_width_value) {
            return false;
        }
        dest.has_skew_src_width = true;
        dest.skew_src_width_value = src.skew_src_width_value;
    }
    if (src.has_skew_src_height) {
        if (dest.has_skew_src_height && dest.skew_src_height_value != src.skew_src_height_value) {
            return false;
        }
        dest.has_skew_src_height = true;
        dest.skew_src_height_value = src.skew_src_height_value;
    }
    if (src.has_skew_margin_x) {
        if (dest.has_skew_margin_x && dest.skew_margin_x_value != src.skew_margin_x_value) {
            return false;
        }
        dest.has_skew_margin_x = true;
        dest.skew_margin_x_value = src.skew_margin_x_value;
    }
    if (src.has_skew_x_pixels) {
        if (dest.has_skew_x_pixels && dest.skew_x_pixels_value != src.skew_x_pixels_value) {
            return false;
        }
        dest.has_skew_x_pixels = true;
        dest.skew_x_pixels_value = src.skew_x_pixels_value;
    }
    if (src.has_skew_y_pixels) {
        if (!dest.has_skew_y_pixels) {
            dest.has_skew_y_pixels = true;
            dest.skew_y_pixels_value = src.skew_y_pixels_value;
        }
    }
    if (src.has_skew_bottom_x) {
        if (dest.has_skew_bottom_x && dest.skew_bottom_x_value != src.skew_bottom_x_value) {
            return false;
        }
        dest.has_skew_bottom_x = true;
        dest.skew_bottom_x_value = src.skew_bottom_x_value;
    }
    if (src.has_affine_transform) {
        if (dest.has_affine_transform) {
            bool mismatch = dest.affine_transform.a00 != src.affine_transform.a00 ||
                            dest.affine_transform.a01 != src.affine_transform.a01 ||
                            dest.affine_transform.a10 != src.affine_transform.a10 ||
                            dest.affine_transform.a11 != src.affine_transform.a11 ||
                            dest.affine_transform.tx != src.affine_transform.tx ||
                            dest.affine_transform.ty != src.affine_transform.ty;
            if (mismatch) {
                return false;
            }
        }
        dest.has_affine_transform = true;
        dest.affine_transform = src.affine_transform;
    }
    return true;
}

static bool frame_bits_to_payload(const u8* frame_data,
                                  u64 frame_bit_count,
                                  const PpmParserState& metadata,
                                  makocode::ByteBuffer& output,
                                  u64& out_bit_count) {
    output.release();
    out_bit_count = 0u;
    if (!frame_data || frame_bit_count == 0u) {
        return false;
    }
    makocode::BitReader reader;
    reader.reset(frame_data, frame_bit_count);
    if (frame_bit_count < 64u) {
        return false;
    }
    u64 header_bits = reader.read_bits(64u);
    if (reader.failed) {
        return false;
    }
    u64 available_bits = (frame_bit_count >= 64u) ? (frame_bit_count - 64u) : 0u;
    u64 payload_bits = header_bits;
    if (header_bits == 0u && metadata.has_bits && metadata.bits_value > 0u && metadata.bits_value <= available_bits) {
        payload_bits = metadata.bits_value;
    } else if (header_bits > available_bits && metadata.has_bits && metadata.bits_value > 0u && metadata.bits_value <= available_bits) {
        payload_bits = metadata.bits_value;
    } else if (metadata.has_ecc_original_bytes && (header_bits == 0u || header_bits > available_bits)) {
        u64 expected_bits = metadata.ecc_original_bytes_value * 8ull;
        if (expected_bits <= available_bits) {
            payload_bits = expected_bits;
        }
    }
    if (payload_bits > available_bits) {
        if (debug_logging_enabled()) {
            char header_buf[32];
            char avail_buf[32];
            char payload_buf[32];
            u64_to_ascii(header_bits, header_buf, sizeof(header_buf));
            u64_to_ascii(available_bits, avail_buf, sizeof(avail_buf));
            u64_to_ascii(payload_bits, payload_buf, sizeof(payload_buf));
            console_write(2, "debug payload bits invalid: header_bits=");
            console_write(2, header_buf);
            console_write(2, " payload_bits=");
            console_write(2, payload_buf);
            console_write(2, " available_bits=");
            console_line(2, avail_buf);
        }
        return false;
    }
    if (debug_logging_enabled()) {
        char header_buf[32];
        char payload_buf[32];
        char avail_buf[32];
        u64_to_ascii(header_bits, header_buf, sizeof(header_buf));
        u64_to_ascii(payload_bits, payload_buf, sizeof(payload_buf));
        u64_to_ascii(available_bits, avail_buf, sizeof(avail_buf));
        console_write(2, "debug payload bits header=");
        console_write(2, header_buf);
        console_write(2, " chosen=");
        console_write(2, payload_buf);
        console_write(2, " available=");
        console_line(2, avail_buf);
    }
    makocode::BitWriter payload_writer;
    for (u64 bit_index = 0u; bit_index < payload_bits; ++bit_index) {
        u8 bit = reader.read_bit();
        if (reader.failed) {
            return false;
        }
        if (!payload_writer.write_bit(bit)) {
            return false;
        }
    }
    if (payload_writer.failed) {
        return false;
    }
    usize payload_bytes = payload_writer.byte_size();
    if (payload_bytes && !output.ensure(payload_bytes)) {
        return false;
    }
    const u8* payload_data = payload_writer.data();
    for (usize i = 0u; i < payload_bytes; ++i) {
        output.data[i] = payload_data ? payload_data[i] : 0u;
    }
    output.size = payload_bytes;
    out_bit_count = payload_bits;
    return true;
}

static bool buffer_append_number(makocode::ByteBuffer& buffer, u64 value) {
    char digits[32];
   u64_to_ascii(value, digits, sizeof(digits));
    return buffer.append_ascii(digits);
}

[[maybe_unused]] static bool append_comment_number(makocode::ByteBuffer& buffer,
                                                   const char* tag,
                                                   u64 value) {
    if (!tag) {
        return false;
    }
    if (!buffer.append_char('#')) {
        return false;
    }
    if (!buffer.append_char(' ')) {
        return false;
    }
    if (!buffer.append_ascii(tag)) {
        return false;
    }
    if (!buffer.append_char(' ')) {
        return false;
    }
    if (!buffer_append_number(buffer, value)) {
        return false;
    }
    return buffer.append_char('\n');
}

[[maybe_unused]] static bool append_comment_list(makocode::ByteBuffer& buffer,
                                                 const char* tag,
                                                 const u64* values,
                                                 u32 count) {
    if (!tag || !values || count == 0u) {
        return false;
    }
    if (!buffer.append_char('#') ||
        !buffer.append_char(' ') ||
        !buffer.append_ascii(tag)) {
        return false;
    }
    for (u32 i = 0u; i < count; ++i) {
        if (!buffer.append_char(' ')) {
            return false;
        }
        if (!buffer_append_number(buffer, values[i])) {
            return false;
        }
    }
    return buffer.append_char('\n');
}

static bool buffer_append_zero_padded(makocode::ByteBuffer& buffer,
                                      u64 value,
                                      u32 width) {
    char digits[32];
    u64_to_ascii(value, digits, sizeof(digits));
    usize length = ascii_length(digits);
    if (width > 16u) {
        width = 16u;
    }
    if (width > length) {
        u32 pad = width - (u32)length;
        for (u32 i = 0u; i < pad; ++i) {
            if (!buffer.append_char('0')) {
                return false;
            }
        }
    }
    return buffer.append_ascii(digits);
}

static bool ppm_write_metadata_header(const PpmParserState& state,
                                      makocode::ByteBuffer& output) {
    (void)state;
    if (!output.append_ascii("P3\n")) {
        return false;
    }
    return true;
}

static bool ppm_write_dimensions(u64 width,
                                 u64 height,
                                 makocode::ByteBuffer& output) {
    if (!buffer_append_number(output, width) || !output.append_char(' ')) {
        return false;
    }
    if (!buffer_append_number(output, height) || !output.append_char('\n')) {
        return false;
    }
    if (!output.append_ascii("255\n")) {
        return false;
    }
    return true;
}

static bool ppm_append_extended_metadata(const PpmParserState& state,
                                         makocode::ByteBuffer& output) {
    (void)state;
    (void)output;
    return true;
}

static bool ppm_append_fiducial_metadata(const PpmParserState& state,
                                         makocode::ByteBuffer& output) {
    (void)state;
    (void)output;
    return true;
}

static bool ppm_insert_fiducial_grid(const makocode::ByteBuffer& input,
                                     u32 marker_size,
                                     u32 grid_columns,
                                     u32 grid_rows,
                                     u32 margin_pixels,
                                     u32 grid_height_limit,
                                     makocode::ByteBuffer& output) {
    if (!input.data || input.size == 0u) {
        return false;
    }
    if (marker_size == 0u || grid_columns == 0u || grid_rows == 0u) {
        return false;
    }
    PpmParserState state;
    state.data = input.data;
    state.size = input.size;
    const char* token = 0;
    usize token_length = 0u;
    if (!ppm_next_token(state, &token, &token_length)) {
        return false;
    }
    if (!ascii_equals_token(token, token_length, "P3")) {
        return false;
    }
    if (!ppm_next_token(state, &token, &token_length)) {
        return false;
    }
    u64 width = 0u;
    if (!ascii_to_u64(token, token_length, &width) || width == 0u) {
        return false;
    }
    if (!ppm_next_token(state, &token, &token_length)) {
        return false;
    }
    u64 height = 0u;
    if (!ascii_to_u64(token, token_length, &height) || height == 0u) {
        return false;
    }
    if (!ppm_next_token(state, &token, &token_length)) {
        return false;
    }
    u64 max_value = 0u;
    if (!ascii_to_u64(token, token_length, &max_value) || max_value != 255u) {
        return false;
    }
    u64 pixel_count = width * height;
    if (pixel_count == 0u) {
        return false;
    }
    makocode::ByteBuffer pixels;
    if (!ppm_read_rgb_pixels(state, pixel_count, pixels)) {
        return false;
    }
    u8* pixel_data = pixels.data;
    if (!pixel_data) {
        return false;
    }
    if (width > (u64)0xFFFFFFFFu || height > (u64)0xFFFFFFFFu) {
        return false;
    }
    u32 width_px = (u32)width;
    u32 height_px = (u32)height;
    if (marker_size > width_px || marker_size > height_px) {
        return false;
    }
    u32 draw_height = (grid_height_limit > 0u && grid_height_limit < height_px) ? grid_height_limit : height_px;
    // Footer stripes are disabled; rely on metadata tile or defaults for footer sizing.
    if (kFooterStripeEnabled && !state.has_footer_rows) {
        FooterStripe::Values stripe_values = {};
        bool stripe_ok = FooterStripe::decode_v3(pixel_data, width_px, height_px, stripe_values);
        if (!stripe_ok) {
            stripe_ok = FooterStripe::decode(FooterStripe::SPEC_V2, pixel_data, width_px, height_px, stripe_values);
        }
        if (!stripe_ok) {
            stripe_ok = FooterStripe::decode(FooterStripe::SPEC_V1, pixel_data, width_px, height_px, stripe_values);
        }
        if (stripe_ok && stripe_values.footer_rows > 0u && stripe_values.footer_rows <= (u64)height_px) {
            state.has_footer_rows = true;
            state.footer_rows_value = stripe_values.footer_rows;
        }
    }
    state.has_fiducial_size = true;
    state.fiducial_size_value = marker_size;
    state.has_fiducial_columns = true;
    state.fiducial_columns_value = grid_columns;
    state.has_fiducial_rows = true;
    state.fiducial_rows_value = grid_rows;
    state.has_fiducial_margin = true;
    state.fiducial_margin_value = margin_pixels;

    u64 logical_width = width;
    u64 logical_height = (u64)draw_height;
    // When clipping is requested, treat the clipped height as pure data area (no footer).
    u64 footer_rows_value = 0u;
    if (grid_height_limit == 0u && state.has_footer_rows && state.footer_rows_value <= logical_height) {
        footer_rows_value = state.footer_rows_value;
    }
    u64 data_height = (logical_height >= footer_rows_value) ? (logical_height - footer_rows_value) : logical_height;
    MetadataTile::Placement metadata_tile = MetadataTile::compute_tile_placement(width_px, (u32)data_height);
    auto marker_overlaps_metadata = [&](int x0, int y0, u32 size) -> bool {
        if (!metadata_tile.valid) return false;
        u32 tx0 = metadata_tile.x0;
        u32 ty0 = metadata_tile.y0;
        u32 tx1 = tx0 + MetadataTile::TILE_SIDE;
        u32 ty1 = ty0 + MetadataTile::TILE_SIDE;
        int x1 = x0 + (int)size;
        int y1 = y0 + (int)size;
        return x0 < (int)tx1 && x1 > (int)tx0 && y0 < (int)ty1 && y1 > (int)ty0;
    };

    u32 sub_cols = (grid_columns > 0u) ? (grid_columns - 1u) : 0u;
    u32 sub_rows = (grid_rows > 0u) ? (grid_rows - 1u) : 0u;

    double min_x = (margin_pixels < width_px) ? (double)margin_pixels : 0.0;
    double max_x = (width_px > margin_pixels) ? (double)(width_px - 1u - margin_pixels)
                                              : (width_px ? (double)(width_px - 1u) : 0.0);
    double min_y = (margin_pixels < draw_height) ? (double)margin_pixels : 0.0;
    double max_y = (draw_height > margin_pixels) ? (double)(draw_height - 1u - margin_pixels)
                                                 : (draw_height ? (double)(draw_height - 1u) : 0.0);
    if (max_x < min_x) {
        max_x = min_x;
    }
    if (max_y < min_y) {
        max_y = min_y;
    }
    if (sub_cols > 0u && (sub_cols + 1u) <= MAX_FIDUCIAL_SUBGRID_ENTRIES) {
        double* column_centers = (double*)((grid_columns > 0u) ? malloc((usize)grid_columns * sizeof(double)) : 0);
        double* column_weights = (double*)malloc((usize)sub_cols * sizeof(double));
        if (column_centers && column_weights) {
            for (u32 col_index = 0u; col_index < grid_columns; ++col_index) {
                if (grid_columns == 1u) {
                    column_centers[col_index] = (min_x + max_x) * 0.5;
                } else {
                    double t = (double)col_index / (double)(grid_columns - 1u);
                    column_centers[col_index] = min_x + (max_x - min_x) * t;
                }
            }
            for (u32 i = 0u; i < sub_cols; ++i) {
                double span = column_centers[i + 1u] - column_centers[i];
                if (span <= 0.0) {
                    span = 1.0;
                }
                column_weights[i] = span;
            }
            double total_phys_width = 0.0;
            for (u32 i = 0u; i < sub_cols; ++i) {
                total_phys_width += column_weights[i];
            }
            if (total_phys_width <= 0.0) {
                total_phys_width = (double)sub_cols;
            }
            double width_scale = (double)logical_width / total_phys_width;
            u64 assigned = 0u;
            state.has_fiducial_col_offsets = true;
            state.fiducial_col_offset_count = sub_cols + 1u;
            state.fiducial_col_offsets[0u] = 0u;
            for (u32 i = 0u; i < sub_cols; ++i) {
                double scaled = column_weights[i] * width_scale;
                double accum = (double)assigned + scaled;
                u64 target = (u64)(accum + 0.5);
                if (target <= assigned) {
                    target = assigned + 1u;
                }
                if ((i + 1u) == sub_cols || target > logical_width) {
                    target = logical_width;
                }
                state.fiducial_col_offsets[i + 1u] = target;
                assigned = target;
            }
        } else {
            state.has_fiducial_col_offsets = false;
            state.fiducial_col_offset_count = 0u;
        }
        if (column_centers) {
            free(column_centers);
        }
        if (column_weights) {
            free(column_weights);
        }
    } else {
        state.has_fiducial_col_offsets = false;
        state.fiducial_col_offset_count = 0u;
    }

    if (sub_rows > 0u && (sub_rows + 1u) <= MAX_FIDUCIAL_SUBGRID_ENTRIES) {
        double* row_centers = (double*)((grid_rows > 0u) ? malloc((usize)grid_rows * sizeof(double)) : 0);
        double* row_weights = (double*)malloc((usize)sub_rows * sizeof(double));
        if (row_centers && row_weights) {
            for (u32 row_index = 0u; row_index < grid_rows; ++row_index) {
                if (grid_rows == 1u) {
                    row_centers[row_index] = (min_y + max_y) * 0.5;
                } else {
                    double t = (double)row_index / (double)(grid_rows - 1u);
                    row_centers[row_index] = min_y + (max_y - min_y) * t;
                }
            }
            for (u32 i = 0u; i < sub_rows; ++i) {
                double span = row_centers[i + 1u] - row_centers[i];
                if (span <= 0.0) {
                    span = 1.0;
                }
                row_weights[i] = span;
            }
            double total_phys_height = 0.0;
            for (u32 i = 0u; i < sub_rows; ++i) {
                total_phys_height += row_weights[i];
            }
            if (total_phys_height <= 0.0) {
                total_phys_height = (double)sub_rows;
            }
            double height_scale = (double)data_height / total_phys_height;
            u64 assigned_rows = 0u;
            state.has_fiducial_row_offsets = true;
            state.fiducial_row_offset_count = sub_rows + 1u;
            state.fiducial_row_offsets[0u] = 0u;
            for (u32 i = 0u; i < sub_rows; ++i) {
                double scaled = row_weights[i] * height_scale;
                double accum = (double)assigned_rows + scaled;
                u64 target = (u64)(accum + 0.5);
                if (target <= assigned_rows) {
                    target = assigned_rows + 1u;
                }
                if ((i + 1u) == sub_rows || target > data_height) {
                    target = data_height;
                }
                state.fiducial_row_offsets[i + 1u] = target;
                assigned_rows = target;
            }
        } else {
            state.has_fiducial_row_offsets = false;
            state.fiducial_row_offset_count = 0u;
        }
        if (row_centers) {
            free(row_centers);
        }
        if (row_weights) {
            free(row_weights);
        }
    } else {
        state.has_fiducial_row_offsets = false;
        state.fiducial_row_offset_count = 0u;
    }
    for (u32 grid_row = 0u; grid_row < grid_rows; ++grid_row) {
        double t_y = (grid_rows == 1u) ? 0.5 : ((double)grid_row / (double)(grid_rows - 1u));
        double center_y = min_y + (max_y - min_y) * t_y;
        for (u32 grid_col = 0u; grid_col < grid_columns; ++grid_col) {
            double t_x = (grid_columns == 1u) ? 0.5 : ((double)grid_col / (double)(grid_columns - 1u));
            double center_x = min_x + (max_x - min_x) * t_x;
            int start_x = (int)(center_x - ((double)marker_size - 1.0) * 0.5);
            int start_y = (int)(center_y - ((double)marker_size - 1.0) * 0.5);
            if (marker_overlaps_metadata(start_x, start_y, marker_size)) {
                continue;
            }
            for (u32 dy = 0u; dy < marker_size; ++dy) {
                int pixel_y = start_y + (int)dy;
                if (pixel_y < 0 || pixel_y >= (int)draw_height) {
                    continue;
                }
                for (u32 dx = 0u; dx < marker_size; ++dx) {
                    int pixel_x = start_x + (int)dx;
                    if (pixel_x < 0 || pixel_x >= (int)width_px) {
                        continue;
                    }
                    usize index = ((usize)pixel_y * (usize)width_px + (usize)pixel_x) * 3u;
                    pixel_data[index + 0u] = 255u;
                    pixel_data[index + 1u] = 255u;
                    pixel_data[index + 2u] = 255u;
                }
            }
        }
    }
    output.release();
    if (!ppm_write_metadata_header(state, output)) {
        return false;
    }
    if (!ppm_append_extended_metadata(state, output)) {
        return false;
    }
    if (!ppm_write_dimensions(width, height, output)) {
        return false;
    }
    for (u64 row = 0u; row < height; ++row) {
        for (u64 col = 0u; col < width; ++col) {
            usize pixel_index = ((usize)row * (usize)width + (usize)col) * 3u;
            for (u32 channel = 0u; channel < 3u; ++channel) {
                if (channel) {
                    if (!output.append_char(' ')) {
                        return false;
                    }
                }
                if (!buffer_append_number(output, (u64)pixel_data[pixel_index + channel])) {
                    return false;
                }
            }
            if (!output.append_char('\n')) {
                return false;
            }
        }
    }
    return true;
}

static bool ppm_measure_dimensions(const makocode::ByteBuffer& input,
                                   u32& width_pixels,
                                   u32& height_pixels) {
    width_pixels = 0u;
    height_pixels = 0u;
    if (!input.data || input.size == 0u) {
        return false;
    }
    PpmParserState state;
    state.data = input.data;
    state.size = input.size;
    const char* token = 0;
    usize token_length = 0u;
    if (!ppm_next_token(state, &token, &token_length)) {
        return false;
    }
    if (!ascii_equals_token(token, token_length, "P3")) {
        return false;
    }
    if (!ppm_next_token(state, &token, &token_length)) {
        return false;
    }
    u64 width_value = 0u;
    if (!ascii_to_u64(token, token_length, &width_value) ||
        width_value == 0u ||
        width_value > (u64)0xFFFFFFFFu) {
        return false;
    }
    if (!ppm_next_token(state, &token, &token_length)) {
        return false;
    }
    u64 height_value = 0u;
    if (!ascii_to_u64(token, token_length, &height_value) ||
        height_value == 0u ||
        height_value > (u64)0xFFFFFFFFu) {
        return false;
    }
    width_pixels = (u32)width_value;
    height_pixels = (u32)height_value;
    return true;
}

// Place the default fiducial grid. Optional data_height_pixels clips the grid
// so markers stay above the footer stripe.
static bool apply_default_fiducial_grid(const makocode::ByteBuffer& input,
                                        makocode::ByteBuffer& output,
                                        u32 data_height_pixels = 0u) {
    u32 width_pixels = 0u;
    u32 height_pixels = 0u;
    if (!ppm_measure_dimensions(input, width_pixels, height_pixels)) {
        return false;
    }
    u32 fiducial_marker_size = g_fiducial_defaults.marker_size_pixels;
    if (fiducial_marker_size == 0u) {
        fiducial_marker_size = 1u;
    }
    u32 fiducial_spacing = g_fiducial_defaults.spacing_pixels;
    if (fiducial_spacing == 0u) {
        fiducial_spacing = fiducial_marker_size;
    }
    u32 fiducial_margin = g_fiducial_defaults.margin_pixels;
    double min_x = (fiducial_margin < width_pixels) ? (double)fiducial_margin : 0.0;
    double max_x = (width_pixels > fiducial_margin)
                       ? (double)(width_pixels - 1u - fiducial_margin)
                       : (width_pixels ? (double)(width_pixels - 1u) : 0.0);
    if (max_x < min_x) {
        max_x = min_x;
    }
    u32 grid_height = height_pixels;
    if (data_height_pixels > 0u && data_height_pixels < height_pixels) {
        grid_height = data_height_pixels;
    }
    double min_y = (fiducial_margin < grid_height) ? (double)fiducial_margin : 0.0;
    double max_y = (grid_height > fiducial_margin)
                       ? (double)(grid_height - 1u - fiducial_margin)
                       : (grid_height ? (double)(grid_height - 1u) : 0.0);
    if (max_y < min_y) {
        max_y = min_y;
    }
    double available_width = (max_x >= min_x) ? (max_x - min_x) : 0.0;
    double available_height = (max_y >= min_y) ? (max_y - min_y) : 0.0;
    // Fit the grid into the drawable span so fixtures keep the configured spacing.
    u32 fiducial_columns = 1u;
    if (fiducial_spacing > 0u && available_width > 0.0) {
        double span = available_width / (double)fiducial_spacing;
        if (span < 0.0) {
            span = 0.0;
        }
        u64 additional = (u64)span;
        if (additional > 0xFFFFFFFFull - 1ull) {
            additional = 0xFFFFFFFFull - 1ull;
        }
        fiducial_columns = (u32)(additional + 1ull);
    }
    if (fiducial_columns == 0u) {
        fiducial_columns = 1u;
    }
    u32 fiducial_rows = 1u;
    if (fiducial_spacing > 0u && available_height > 0.0) {
        double span = available_height / (double)fiducial_spacing;
        if (span < 0.0) {
            span = 0.0;
        }
        u64 additional = (u64)span;
        if (additional > 0xFFFFFFFFull - 1ull) {
            additional = 0xFFFFFFFFull - 1ull;
        }
        fiducial_rows = (u32)(additional + 1ull);
    }
    if (fiducial_rows == 0u) {
        fiducial_rows = 1u;
    }
    if (fiducial_columns > 1u) {
        double span = (double)fiducial_spacing * (double)(fiducial_columns - 1u);
        double limit = available_width;
        while (fiducial_columns > 1u && span > limit + 1e-6) {
            --fiducial_columns;
            span = (double)fiducial_spacing * (double)(fiducial_columns - 1u);
        }
    }
    if (fiducial_rows > 1u) {
        double span = (double)fiducial_spacing * (double)(fiducial_rows - 1u);
        double limit = available_height;
        while (fiducial_rows > 1u && span > limit + 1e-6) {
            --fiducial_rows;
            span = (double)fiducial_spacing * (double)(fiducial_rows - 1u);
        }
    }
    return ppm_insert_fiducial_grid(input,
                                    fiducial_marker_size,
                                    fiducial_columns,
                                    fiducial_rows,
                                    fiducial_margin,
                                    grid_height,
                                    output);
}

static bool write_ppm_with_fiducials_to_file(const char* path, const makocode::ByteBuffer& buffer) {
    makocode::ByteBuffer fiducial_buffer;
    u32 width_pixels = 0u;
    u32 height_pixels = 0u;
    if (!ppm_measure_dimensions(buffer, width_pixels, height_pixels)) {
        return false;
    }
    // Footer stripes are disabled; rely on metadata tile or defaults.
    u32 data_height_pixels = 0u;
    if (kFooterStripeEnabled && buffer.data && buffer.size > 0u && width_pixels > 0u && height_pixels > 0u) {
        PpmParserState state;
        state.data = buffer.data;
        state.size = buffer.size;
        const char* token = 0;
        usize token_length = 0u;
        if (ppm_next_token(state, &token, &token_length) &&
            ascii_equals_token(token, token_length, "P3") &&
            ppm_next_token(state, &token, &token_length) &&
            ppm_next_token(state, &token, &token_length) &&
            ppm_next_token(state, &token, &token_length)) {
            // The first three tokens after P3 are width/height/max_value; width/height are already known.
            u64 max_value = 0u;
            if (ascii_to_u64(token, token_length, &max_value) && max_value == 255u) {
                u64 pixel_count = (u64)width_pixels * (u64)height_pixels;
                makocode::ByteBuffer pixels;
                if (ppm_read_rgb_pixels(state, pixel_count, pixels) && pixels.data) {
                    FooterStripe::Values stripe_values = {};
                    bool stripe_ok = FooterStripe::decode_v3(pixels.data, width_pixels, height_pixels, stripe_values);
                    if (!stripe_ok) {
                        stripe_ok = FooterStripe::decode(FooterStripe::SPEC_V2, pixels.data, width_pixels, height_pixels, stripe_values);
                    }
                    if (!stripe_ok) {
                        stripe_ok = FooterStripe::decode(FooterStripe::SPEC_V1, pixels.data, width_pixels, height_pixels, stripe_values);
                    }
                    if (stripe_ok && stripe_values.footer_rows > 0u && stripe_values.footer_rows < (u64)height_pixels) {
                        data_height_pixels = height_pixels - (u32)stripe_values.footer_rows;
                        if (debug_logging_enabled()) {
                            char footer_buf[32];
                            char data_buf[32];
                            u64_to_ascii(stripe_values.footer_rows, footer_buf, sizeof(footer_buf));
                            u64_to_ascii((u64)data_height_pixels, data_buf, sizeof(data_buf));
                            console_write(2, "debug fiducial embed: footer_rows=");
                            console_write(2, footer_buf);
                            console_write(2, " data_height=");
                            console_line(2, data_buf);
                        }
                    } else if (debug_logging_enabled()) {
                        console_line(2, "debug fiducial embed: footer stripe not available");
                    }
                }
            }
        }
    }
    if (!apply_default_fiducial_grid(buffer, fiducial_buffer, data_height_pixels)) {
        return false;
    }
    return write_bytes_to_file(path, fiducial_buffer.data, fiducial_buffer.size);
}

// Build a mask that reserves only the fiducial marker pixels (no metadata tile).
// The mask is sized to the full page (width_pixels * height_pixels), and markers
// are clipped to the data region (data_height_pixels) when counting reserved
// data pixels.
static bool compute_fiducial_marker_mask(u32 width_pixels,
                                        u32 height_pixels,
                                        u32 data_height_pixels,
                                        u64& reserved_data_pixels,
                                        makocode::ByteBuffer* mask_out) {
    reserved_data_pixels = 0u;
    if (width_pixels == 0u || height_pixels == 0u) {
        if (mask_out) {
            mask_out->release();
        }
        return true;
    }
    if (data_height_pixels > height_pixels) {
        data_height_pixels = height_pixels;
    }
    u64 total_pixels = (u64)width_pixels * (u64)height_pixels;
    if (mask_out) {
        mask_out->release();
        if (total_pixels) {
            if (!mask_out->ensure((usize)total_pixels)) {
                return false;
            }
            mask_out->size = (usize)total_pixels;
            for (u64 i = 0u; i < total_pixels; ++i) {
                mask_out->data[i] = 0u;
            }
        } else {
            mask_out->size = 0u;
        }
    }
    u32 marker_size = g_fiducial_defaults.marker_size_pixels;
    if (marker_size == 0u) {
        return true;
    }
    u32 draw_height = height_pixels;
    if (data_height_pixels > 0u && data_height_pixels < height_pixels) {
        draw_height = data_height_pixels;
    }
    u32 spacing = g_fiducial_defaults.spacing_pixels;
    if (spacing == 0u) {
        spacing = marker_size;
    }
    u32 margin = g_fiducial_defaults.margin_pixels;
    double min_x = (margin < width_pixels) ? (double)margin : 0.0;
    double max_x = (width_pixels > margin)
                       ? (double)(width_pixels - 1u - margin)
                       : (width_pixels ? (double)(width_pixels - 1u) : 0.0);
    if (max_x < min_x) {
        max_x = min_x;
    }
    double min_y = (margin < draw_height) ? (double)margin : 0.0;
    double max_y = (draw_height > margin)
                       ? (double)(draw_height - 1u - margin)
                       : (draw_height ? (double)(draw_height - 1u) : 0.0);
    if (max_y < min_y) {
        max_y = min_y;
    }
    double available_width = (max_x >= min_x) ? (max_x - min_x) : 0.0;
    double available_height = (max_y >= min_y) ? (max_y - min_y) : 0.0;
    u32 fiducial_columns = 1u;
    if (spacing > 0u && available_width > 0.0) {
        double span = available_width / (double)spacing;
        if (span < 0.0) {
            span = 0.0;
        }
        u64 additional = (u64)span;
        if (additional > 0xFFFFFFFFull - 1ull) {
            additional = 0xFFFFFFFFull - 1ull;
        }
        fiducial_columns = (u32)(additional + 1ull);
    }
    if (fiducial_columns == 0u) {
        fiducial_columns = 1u;
    }
    u32 fiducial_rows = 1u;
    if (spacing > 0u && available_height > 0.0) {
        double span = available_height / (double)spacing;
        if (span < 0.0) {
            span = 0.0;
        }
        u64 additional = (u64)span;
        if (additional > 0xFFFFFFFFull - 1ull) {
            additional = 0xFFFFFFFFull - 1ull;
        }
        fiducial_rows = (u32)(additional + 1ull);
    }
    if (fiducial_rows == 0u) {
        fiducial_rows = 1u;
    }
    if (fiducial_columns > 1u) {
        double span = (double)spacing * (double)(fiducial_columns - 1u);
        double limit = available_width;
        while (fiducial_columns > 1u && span > limit + 1e-6) {
            --fiducial_columns;
            span = (double)spacing * (double)(fiducial_columns - 1u);
        }
    }
    if (fiducial_rows > 1u) {
        double span = (double)spacing * (double)(fiducial_rows - 1u);
        double limit = available_height;
        while (fiducial_rows > 1u && span > limit + 1e-6) {
            --fiducial_rows;
            span = (double)spacing * (double)(fiducial_rows - 1u);
        }
    }
    if (fiducial_columns == 0u || fiducial_rows == 0u || marker_size == 0u) {
        return true;
    }
    for (u32 grid_row = 0u; grid_row < fiducial_rows; ++grid_row) {
        double t_y = (fiducial_rows == 1u) ? 0.5 : ((double)grid_row / (double)(fiducial_rows - 1u));
        double center_y = min_y + (max_y - min_y) * t_y;
        int start_y = (int)(center_y - ((double)marker_size - 1.0) * 0.5);
        for (u32 grid_col = 0u; grid_col < fiducial_columns; ++grid_col) {
            double t_x = (fiducial_columns == 1u) ? 0.5 : ((double)grid_col / (double)(fiducial_columns - 1u));
            double center_x = min_x + (max_x - min_x) * t_x;
            int start_x = (int)(center_x - ((double)marker_size - 1.0) * 0.5);
            for (u32 dy = 0u; dy < marker_size; ++dy) {
                int pixel_y = start_y + (int)dy;
                if (pixel_y < 0 || pixel_y >= (int)draw_height) {
                    continue;
                }
                bool within_data = ((u32)pixel_y < data_height_pixels);
                for (u32 dx = 0u; dx < marker_size; ++dx) {
                    int pixel_x = start_x + (int)dx;
                    if (pixel_x < 0 || pixel_x >= (int)width_pixels) {
                        continue;
                    }
                    bool counted = true;
                    usize mask_index = ((usize)pixel_y * (usize)width_pixels) + (usize)pixel_x;
                    if (mask_out && mask_out->size) {
                        if (mask_out->data[mask_index]) {
                            counted = false;
                        } else {
                            mask_out->data[mask_index] = 1u;
                        }
                    }
                    if (counted && within_data) {
                        ++reserved_data_pixels;
                    }
                }
            }
        }
    }
    return true;
}

static bool compute_fiducial_reservation(u32 width_pixels,
                                         u32 height_pixels,
                                         u32 data_height_pixels,
                                         u64& reserved_data_pixels,
                                         makocode::ByteBuffer* mask_out,
                                         bool reserve_metadata_tile) {
    if (!compute_fiducial_marker_mask(width_pixels,
                                      height_pixels,
                                      data_height_pixels,
                                      reserved_data_pixels,
                                      mask_out)) {
        return false;
    }

    // Reserve the per-page metadata tile (48x48) in the data region so payload bits never land there.
    const char* disable_tile_env = getenv("MAKO_DISABLE_METADATA_TILE");
    if (reserve_metadata_tile &&
        !(disable_tile_env && disable_tile_env[0]) &&
        data_height_pixels >= MetadataTile::TILE_SIDE && width_pixels >= MetadataTile::TILE_SIDE) {
        MetadataTile::Placement placement = MetadataTile::compute_tile_placement(width_pixels, data_height_pixels);
        if (placement.valid) {
            for (u32 dy = 0u; dy < MetadataTile::TILE_SIDE; ++dy) {
                u32 y = placement.y0 + dy;
                if (y >= data_height_pixels) {
                    continue;
                }
                for (u32 dx = 0u; dx < MetadataTile::TILE_SIDE; ++dx) {
                    u32 x = placement.x0 + dx;
                    if (x >= width_pixels) {
                        continue;
                    }
                    usize mask_index = (usize)y * (usize)width_pixels + (usize)x;
                    bool counted = true;
                    if (mask_out && mask_out->size) {
                        if (mask_out->data[mask_index]) {
                            counted = false;
                        } else {
                            mask_out->data[mask_index] = 1u;
                        }
                    }
                    if (counted) {
                        ++reserved_data_pixels;
                    }
                }
            }
        }
    }
    return true;
}

static bool compute_bits_per_page(u32 width_pixels,
                                  u32 height_pixels,
                                  u32 data_height_pixels,
                                  double bits_per_pixel,
                                  u64& bits_per_page,
                                  u64* reserved_pixels_out) {
    if (bits_per_pixel <= 0.0) {
        return false;
    }
    if (data_height_pixels == 0u || data_height_pixels > height_pixels) {
        return false;
    }
    u64 total_pixels = (u64)width_pixels * (u64)data_height_pixels;
    u64 reserved_pixels = 0u;
    makocode::ByteBuffer temp_mask;
    if (!compute_fiducial_reservation(width_pixels,
                                      height_pixels,
                                      data_height_pixels,
                                      reserved_pixels,
                                      &temp_mask)) {
        return false;
    }
    if (reserved_pixels >= total_pixels) {
        bits_per_page = 0u;
        return false;
    }
    u64 usable_pixels = total_pixels - reserved_pixels;
    double capacity_bits = (double)usable_pixels * bits_per_pixel;
    if (capacity_bits <= 0.0) {
        bits_per_page = 0u;
        return false;
    }
    if (capacity_bits > (double)U64_MAX_VALUE) {
        return false;
    }
    u64 computed_bits = (u64)capacity_bits;
    if (computed_bits == 0u) {
        bits_per_page = 0u;
        return false;
    }
    bits_per_page = computed_bits;
    if (reserved_pixels_out) {
        *reserved_pixels_out = reserved_pixels;
    }
    return true;
}

struct PageCapacityResult {
    u32 width_pixels;
    u32 height_pixels;
    u32 data_height_pixels;
    u64 bits_per_page;
    u64 usable_data_pixels;
    FooterLayout footer_layout;

    PageCapacityResult()
        : width_pixels(0u),
          height_pixels(0u),
          data_height_pixels(0u),
          bits_per_page(0u),
          usable_data_pixels(0u),
          footer_layout() {}
};

static bool build_page_filename(makocode::ByteBuffer& buffer,
                                const char* timestamp,
                                u64 page_index,
                                u64 page_count) {
    if (!timestamp || page_index == 0u) {
        return false;
    }
    buffer.release();
    if (!buffer.append_ascii(timestamp)) {
        return false;
    }
    if (page_count > 1u) {
        if (!buffer.append_ascii("_page_")) {
            return false;
        }
        u32 width = 4u;
        u64 count = page_count;
        u32 digits = 1u;
        while (count >= 10u) {
            count /= 10u;
            ++digits;
        }
        if (digits > width) {
            width = digits;
        }
        if (!buffer_append_zero_padded(buffer, page_index, width)) {
            return false;
        }
    }
    if (!buffer.append_ascii(".ppm") || !buffer.append_char('\0')) {
        return false;
    }
    return true;
}

static bool build_frame_bits(const makocode::EncoderContext& encoder,
                             const ImageMappingConfig& mapping,
                             makocode::ByteBuffer& frame_bits,
                             u64& frame_bit_count,
                             u64& payload_bit_count) {
    if (mapping.color_channels == 0u || mapping.color_channels > 3u) {
        return false;
    }
    const u8 sample_bits = bits_per_sample(mapping.color_channels);
    if (sample_bits == 0u) {
        return false;
    }
    const PaletteColor* palette = 0;
    u32 palette_size = 0u;
    if (!palette_for_mode(mapping.color_channels, palette, palette_size)) {
        return false;
    }
    if (palette_size != (1u << sample_bits)) {
        return false;
    }
    (void)palette;
    payload_bit_count = encoder.bit_writer.bit_size();
    usize payload_byte_count = encoder.bit_writer.byte_size();
    makocode::BitWriter frame_writer;
    if (!frame_writer.write_bits(payload_bit_count, 64u)) {
        return false;
    }
    const u8* payload_raw = encoder.bit_writer.data();
    for (usize byte_index = 0u; byte_index < payload_byte_count; ++byte_index) {
        u8 byte = payload_raw ? payload_raw[byte_index] : 0u;
        u64 bits_written = (u64)byte_index * 8u;
        u64 bits_remaining = (payload_bit_count > bits_written) ? (payload_bit_count - bits_written) : 0u;
        if (!bits_remaining) {
            break;
        }
        usize chunk = (bits_remaining >= 8u) ? 8u : (usize)bits_remaining;
        if (!frame_writer.write_bits((u64)byte, chunk)) {
            return false;
        }
    }
    frame_bit_count = frame_writer.bit_size();
    usize frame_bytes = frame_writer.byte_size();
    frame_bits.release();
    if (frame_bytes && !frame_bits.ensure(frame_bytes)) {
        return false;
    }
    const u8* raw = frame_writer.data();
    for (usize i = 0u; i < frame_bytes; ++i) {
        frame_bits.data[i] = raw ? raw[i] : 0u;
    }
    frame_bits.size = frame_bytes;
    if (mapping.color_channels == 3u && frame_bytes) {
        for (usize i = 0u; i < frame_bytes; ++i) {
            u8 rotate = (u8)((i % 3u) + 1u);
            frame_bits.data[i] = rotate_left_u8(frame_bits.data[i], rotate);
        }
    }
    return true;
}


static bool encode_page_to_ppm(const ImageMappingConfig& mapping,
                               const makocode::ByteBuffer& frame_bits,
                               u64 frame_bit_count,
                               u64 bit_offset,
                               u32 width_pixels,
                               u32 height_pixels,
                               u64 page_index,
                               u64 page_count,
                               u64 bits_per_page,
                               u64 payload_bit_count,
                               const makocode::EccSummary* ecc_summary,
                               const char* footer_text,
                               usize footer_length,
                               const FooterLayout& footer_layout,
                               makocode::ByteBuffer& output) {
    if (mapping.color_channels == 0u || mapping.color_channels > 3u) {
        return false;
    }
    const u8 sample_bits = bits_per_sample(mapping.color_channels);
    if (sample_bits == 0u) {
        return false;
    }
    u8 samples_per_pixel = color_mode_samples_per_pixel(mapping.color_channels);
    if (samples_per_pixel == 0u) {
        return false;
    }
    u64 total_pixels = (u64)width_pixels * (u64)height_pixels;
    if (total_pixels == 0u) {
        return false;
    }
    bool has_footer_text = (footer_text && footer_length > 0u);
    if (has_footer_text && !footer_layout.has_text) {
        return false;
    }
    u32 data_height_pixels = height_pixels;
    if (footer_layout.data_height_pixels == 0u || footer_layout.data_height_pixels > height_pixels) {
        return false;
    }
    data_height_pixels = footer_layout.data_height_pixels;
    makocode::ByteBuffer fiducial_mask;
    makocode::ByteBuffer fiducial_marker_mask;
    u64 reserved_data_pixels = 0u;
    if (!compute_fiducial_reservation(width_pixels,
                                      height_pixels,
                                      data_height_pixels,
                                      reserved_data_pixels,
                                      &fiducial_mask)) {
        return false;
    }
    // Keep a fiducial-only mask so metadata tile rendering never overwrites the
    // white fiducial markers (the combined reservation mask also marks the tile).
    u64 fiducial_only_reserved = 0u;
    if (!compute_fiducial_marker_mask(width_pixels,
                                      height_pixels,
                                      data_height_pixels,
                                      fiducial_only_reserved,
                                      &fiducial_marker_mask)) {
        return false;
    }
    u64 total_data_pixels = (u64)width_pixels * (u64)data_height_pixels;
    if (reserved_data_pixels > total_data_pixels) {
        return false;
    }
    u64 usable_data_pixels = total_data_pixels - reserved_data_pixels;
    bool use_custom_palette = mapping_has_custom_palette(mapping);
    u32 custom_base = use_custom_palette ? mapping_custom_palette_base(mapping) : 0u;
    if (!use_custom_palette) {
        u64 expected_bits_per_page = usable_data_pixels *
                                     (u64)sample_bits *
                                     (u64)samples_per_pixel;
        if (expected_bits_per_page != bits_per_page) {
            char exp_digits[32];
            char bits_digits[32];
            u64_to_ascii(expected_bits_per_page, exp_digits, sizeof(exp_digits));
            u64_to_ascii(bits_per_page, bits_digits, sizeof(bits_digits));
            console_write(2, "encode_page_to_ppm: expected bits=");
            console_write(2, exp_digits);
            console_write(2, " provided bits=");
            console_line(2, bits_digits);
            return false;
        }
    }
    makocode::ByteBuffer page_bits_chunk;
    makocode::ByteBuffer base_digits;
    u64 digits_used = 0u;
    u64 digit_span = 0u;
    if (use_custom_palette) {
        if (custom_base < 2u) {
            return false;
        }
        if (!copy_bits_segment(frame_bits.data,
                               frame_bit_count,
                               bit_offset,
                               bits_per_page,
                               page_bits_chunk)) {
            return false;
        }
        if (!bits_to_base_digits(page_bits_chunk,
                                 bits_per_page,
                                 custom_base,
                                 base_digits,
                                 digits_used)) {
            return false;
        }
        if (debug_logging_enabled()) {
            char palette_buf[32];
            char base_buf[32];
            char digits_buf[32];
            char capacity_buf[32];
            char bits_buf[64];
            u64_to_ascii((u64)mapping.custom_palette_count, palette_buf, sizeof(palette_buf));
            u64_to_ascii((u64)custom_base, base_buf, sizeof(base_buf));
            u64_to_ascii(digits_used, digits_buf, sizeof(digits_buf));
            u64_to_ascii(usable_data_pixels, capacity_buf, sizeof(capacity_buf));
            u64_to_ascii(bits_per_page, bits_buf, sizeof(bits_buf));
            console_write(2, "debug palette: size=");
            console_write(2, palette_buf);
            console_write(2, " base=");
            console_write(2, base_buf);
            console_write(2, " digits_from_bits=");
            console_write(2, digits_buf);
            console_write(2, " digits_per_page=");
            console_write(2, capacity_buf);
            console_write(2, " bits_per_page=");
            console_line(2, bits_buf);
        }
        if (digits_used > usable_data_pixels) {
            console_line(2, "encode_page_to_ppm: insufficient data pixels for palette digits");
            return false;
        }
        if (usable_data_pixels == 0u || usable_data_pixels > (u64)USIZE_MAX_VALUE) {
            console_line(2, "encode_page_to_ppm: unusable palette pixel capacity");
            return false;
        }
        usize target_digits = (usize)usable_data_pixels;
        if (!base_digits.ensure(target_digits)) {
            return false;
        }
        if (base_digits.size < target_digits) {
            for (usize pad = base_digits.size; pad < target_digits; ++pad) {
                base_digits.data[pad] = 0u;
            }
        }
        base_digits.size = target_digits;
        digit_span = (u64)base_digits.size;
    }
    if (debug_logging_enabled()) {
        char frame_buf[32];
        char payload_buf[32];
        char capacity_buf[32];
        u64_to_ascii(frame_bit_count, frame_buf, sizeof(frame_buf));
        u64_to_ascii(payload_bit_count, payload_buf, sizeof(payload_buf));
        u64_to_ascii(usable_data_pixels, capacity_buf, sizeof(capacity_buf));
        console_write(2, "debug encode frame_bits=");
        console_write(2, frame_buf);
        console_write(2, " payload_bits=");
        console_write(2, payload_buf);
        console_write(2, " usable_pixels=");
        console_line(2, capacity_buf);
    }
    // Footer barcode removed; keep layout variables zeroed.
    u8 footer_text_rgb[3] = {0u, 0u, 0u};
    u8 footer_background_rgb[3] = {255u, 255u, 255u};
    footer_select_colors(mapping, footer_text_rgb, footer_background_rgb);
    output.release();
    if (!output.append_ascii("P3\n")) {
        return false;
    }
    if (!buffer_append_number(output, (u64)width_pixels) || !output.append_char(' ')) {
        return false;
    }
    if (!buffer_append_number(output, (u64)height_pixels) || !output.append_char('\n')) {
        return false;
    }
    if (!output.append_ascii("255\n")) {
        return false;
    }
    const u8* frame_data = frame_bits.data;
    const u8* mask_data = fiducial_mask.data;
    usize mask_size = fiducial_mask.size;
    u64 bit_cursor = bit_offset;
    u64 digit_index = 0u;

    // Build metadata tile bits (2-color endpoints) so reserved pixels in the tile
    // region render as metadata rather than blank white.
    MetadataTile::Placement tile_placement = MetadataTile::compute_tile_placement(width_pixels, data_height_pixels);
    const char* disable_tile_env = getenv("MAKO_DISABLE_METADATA_TILE");
    bool have_metadata_tile = tile_placement.valid && !(disable_tile_env && disable_tile_env[0]);
    PaletteColor tile_light = {255u, 255u, 255u};
    PaletteColor tile_dark = {0u, 0u, 0u};
    MetadataTile::Values tile_values;
    makocode::ByteBuffer tile_bitfield;
    if (have_metadata_tile) {
        const PaletteColor* palette = 0;
        u32 palette_size = 0u;
        if (use_custom_palette) {
            if (mapping.custom_palette_count < 2u) {
                return false;
            }
            tile_values.palette_count = mapping.custom_palette_count;
            for (u32 i = 0u; i < mapping.custom_palette_count; ++i) {
                tile_values.palette[i] = mapping.custom_palette[i];
            }
            tile_light = mapping.custom_palette[0u];
            // Pick the darkest palette entry for the 2-color bootstrap (some palettes
            // are not ordered light->dark, e.g. CMYK ends with Yellow).
            u32 darkest_index = 0u;
            double darkest_l = MetadataTile::rgb_luminance_u8(mapping.custom_palette[0u].r,
                                                              mapping.custom_palette[0u].g,
                                                              mapping.custom_palette[0u].b);
            for (u32 i = 1u; i < mapping.custom_palette_count; ++i) {
                double l = MetadataTile::rgb_luminance_u8(mapping.custom_palette[i].r,
                                                          mapping.custom_palette[i].g,
                                                          mapping.custom_palette[i].b);
                if (l < darkest_l) {
                    darkest_l = l;
                    darkest_index = i;
                }
            }
            tile_dark = mapping.custom_palette[darkest_index];
        } else {
            if (!palette_for_mode(mapping.color_channels, palette, palette_size) || palette_size < 2u) {
                return false;
            }
            tile_values.palette_count = palette_size;
            for (u32 i = 0u; i < palette_size && i < MAX_CUSTOM_PALETTE_COLORS; ++i) {
                tile_values.palette[i] = palette[i];
            }
            // Built-in palettes don't have a "first is light" convention; pick
            // the lightest/darkest endpoints by luminance.
            u32 lightest_index = 0u;
            u32 darkest_index = 0u;
            double lightest_l = MetadataTile::rgb_luminance_u8(palette[0u].r,
                                                               palette[0u].g,
                                                               palette[0u].b);
            double darkest_l = lightest_l;
            for (u32 i = 1u; i < palette_size; ++i) {
                double l = MetadataTile::rgb_luminance_u8(palette[i].r,
                                                          palette[i].g,
                                                          palette[i].b);
                if (l > lightest_l) {
                    lightest_l = l;
                    lightest_index = i;
                }
                if (l < darkest_l) {
                    darkest_l = l;
                    darkest_index = i;
                }
            }
            if (lightest_index == darkest_index) {
                darkest_index = (palette_size > 1u) ? 1u : 0u;
            }
            tile_light = palette[lightest_index];
            tile_dark = palette[darkest_index];
        }

        // Enforce a minimum luminance gap for reliable 2-color bootstrap.
        if (!MetadataTile::palette_endpoints_have_contrast(tile_light, tile_dark, 40.0)) {
            console_line(2, "encode: palette endpoints have insufficient contrast for metadata (first/last)");
            return false;
        }

        tile_values.page_bits = bits_per_page;
        tile_values.page_count = page_count;
        tile_values.page_index = page_index;
        tile_values.page_width_pixels = width_pixels;
        tile_values.page_height_pixels = height_pixels;
        tile_values.footer_rows = height_pixels - data_height_pixels;
        tile_values.fiducial_marker_size_pixels = g_fiducial_defaults.marker_size_pixels ? g_fiducial_defaults.marker_size_pixels : 1u;
        tile_values.ecc_enabled = (ecc_summary && ecc_summary->enabled);
        if (tile_values.ecc_enabled && ecc_summary) {
            tile_values.ecc_block_data = ecc_summary->block_data_symbols;
            tile_values.ecc_parity = ecc_summary->parity_symbols;
            tile_values.ecc_block_count = ecc_summary->block_count;
            tile_values.ecc_original_bytes = ecc_summary->original_bytes;
        }

        if (!MetadataTile::build_tile_bits(tile_values, tile_bitfield)) {
            console_line(2, "encode_page_to_ppm: failed to build metadata tile");
            return false;
        }
        if (tile_bitfield.size != (usize)MetadataTile::TILE_SIDE * (usize)MetadataTile::TILE_SIDE) {
            return false;
        }
    }

    for (u32 row = 0u; row < height_pixels; ++row) {
        bool is_footer_row = (row >= data_height_pixels);
        for (u32 column = 0u; column < width_pixels; ++column) {
            u8 rgb[3] = {0u, 0u, 0u};
            usize mask_index = ((usize)row * (usize)width_pixels) + (usize)column;
            bool reserved_pixel = (!is_footer_row &&
                                   mask_data &&
                                   mask_index < mask_size &&
                                   mask_data[mask_index] != 0u);
            bool inside_tile = false;
            if (!is_footer_row && have_metadata_tile) {
                if (column >= tile_placement.x0 &&
                    column < tile_placement.x0 + MetadataTile::TILE_SIDE &&
                    row >= tile_placement.y0 &&
                    row < tile_placement.y0 + MetadataTile::TILE_SIDE) {
                    inside_tile = true;
                }
            }
            if (!is_footer_row && inside_tile) {
                bool is_fiducial_marker_pixel = false;
                if (fiducial_marker_mask.data && fiducial_marker_mask.size) {
                    if (mask_index < fiducial_marker_mask.size) {
                        is_fiducial_marker_pixel = (fiducial_marker_mask.data[mask_index] != 0u);
                    }
                }
                if (is_fiducial_marker_pixel) {
                    // Preserve fiducial markers as pure white (255,255,255).
                    rgb[0] = 255u;
                    rgb[1] = 255u;
                    rgb[2] = 255u;
                } else {
                    u32 local_x = column - tile_placement.x0;
                    u32 local_y = row - tile_placement.y0;
                    u8 bit = tile_bitfield.data[(usize)local_y * (usize)MetadataTile::TILE_SIDE + (usize)local_x];
                    const PaletteColor& c = bit ? tile_dark : tile_light;
                    rgb[0] = c.r;
                    rgb[1] = c.g;
                    rgb[2] = c.b;
                }
            } else if (!is_footer_row && !reserved_pixel) {
                if (use_custom_palette) {
                    u8 symbol = 0u;
                    if (digit_index < (u64)base_digits.size) {
                        symbol = base_digits.data[digit_index];
                    }
                    ++digit_index;
                    if (symbol >= mapping.custom_palette_count) {
                        return false;
                    }
                    const PaletteColor& color = mapping.custom_palette[symbol];
                    rgb[0] = color.r;
                    rgb[1] = color.g;
                    rgb[2] = color.b;
                } else {
                    u32 samples_raw[3] = {0u, 0u, 0u};
                    for (u8 sample_index = 0u; sample_index < samples_per_pixel; ++sample_index) {
                        u32 sample = 0u;
                        for (u8 bit = 0u; bit < sample_bits; ++bit) {
                            u8 bit_value = 0u;
                            if (bit_cursor < frame_bit_count && frame_data) {
                                usize byte_index = (usize)(bit_cursor >> 3u);
                                u8 mask = (u8)(1u << (bit_cursor & 7u));
                                bit_value = (frame_data[byte_index] & mask) ? 1u : 0u;
                            }
                            sample |= ((u32)bit_value) << bit;
                            ++bit_cursor;
                        }
                        samples_raw[sample_index] = sample;
                    }
                    if (!map_samples_to_rgb(mapping.color_channels, samples_raw, rgb)) {
                        return false;
                    }
                }
            } else if (!is_footer_row) {
                rgb[0] = 255u;
                rgb[1] = 255u;
                rgb[2] = 255u;
            } else {
                rgb[0] = footer_background_rgb[0];
                rgb[1] = footer_background_rgb[1];
                rgb[2] = footer_background_rgb[2];
                bool text_pixel = (has_footer_text &&
                                   footer_is_text_pixel(footer_text, footer_length, footer_layout, column, row));
                if (text_pixel) {
                    rgb[0] = footer_text_rgb[0];
                    rgb[1] = footer_text_rgb[1];
                    rgb[2] = footer_text_rgb[2];
                }
            }
            for (u8 channel = 0u; channel < 3u; ++channel) {
                if (channel) {
                    if (!output.append_char(' ')) {
                        return false;
                    }
                }
                if (!buffer_append_number(output, (u64)rgb[channel])) {
                    return false;
                }
            }
            if (!output.append_char('\n')) {
                return false;
            }
        }
    }
    if (use_custom_palette && digit_index != digit_span) {
        console_line(2, "encode_page_to_ppm: palette digit span mismatch");
        return false;
    }
    return true;
}
static bool process_fiducial_option(int arg_count,
                                    char** args,
                                    int* arg_index,
                                    FiducialGridDefaults& defaults,
                                    const char* command_name,
                                    bool* handled) {
    if (!handled || !arg_index || !args) {
        return false;
    }
    *handled = false;
    int index = *arg_index;
    if (index < 0 || index >= arg_count) {
        return false;
    }
    const char* arg = args[index];
    if (!arg) {
        return true;
    }
    const char fiducial_prefix[] = "--fiducials=";
    const char* value_text = 0;
    if (ascii_equals_token(arg, ascii_length(arg), "--fiducials")) {
        if ((index + 1) >= arg_count) {
            console_write(2, command_name);
            console_line(2, ": --fiducials requires size,spacing[,margin]");
            return false;
        }
        value_text = args[index + 1];
        if (!value_text) {
            console_write(2, command_name);
            console_line(2, ": --fiducials requires size,spacing[,margin]");
            return false;
        }
        *arg_index = index + 1;
    } else if (ascii_starts_with(arg, fiducial_prefix)) {
        value_text = arg + (sizeof(fiducial_prefix) - 1u);
    } else {
        return true;
    }
    usize total_length = ascii_length(value_text);
    if (total_length == 0u) {
        console_write(2, command_name);
        console_line(2, ": --fiducials requires size,spacing[,margin]");
        return false;
    }
    u64 parsed_values[3];
    usize parsed_count = 0u;
    usize segment_start = 0u;
    for (usize i = 0u; i <= total_length; ++i) {
        bool at_end = (i == total_length);
        char c = at_end ? '\0' : value_text[i];
        if (c == ',' || at_end) {
            if (parsed_count >= 3u) {
                console_write(2, command_name);
                console_line(2, ": --fiducials accepts at most three numeric values");
                return false;
            }
            if (i < segment_start) {
                console_write(2, command_name);
                console_line(2, ": --fiducials parsing failure");
                return false;
            }
            usize segment_length = i - segment_start;
            if (segment_length == 0u) {
                console_write(2, command_name);
                console_line(2, ": --fiducials values must be non-empty");
                return false;
            }
            u64 number_value = 0u;
            if (!ascii_to_u64(value_text + segment_start, segment_length, &number_value)) {
                console_write(2, command_name);
                console_line(2, ": --fiducials values must be unsigned integers");
                return false;
            }
            parsed_values[parsed_count++] = number_value;
            segment_start = i + 1u;
            continue;
        }
        if (c < '0' || c > '9') {
            console_write(2, command_name);
            console_line(2, ": --fiducials values must be numeric");
            return false;
        }
    }
    if (parsed_count < 2u) {
        console_write(2, command_name);
        console_line(2, ": --fiducials requires at least size and spacing");
        return false;
    }
    if (parsed_values[0] == 0u || parsed_values[0] > 0xFFFFFFFFull) {
        console_write(2, command_name);
        console_line(2, ": --fiducials size must be between 1 and 4294967295");
        return false;
    }
    if (parsed_values[1] == 0u || parsed_values[1] > 0xFFFFFFFFull) {
        console_write(2, command_name);
        console_line(2, ": --fiducials spacing must be between 1 and 4294967295");
        return false;
    }
    if (parsed_values[1] < parsed_values[0]) {
        console_write(2, command_name);
        console_line(2, ": --fiducials spacing must be >= size");
        return false;
    }
    defaults.marker_size_pixels = (u32)parsed_values[0];
    defaults.spacing_pixels = (u32)parsed_values[1];
    if (parsed_count >= 3u) {
        if (parsed_values[2] > 0xFFFFFFFFull) {
            console_write(2, command_name);
            console_line(2, ": --fiducials margin must be between 0 and 4294967295");
            return false;
        }
        defaults.margin_pixels = (u32)parsed_values[2];
    }
    *handled = true;
    return true;
}

static bool process_image_mapping_option(int arg_count,
                                         char** args,
                                         int* arg_index,
                                         ImageMappingConfig& config,
                                         const char* command_name,
                                         bool* handled) {
    if (!handled || !arg_index || !args) {
        return false;
    }
    *handled = false;
    int index = *arg_index;
    if (index < 0 || index >= arg_count) {
        return false;
    }
    const char* arg = args[index];
    if (!arg) {
        return true;
    }

    const char palette_prefix[] = "--palette=";
    const char* palette_value = 0;
    usize palette_length = 0u;
    if (ascii_equals_token(arg, ascii_length(arg), "--palette")) {
        if ((index + 1) >= arg_count) {
            console_write(2, command_name);
            console_line(2, ": --palette requires a quoted list of colors");
            return false;
        }
        palette_value = args[index + 1];
        if (!palette_value) {
            console_write(2, command_name);
            console_line(2, ": --palette requires a quoted list of colors");
            return false;
        }
        palette_length = ascii_length(palette_value);
        *arg_index = index + 1;
    } else if (ascii_starts_with(arg, palette_prefix)) {
        palette_value = arg + (sizeof(palette_prefix) - 1u);
        palette_length = ascii_length(palette_value);
    }
    if (palette_value) {
        if (!image_mapping_set_palette_text(config, palette_value, palette_length, command_name)) {
            return false;
        }
        *handled = true;
        return true;
    }

    const char width_prefix[] = "--page-width=";
    const char* value_text = 0;
    usize length = 0u;
    if (ascii_equals_token(arg, ascii_length(arg), "--page-width")) {
        if ((index + 1) >= arg_count) {
            console_write(2, command_name);
            console_line(2, ": --page-width requires a value (pixels)");
            return false;
        }
        value_text = args[index + 1];
        if (!value_text) {
            console_write(2, command_name);
            console_line(2, ": --page-width requires a value (pixels)");
            return false;
        }
        length = ascii_length(value_text);
        *arg_index = index + 1;
    } else if (ascii_starts_with(arg, width_prefix)) {
        value_text = arg + (sizeof(width_prefix) - 1u);
        length = ascii_length(value_text);
    }
    if (value_text) {
        if (length == 0u) {
            console_write(2, command_name);
            console_line(2, ": --page-width requires a value (pixels)");
            return false;
        }
        u64 value = 0u;
        if (!ascii_to_u64(value_text, length, &value) || value == 0u || value > 0xFFFFFFFFu) {
            console_write(2, command_name);
            console_line(2, ": --page-width must be a positive integer number of pixels");
            return false;
        }
        config.page_width_pixels = (u32)value;
        config.page_width_set = true;
        *handled = true;
        return true;
    }

    const char height_prefix[] = "--page-height=";
    value_text = 0;
    length = 0u;
    if (ascii_equals_token(arg, ascii_length(arg), "--page-height")) {
        if ((index + 1) >= arg_count) {
            console_write(2, command_name);
            console_line(2, ": --page-height requires a value (pixels)");
            return false;
        }
        value_text = args[index + 1];
        if (!value_text) {
            console_write(2, command_name);
            console_line(2, ": --page-height requires a value (pixels)");
            return false;
        }
        length = ascii_length(value_text);
        *arg_index = index + 1;
    } else if (ascii_starts_with(arg, height_prefix)) {
        value_text = arg + (sizeof(height_prefix) - 1u);
        length = ascii_length(value_text);
    }
    if (value_text) {
        if (length == 0u) {
            console_write(2, command_name);
            console_line(2, ": --page-height requires a value (pixels)");
            return false;
        }
        u64 value = 0u;
        if (!ascii_to_u64(value_text, length, &value) || value == 0u || value > 0xFFFFFFFFu) {
            console_write(2, command_name);
            console_line(2, ": --page-height must be a positive integer number of pixels");
            return false;
        }
        config.page_height_pixels = (u32)value;
        config.page_height_set = true;
        *handled = true;
        return true;
    }
    return true;
}

static bool read_entire_stdin(makocode::ByteBuffer& buffer) {
    const usize chunk = 4096u;
    usize total = 0u;
    for (;;) {
        if (!buffer.ensure(total + chunk)) {
            return false;
        }
        int read_result = read(0, buffer.data + total, chunk);
        if (read_result < 0) {
            return false;
        }
        if (read_result == 0) {
            break;
        }
        total += (usize)read_result;
        buffer.size = total;
    }
    buffer.size = total;
    return true;
}

static bool read_entire_file(const char* path, makocode::ByteBuffer& buffer) {
    if (!path) {
        return false;
    }
    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        return false;
    }
    buffer.release();
    const usize chunk = 4096u;
    usize total = 0u;
    for (;;) {
        if (!buffer.ensure(total + chunk)) {
            close(fd);
            return false;
        }
        int read_result = read(fd, buffer.data + total, chunk);
        if (read_result < 0) {
            close(fd);
            return false;
        }
        if (read_result > 0 && total == 0u && debug_logging_enabled()) {
            char debug_msg[64];
            u64_to_ascii((u64)read_result, debug_msg, sizeof(debug_msg));
            console_write(2, "debug read chunk size: ");
            console_line(2, debug_msg);
        }
        if (read_result == 0) {
            break;
        }
        total += (usize)read_result;
        buffer.size = total;
    }
    buffer.size = total;
    close(fd);
    if (debug_logging_enabled() && buffer.size >= 8u && buffer.data) {
        console_write(2, "debug file first bytes: ");
        for (usize debug_i = 0u; debug_i < 8u && debug_i < buffer.size; ++debug_i) {
            char value_buffer[32];
            u64_to_ascii((u64)(unsigned char)buffer.data[debug_i], value_buffer, sizeof(value_buffer));
            console_write(2, value_buffer);
            if ((debug_i + 1u) < buffer.size && debug_i < 7u) {
                console_write(2, " ");
            }
        }
        console_line(2, "");
    }
    return true;
}

static const char ARCHIVE_MAGIC[8] = {'M', 'K', 'A', 'R', 'C', 'H', '0', '1'};
static const usize ARCHIVE_MAGIC_SIZE = (usize)sizeof(ARCHIVE_MAGIC);
static const usize ARCHIVE_HEADER_SIZE = ARCHIVE_MAGIC_SIZE + 4u;
static const usize MAX_ARCHIVE_PATH_COMPONENTS = 512u;

struct ArchiveBuildContext {
    makocode::ByteBuffer buffer;
    makocode::ByteBuffer path_registry;
    u32 entry_count;

    ArchiveBuildContext()
        : buffer(),
          path_registry(),
          entry_count(0u) {}

    ~ArchiveBuildContext() {
        buffer.release();
        path_registry.release();
        entry_count = 0u;
    }
};

static bool archive_init(ArchiveBuildContext& ctx) {
    ctx.buffer.release();
    ctx.path_registry.release();
    ctx.entry_count = 0u;
    if (!ctx.buffer.ensure(ARCHIVE_HEADER_SIZE)) {
        return false;
    }
    for (usize i = 0u; i < ARCHIVE_MAGIC_SIZE; ++i) {
        ctx.buffer.data[i] = (u8)ARCHIVE_MAGIC[i];
    }
    write_le_u32(ctx.buffer.data + ARCHIVE_MAGIC_SIZE, 0u);
    ctx.buffer.size = ARCHIVE_HEADER_SIZE;
    return true;
}

static bool archive_append_u8(makocode::ByteBuffer& buffer, u8 value) {
    if (!buffer.ensure(buffer.size + 1u)) {
        return false;
    }
    buffer.data[buffer.size++] = value;
    return true;
}

static bool archive_append_u32(makocode::ByteBuffer& buffer, u32 value) {
    if (!buffer.ensure(buffer.size + 4u)) {
        return false;
    }
    write_le_u32(buffer.data + buffer.size, value);
    buffer.size += 4u;
    return true;
}

static bool archive_append_u64(makocode::ByteBuffer& buffer, u64 value) {
    if (!buffer.ensure(buffer.size + 8u)) {
        return false;
    }
    write_le_u64(buffer.data + buffer.size, value);
    buffer.size += 8u;
    return true;
}

static bool archive_append_bytes(makocode::ByteBuffer& buffer,
                                 const u8* data,
                                 usize length) {
    if (length == 0u) {
        return true;
    }
    if (!buffer.ensure(buffer.size + length)) {
        return false;
    }
    for (usize i = 0u; i < length; ++i) {
        buffer.data[buffer.size + i] = data ? data[i] : 0u;
    }
    buffer.size += length;
    return true;
}

static bool archive_register_path(ArchiveBuildContext& ctx,
                                  const char* path,
                                  usize length,
                                  bool* duplicate_out) {
    if (duplicate_out) {
        *duplicate_out = false;
    }
    if (!path || length == 0u) {
        return false;
    }
    usize cursor = 0u;
    while (cursor < ctx.path_registry.size) {
        const char* existing = (const char*)(ctx.path_registry.data + cursor);
        usize existing_length = ascii_length(existing);
        if (existing_length == length) {
            bool same = true;
            for (usize i = 0u; i < length; ++i) {
                if (existing[i] != path[i]) {
                    same = false;
                    break;
                }
            }
            if (same) {
                if (duplicate_out) {
                    *duplicate_out = true;
                }
                return false;
            }
        }
        cursor += existing_length + 1u;
    }
    if (!ctx.path_registry.ensure(ctx.path_registry.size + length + 1u)) {
        return false;
    }
    u8* dest = ctx.path_registry.data + ctx.path_registry.size;
    for (usize i = 0u; i < length; ++i) {
        dest[i] = (u8)path[i];
    }
    dest[length] = 0u;
    ctx.path_registry.size += length + 1u;
    return true;
}

static bool archive_add_directory(ArchiveBuildContext& ctx,
                                  const char* rel_path) {
    if (!rel_path) {
        return false;
    }
    usize path_len = ascii_length(rel_path);
    if (path_len == 0u || path_len > 0xFFFFFFFFu) {
        return false;
    }
    bool duplicate = false;
    if (!archive_register_path(ctx, rel_path, path_len, &duplicate)) {
        if (duplicate) {
            console_write(2, "encode: duplicate entry path ");
            console_line(2, rel_path);
        }
        return false;
    }
    if (!archive_append_u8(ctx.buffer, 1u)) {
        return false;
    }
    if (!archive_append_u32(ctx.buffer, (u32)path_len)) {
        return false;
    }
    if (!archive_append_bytes(ctx.buffer, (const u8*)rel_path, path_len)) {
        return false;
    }
    ++ctx.entry_count;
    return true;
}

static bool archive_add_file(ArchiveBuildContext& ctx,
                             const char* rel_path,
                             const u8* data,
                             usize length) {
    if (!rel_path) {
        return false;
    }
    usize path_len = ascii_length(rel_path);
    if (path_len == 0u || path_len > 0xFFFFFFFFu) {
        return false;
    }
    bool duplicate = false;
    if (!archive_register_path(ctx, rel_path, path_len, &duplicate)) {
        if (duplicate) {
            console_write(2, "encode: duplicate entry path ");
            console_line(2, rel_path);
        }
        return false;
    }
    if (!archive_append_u8(ctx.buffer, 0u)) {
        return false;
    }
    if (!archive_append_u32(ctx.buffer, (u32)path_len)) {
        return false;
    }
    if (!archive_append_bytes(ctx.buffer, (const u8*)rel_path, path_len)) {
        return false;
    }
    if (!archive_append_u64(ctx.buffer, (u64)length)) {
        return false;
    }
    if (!archive_append_bytes(ctx.buffer, data, length)) {
        return false;
    }
    ++ctx.entry_count;
    return true;
}

static bool archive_finalize(ArchiveBuildContext& ctx) {
    if (ctx.buffer.size < ARCHIVE_HEADER_SIZE) {
        return false;
    }
    write_le_u32(ctx.buffer.data + ARCHIVE_MAGIC_SIZE, ctx.entry_count);
    return true;
}

static const char* find_last_path_component(const char* path) {
    if (!path) {
        return path;
    }
    usize length = ascii_length(path);
    if (length == 0u) {
        return path;
    }
    const char* start = path;
    const char* end = path + length;
    while (end > start) {
        char c = end[-1];
        if (c == '/' || c == '\\') {
            --end;
        } else {
            break;
        }
    }
    const char* component = start;
    const char* cursor = start;
    while (cursor < end) {
        char c = *cursor;
        if (c == '/' || c == '\\') {
            component = cursor + 1;
        }
        ++cursor;
    }
    if (component >= end) {
        return component;
    }
    return component;
}

static bool normalize_store_path(const char* source,
                                 makocode::ByteBuffer& output) {
    output.release();
    if (!source) {
        return false;
    }
    usize length = ascii_length(source);
    if (length == 0u) {
        return false;
    }
    makocode::ByteBuffer scratch;
    if (!scratch.ensure(length)) {
        return false;
    }
    scratch.size = length;
    for (usize i = 0u; i < length; ++i) {
        char c = source[i];
        if (c == '\\') {
            c = '/';
        }
        scratch.data[i] = (u8)c;
    }
    usize component_offsets[MAX_ARCHIVE_PATH_COMPONENTS];
    usize component_lengths[MAX_ARCHIVE_PATH_COMPONENTS];
    usize component_count = 0u;
    usize index = 0u;
    while (index < length) {
        char c = (char)scratch.data[index];
        if (c == '/') {
            ++index;
            continue;
        }
        usize start = index;
        while (index < length) {
            char d = (char)scratch.data[index];
            if (d == '/') {
                break;
            }
            ++index;
        }
        usize segment_length = index - start;
        if (segment_length == 0u) {
            continue;
        }
        if (segment_length == 1u && scratch.data[start] == '.') {
            continue;
        }
        if (segment_length == 2u &&
            scratch.data[start] == '.' &&
            scratch.data[start + 1u] == '.') {
            if (component_count > 0u) {
                --component_count;
            }
            continue;
        }
        if (component_count >= MAX_ARCHIVE_PATH_COMPONENTS) {
            scratch.release();
            return false;
        }
        component_offsets[component_count] = start;
        component_lengths[component_count] = segment_length;
        ++component_count;
    }
    if (component_count == 0u) {
        scratch.release();
        char* resolved = realpath(source, 0);
        if (!resolved) {
            return false;
        }
        const char* base = find_last_path_component(resolved);
        usize base_len = ascii_length(base);
        bool valid_base = (base_len > 0u);
        if (valid_base) {
            if (base_len == 1u && base[0] == '.') {
                valid_base = false;
            } else if (base_len == 2u && base[0] == '.' && base[1u] == '.') {
                valid_base = false;
            } else {
                for (usize i = 0u; i < base_len; ++i) {
                    char c = base[i];
                    if (c == '/' || c == '\\' || c == 0) {
                        valid_base = false;
                        break;
                    }
                }
            }
        }
        if (valid_base && output.ensure(base_len + 1u)) {
            for (usize i = 0u; i < base_len; ++i) {
                char c = base[i];
                if (c == '\\') {
                    c = '/';
                }
                output.data[i] = (u8)c;
            }
            output.data[base_len] = 0u;
            output.size = base_len;
            free(resolved);
            return true;
        }
        free(resolved);
        return false;
    }
    usize result_length = 0u;
    for (usize i = 0u; i < component_count; ++i) {
        result_length += component_lengths[i];
        if ((i + 1u) < component_count) {
            ++result_length;
        }
    }
    if (!output.ensure(result_length + 1u)) {
        scratch.release();
        return false;
    }
    usize cursor = 0u;
    for (usize i = 0u; i < component_count; ++i) {
        if (i) {
            output.data[cursor++] = (u8)'/';
        }
        usize start = component_offsets[i];
        usize seg_len = component_lengths[i];
        for (usize j = 0u; j < seg_len; ++j) {
            output.data[cursor++] = scratch.data[start + j];
        }
    }
    output.data[cursor] = 0u;
    output.size = cursor;
    scratch.release();
    return true;
}

static bool join_rel_path(const char* base,
                          const char* name,
                          makocode::ByteBuffer& out) {
    out.release();
    if (!name) {
        return false;
    }
    usize name_len = ascii_length(name);
    if (name_len == 0u) {
        return false;
    }
    usize base_len = base ? ascii_length(base) : 0u;
    bool include_base = (base_len > 0u);
    usize total = name_len;
    if (include_base) {
        total += base_len;
        char last = base[base_len - 1u];
        if (last != '/' && last != '\\') {
            ++total;
        }
    }
    if (!out.ensure(total + 1u)) {
        return false;
    }
    usize cursor = 0u;
    if (include_base) {
        for (usize i = 0u; i < base_len; ++i) {
            char c = base[i];
            if (c == '\\') {
                c = '/';
            }
            out.data[cursor++] = (u8)c;
        }
        if (cursor && out.data[cursor - 1u] != '/') {
            out.data[cursor++] = (u8)'/';
        }
    }
    for (usize i = 0u; i < name_len; ++i) {
        char c = name[i];
        if (c == '\\') {
            c = '/';
        }
        out.data[cursor++] = (u8)c;
    }
    out.data[cursor] = 0u;
    out.size = cursor;
    return true;
}

static bool join_fs_path(const char* base,
                         const char* name,
                         makocode::ByteBuffer& out) {
    out.release();
    if (!base || !name) {
        return false;
    }
    usize base_len = ascii_length(base);
    usize name_len = ascii_length(name);
    bool need_separator = (base_len > 0u);
    if (need_separator) {
        char last = base[base_len - 1u];
        if (last == '/' || last == '\\') {
            need_separator = false;
        }
    }
    usize total = base_len + name_len + (need_separator ? 1u : 0u);
    if (!out.ensure(total + 1u)) {
        return false;
    }
    usize cursor = 0u;
    for (usize i = 0u; i < base_len; ++i) {
        out.data[cursor++] = (u8)base[i];
    }
    if (need_separator) {
        out.data[cursor++] = (u8)'/';
    }
    for (usize i = 0u; i < name_len; ++i) {
        out.data[cursor++] = (u8)name[i];
    }
    out.data[cursor] = 0u;
    out.size = cursor;
    return true;
}

static bool archive_collect_directory(const char* fs_path,
                                      const char* rel_path,
                                      ArchiveBuildContext& ctx) {
    if (!fs_path || !rel_path) {
        return false;
    }
    if (!archive_add_directory(ctx, rel_path)) {
        return false;
    }
    DIR* dir = opendir(fs_path);
    if (!dir) {
        console_write(2, "encode: failed to open directory ");
        console_line(2, fs_path);
        return false;
    }
    struct dirent* entry = 0;
    while ((entry = readdir(dir)) != (struct dirent*)0) {
        const char* name = entry->d_name;
        if (!name) {
            continue;
        }
        if (name[0] == '.' &&
            (name[1] == '\0' ||
             (name[1] == '.' && name[2] == '\0'))) {
            continue;
        }
        makocode::ByteBuffer child_fs;
        if (!join_fs_path(fs_path, name, child_fs)) {
            closedir(dir);
            return false;
        }
        makocode::ByteBuffer child_rel;
        if (!join_rel_path(rel_path, name, child_rel)) {
            closedir(dir);
            return false;
        }
        struct stat st;
        if (stat((const char*)child_fs.data, &st) != 0) {
            console_write(2, "encode: unable to stat ");
            console_line(2, (const char*)child_fs.data);
            closedir(dir);
            return false;
        }
        if (S_ISDIR(st.st_mode)) {
            if (!archive_collect_directory((const char*)child_fs.data,
                                           (const char*)child_rel.data,
                                           ctx)) {
                closedir(dir);
                return false;
            }
        } else if (S_ISREG(st.st_mode)) {
            makocode::ByteBuffer file_data;
            if (!read_entire_file((const char*)child_fs.data, file_data)) {
                console_write(2, "encode: failed to read ");
                console_line(2, (const char*)child_fs.data);
                closedir(dir);
                return false;
            }
            if (!archive_add_file(ctx,
                                  (const char*)child_rel.data,
                                  file_data.data,
                                  file_data.size)) {
                file_data.release();
                closedir(dir);
                return false;
            }
            file_data.release();
        } else {
            console_write(2, "encode: unsupported entry type for ");
            console_line(2, (const char*)child_rel.data);
            closedir(dir);
            return false;
        }
    }
    closedir(dir);
    return true;
}

static bool is_safe_archive_path(const char* path, usize length) {
    if (!path || length == 0u) {
        return false;
    }
    if (path[0] == '/') {
        return false;
    }
    for (usize i = 0u; i < length; ++i) {
        char c = path[i];
        if (c == '\\' || c == '\0') {
            return false;
        }
    }
    usize index = 0u;
    while (index < length) {
        while (index < length && path[index] == '/') {
            ++index;
        }
        usize start = index;
        while (index < length && path[index] != '/') {
            ++index;
        }
        usize segment_length = index - start;
        if (segment_length == 0u) {
            continue;
        }
        if (segment_length == 1u && path[start] == '.') {
            return false;
        }
        if (segment_length == 2u &&
            path[start] == '.' &&
            path[start + 1u] == '.') {
            return false;
        }
    }
    return true;
}

static bool ensure_directory_exists(const char* path) {
    if (!path || !path[0]) {
        return true;
    }
    struct stat st;
    if (stat(path, &st) == 0) {
        return S_ISDIR(st.st_mode);
    }
    if (mkdir(path, 0755) == 0) {
        return true;
    }
    if (errno == EEXIST) {
        if (stat(path, &st) == 0) {
            return S_ISDIR(st.st_mode);
        }
    }
    return false;
}

static bool ensure_directory_tree(const char* path) {
    if (!path || !path[0]) {
        return true;
    }
    makocode::ByteBuffer temp;
    usize length = ascii_length(path);
    if (!temp.ensure(length + 1u)) {
        return false;
    }
    for (usize i = 0u; i < length; ++i) {
        char c = path[i];
        if (c == '\\') {
            c = '/';
        }
        temp.data[i] = (u8)c;
    }
    temp.data[length] = 0u;
    temp.size = length;
    for (usize i = 1u; i <= length; ++i) {
        char c = (char)temp.data[i];
        if (c == '/' || c == 0) {
            char saved = (char)temp.data[i];
            temp.data[i] = 0u;
            const char* partial = (const char*)temp.data;
            if (partial[0] != 0) {
                if (!ensure_directory_exists(partial)) {
                    temp.data[i] = saved;
                    return false;
                }
            }
            temp.data[i] = (u8)saved;
        }
    }
    return true;
}

static bool ensure_parent_directories(const char* file_path) {
    if (!file_path) {
        return false;
    }
    usize length = ascii_length(file_path);
    if (length == 0u) {
        return false;
    }
    usize i = length;
    while (i > 0u) {
        char c = file_path[i - 1u];
        if (c == '/' || c == '\\') {
            break;
        }
        --i;
    }
    if (i == 0u) {
        return true;
    }
    makocode::ByteBuffer parent;
    if (!parent.ensure(i + 1u)) {
        return false;
    }
    for (usize j = 0u; j < i; ++j) {
        char c = file_path[j];
        if (c == '\\') {
            c = '/';
        }
        parent.data[j] = (u8)c;
    }
    parent.data[i] = 0u;
    parent.size = i;
    return ensure_directory_tree((const char*)parent.data);
}

static bool join_output_path(const char* base_dir,
                             const char* rel_path,
                             makocode::ByteBuffer& out) {
    out.release();
    if (!rel_path) {
        return false;
    }
    usize rel_len = ascii_length(rel_path);
    if (rel_len == 0u) {
        return false;
    }
    bool include_base = false;
    usize base_len = 0u;
    if (base_dir && base_dir[0]) {
        base_len = ascii_length(base_dir);
        if (!(base_len == 1u && base_dir[0] == '.')) {
            include_base = true;
        }
    }
    bool need_separator = false;
    if (include_base) {
        char last = base_dir[base_len - 1u];
        if (last != '/' && last != '\\') {
            need_separator = true;
        }
    }
    usize total = rel_len;
    if (include_base) {
        total += base_len + (need_separator ? 1u : 0u);
    }
    if (!out.ensure(total + 1u)) {
        return false;
    }
    usize cursor = 0u;
    if (include_base) {
        for (usize i = 0u; i < base_len; ++i) {
            char c = base_dir[i];
            if (c == '\\') {
                c = '/';
            }
            out.data[cursor++] = (u8)c;
        }
        if (need_separator) {
            out.data[cursor++] = (u8)'/';
        }
    }
    for (usize i = 0u; i < rel_len; ++i) {
        char c = rel_path[i];
        if (c == '\\') {
            c = '/';
        }
        out.data[cursor++] = (u8)c;
    }
    out.data[cursor] = 0u;
    out.size = cursor;
    return true;
}

static bool unpack_archive_to_directory(const makocode::ByteBuffer& payload,
                                        const char* output_dir) {
    if (!payload.data || payload.size < ARCHIVE_HEADER_SIZE) {
        console_line(2, "decode: payload missing archive header");
        return false;
    }
    for (usize i = 0u; i < ARCHIVE_MAGIC_SIZE; ++i) {
        if (payload.data[i] != (u8)ARCHIVE_MAGIC[i]) {
            console_line(2, "decode: payload is not a makocode archive");
            return false;
        }
    }
    u32 entry_count = read_le_u32(payload.data + ARCHIVE_MAGIC_SIZE);
    usize cursor = ARCHIVE_HEADER_SIZE;
    for (u32 entry_index = 0u; entry_index < entry_count; ++entry_index) {
        if (cursor >= payload.size) {
            console_line(2, "decode: archive truncated before entries completed");
            return false;
        }
        u8 entry_type = payload.data[cursor++];
        if ((payload.size - cursor) < 4u) {
            console_line(2, "decode: archive truncated during path length read");
            return false;
        }
        u32 path_length = read_le_u32(payload.data + cursor);
        cursor += 4u;
        if (path_length == 0u) {
            console_line(2, "decode: archive entry has empty path");
            return false;
        }
        if ((payload.size - cursor) < (usize)path_length) {
            console_line(2, "decode: archive truncated during path read");
            return false;
        }
        makocode::ByteBuffer path_buffer;
        if (!path_buffer.ensure(path_length + 1u)) {
            return false;
        }
        for (u32 i = 0u; i < path_length; ++i) {
            path_buffer.data[i] = payload.data[cursor + i];
        }
        path_buffer.data[path_length] = 0u;
        path_buffer.size = path_length;
        const char* entry_path = (const char*)path_buffer.data;
        if (!is_safe_archive_path(entry_path, path_length)) {
            console_write(2, "decode: unsafe archive path ");
            console_line(2, entry_path);
            return false;
        }
        cursor += (usize)path_length;
        if (entry_type == 1u) {
            makocode::ByteBuffer output_path;
            if (!join_output_path(output_dir, entry_path, output_path)) {
                return false;
            }
            if (!ensure_directory_tree((const char*)output_path.data)) {
                console_write(2, "decode: failed to create directory ");
                console_line(2, (const char*)output_path.data);
                return false;
            }
        } else if (entry_type == 0u) {
            if ((payload.size - cursor) < 8u) {
                console_line(2, "decode: archive truncated during file size read");
                return false;
            }
            u64 file_size = read_le_u64(payload.data + cursor);
            cursor += 8u;
            if ((payload.size - cursor) < file_size) {
                console_line(2, "decode: archive truncated during file data read");
                return false;
            }
            const u8* file_data = payload.data + cursor;
            cursor += (usize)file_size;
            makocode::ByteBuffer output_path;
            if (!join_output_path(output_dir, entry_path, output_path)) {
                return false;
            }
            if (!ensure_parent_directories((const char*)output_path.data)) {
                console_write(2, "decode: failed to prepare directories for ");
                console_line(2, (const char*)output_path.data);
                return false;
            }
            if (!write_bytes_to_file((const char*)output_path.data,
                                     file_data,
                                     (usize)file_size)) {
                console_write(2, "decode: failed to write file ");
                console_line(2, (const char*)output_path.data);
                return false;
            }
        } else {
            console_line(2, "decode: unknown archive entry type");
            return false;
        }
    }
    if (cursor != payload.size) {
        console_line(2, "decode: archive payload has trailing data");
        return false;
    }
    return true;
}

static void write_usage() {
    console_line(1, "MakoCode CLI");
    console_line(1, "Usage:");
    console_line(1, "  makocode encode [options]   (reads payload from file; emits PPM pages)");
    console_line(1, "  makocode decode [options] files... (reads PPM pages; use stdin when no files)");
    console_line(1, "  makocode overlay BASE.ppm OVERLAY.ppm FRACTION (writes merged page to stdout)");
    console_line(1, "  makocode minify             (writes makocode_minified.cpp without comments)");
    console_line(1, "Options:");
    console_line(1, "  --palette \"Color ...\" (2-16 unique names from White/Cyan/Magenta/Yellow/Black; default palette is White Black)");
    console_line(1, "  --page-width PX    (page width in pixels; default 2480)");
    console_line(1, "  --page-height PX   (page height in pixels; default 3508)");
    console_line(1, "  --fiducials S,D[,M] (marker size, spacing, optional margin; default 4,24,12)");
    console_line(1, "  --input PATH       (encode: repeat to add files or directories)");
    console_line(1, "  --output-dir PATH  (encode: PPM output directory; decode: extract destination; default .)");
    console_line(1, "  --prefix TEXT       (encode: base name for generated pages; default UTC timestamp, no '/' or '\\\\').");
    console_line(1, "  --ecc RATIO        (Reed-Solomon redundancy; default 0.20, 0 disables)");
    console_line(1, "  --ecc-fill         Compute the ECC ratio that will fill the final page and use it for encoding");
    console_line(1, "  --password TEXT    (encrypt payload with ChaCha20-Poly1305 using TEXT)");
    console_line(1, "  --no-filename      (omit payload filename from footer text)");
    console_line(1, "  --no-page-count    (omit page index/total from footer text)");
    console_line(1, "  --title TEXT       (optional footer title; letters, digits, common symbols)");
    console_line(1, "  --font-size PX     (footer font scale in pixels; default 1)");
    console_line(1, "  --debug            (emit verbose diagnostic logs; default off)");
    console_line(1, "");
    console_line(1, "Run 'makocode <command> --help' (or -h) for command-specific details.");
}

static bool arguments_request_help(int arg_count, char** args) {
    for (int i = 0; i < arg_count; ++i) {
        const char* arg = args ? args[i] : 0;
        if (!arg) {
            continue;
        }
        usize length = ascii_length(arg);
        if (ascii_equals_token(arg, length, "--help") ||
            ascii_equals_token(arg, length, "-h")) {
            return true;
        }
    }
    return false;
}

static void write_encode_help() {
    console_line(1, "makocode encode");
    console_line(1, "Usage: makocode encode --input PATH [--input PATH ...] [options]");
    console_line(1, "Packages files/directories into fiducial-marked printable PPM pages.");
    console_line(1, "");
    console_line(1, "Required:");
    console_line(1, "  --input PATH         Add a file or directory to the archive (repeatable).");
    console_line(1, "");
    console_line(1, "Output:");
    console_line(1, "  --output-dir PATH    Directory for generated PPM pages (default current directory).");
    console_line(1, "  --prefix TEXT        Base filename prefix for generated pages (default UTC timestamp, no '/' or '\\\\').");
    console_line(1, "");
    console_line(1, "Layout:");
    console_line(1, "  --palette \"Color ...\"   Custom palette (2-16 unique entries from White/Cyan/Magenta/Yellow/Black; default is \"White Black\").");
    console_line(1, "  --page-width PX      Override page width in pixels (default 2480).");
    console_line(1, "  --page-height PX     Override page height in pixels (default 3508).");
    console_line(1, "  --compact-page       Shrink single-page output height to minimal fit (disables fixed barcode placement).");
    console_line(1, "  --fiducials S,D[,M]  Marker size, spacing, optional margin (default 4,24,12).");
    console_line(1, "");
    console_line(1, "ECC & security:");
    console_line(1, "  --ecc RATIO          Reed-Solomon redundancy (default 0.20, 0 disables).");
    console_line(1, "  --ecc-fill           Derive the ECC ratio that fills the final page and emit pages with that redundancy.");
    console_line(1, "  --password TEXT      Encrypt payload with ChaCha20-Poly1305.");
    console_line(1, "");
    console_line(1, "Footer customization:");
    console_line(1, "  --title TEXT         Footer title (letters/digits/common symbols).");
    console_line(1, "  --font-size PX       Footer font scaling (default 1, max 2048).");
    console_line(1, "  --no-filename        Remove payload filename from footer text.");
    console_line(1, "  --no-page-count      Remove page index/total from footer text.");
    console_line(1, "");
    console_line(1, "General:");
    console_line(1, "  --debug              Emit verbose diagnostic logs to stderr.");
    console_line(1, "  --help               Show this message.");
    console_line(1, "All options accept either --flag=value or --flag value forms where supported.");
}

static void write_decode_help() {
    console_line(1, "makocode decode");
    console_line(1, "Usage: makocode decode [options] [PPM files...]");
    console_line(1, "Reads pages from files or stdin (when no files) and reconstructs the archive.");
    console_line(1, "");
    console_line(1, "Output & security:");
    console_line(1, "  --output-dir PATH    Destination directory (default current directory).");
    console_line(1, "  --password TEXT      Supply the decryption password for protected payloads.");
    console_line(1, "");
    console_line(1, "Layout overrides (match encoder settings when non-default):");
    console_line(1, "  --palette \"Color ...\"   Custom palette (2-16 unique entries from White/Cyan/Magenta/Yellow/Black; default is \"White Black\").");
    console_line(1, "  --page-width PX      Page width in pixels (default 2480).");
    console_line(1, "  --page-height PX     Page height in pixels (default 3508).");
    console_line(1, "  --fiducials S,D[,M]  Marker size, spacing, optional margin (default 4,24,12).");
    console_line(1, "");
    console_line(1, "General:");
    console_line(1, "  --debug              Emit verbose diagnostic logs to stderr.");
    console_line(1, "  --help               Show this message.");
    console_line(1, "Provide one or more PPM files, or pipe pages via stdin.");
}

static void write_overlay_help() {
    console_line(1, "makocode overlay");
    console_line(1, "Usage: makocode overlay [--ignore-colors COLORS] [--overlay-ecc-target TARGET] BASE.ppm OVERLAY.ppm FRACTION");
    console_line(1, "Blends OVERLAY data bytes into BASE using FRACTION (0.0-1.0 decimal).");
    console_line(1, "Both pages must share dimensions and fiducial layout.");
    console_line(1, "  --ignore-colors COLORS  Skip writing overlay pixels whose color matches one of the listed");
    console_line(1, "                           color names (White/Cyan/Magenta/Yellow/Black) or hex tokens (RRGGBB).");
    console_line(1, "  --overlay-ecc-target TARGET  Aim to consume this fraction (0.0-1.0) of the ECC parity budget.");
}

static void write_minify_help() {
    console_line(1, "makocode minify");
    console_line(1, "Usage: makocode minify");
    console_line(1, "Strips comments/whitespace from makocode.cpp and emits makocode_minified.cpp.");
}

static bool title_char_is_allowed(char c) {
    bool is_digit = (c >= '0' && c <= '9');
    bool is_upper = (c >= 'A' && c <= 'Z');
    bool is_lower = (c >= 'a' && c <= 'z');
    if (is_digit || is_upper || is_lower) {
        return true;
    }
    switch (c) {
        case ' ':
        case '!':
        case '@':
        case '#':
        case '$':
        case '%':
        case '^':
        case '&':
        case '*':
        case '+':
        case '(':
        case ')':
        case '{':
        case '}':
        case '[':
        case ']':
        case ':':
        case '"':
        case ';':
        case '\'':
        case '<':
        case '=':
        case '>':
        case '?':
        case ',':
        case '-':
        case '.':
        case '/':
        case '`':
        case '~':
        case '|':
        case '\\':
        case '_':
            return true;
        default:
            break;
    }
    return false;
}

static usize decimal_digit_count(u64 value) {
    if (value == 0u) {
        return 1u;
    }
    usize digits = 0u;
    while (value) {
        value /= 10u;
        ++digits;
    }
    return digits ? digits : 1u;
}

static usize footer_compute_page_text_length(const PageFooterConfig& footer,
                                             u64 page_index,
                                             u64 page_count) {
    usize length = 0u;
    bool need_separator = false;
    if (footer.has_title && footer.title_text && footer.title_length) {
        if (need_separator) {
            length += 3u; // " | "
        }
        length += footer.title_length;
        need_separator = true;
    }
    if (footer.display_filename && footer.has_filename && footer.filename_text && footer.filename_length) {
        if (need_separator) {
            length += 3u; // " | "
        }
        length += footer.filename_length;
        need_separator = true;
    }
    if (footer.display_page_info) {
        if (page_index == 0u) {
            page_index = 1u;
        }
        if (page_count == 0u) {
            page_count = 1u;
        }
        if (need_separator) {
            length += 3u; // " | "
        }
        length += 5u; // "Page "
        length += decimal_digit_count(page_index);
        length += 1u; // '/'
        length += decimal_digit_count(page_count);
    }
    return length;
}

static usize footer_compute_max_text_length(const PageFooterConfig& footer,
                                            u64 page_count) {
    if (page_count == 0u) {
        page_count = 1u;
    }
    usize max_length = 0u;
    for (u64 index = 1u; index <= page_count; ++index) {
        usize length = footer_compute_page_text_length(footer, index, page_count);
        if (length > max_length) {
            max_length = length;
        }
    }
    return max_length;
}

static bool footer_build_page_text(const PageFooterConfig& footer,
                                   u64 page_index,
                                   u64 page_count,
                                   makocode::ByteBuffer& buffer) {
    if (page_index == 0u) {
        page_index = 1u;
    }
    if (page_count == 0u) {
        page_count = 1u;
    }
    usize length = footer_compute_page_text_length(footer, page_index, page_count);
    if (!buffer.ensure(length + 1u)) {
        return false;
    }
    usize cursor = 0u;
    bool need_separator = false;
    if (footer.has_title && footer.title_text && footer.title_length) {
        if (need_separator) {
            buffer.data[cursor++] = ' ';
            buffer.data[cursor++] = '|';
            buffer.data[cursor++] = ' ';
        }
        for (usize i = 0u; i < footer.title_length; ++i) {
            buffer.data[cursor++] = (u8)footer.title_text[i];
        }
        need_separator = true;
    }
    if (footer.display_filename && footer.has_filename && footer.filename_text && footer.filename_length) {
        if (need_separator) {
            buffer.data[cursor++] = ' ';
            buffer.data[cursor++] = '|';
            buffer.data[cursor++] = ' ';
        }
        for (usize i = 0u; i < footer.filename_length; ++i) {
            buffer.data[cursor++] = (u8)footer.filename_text[i];
        }
        need_separator = true;
    }
    if (footer.display_page_info) {
        if (need_separator) {
            buffer.data[cursor++] = ' ';
            buffer.data[cursor++] = '|';
            buffer.data[cursor++] = ' ';
        }
        buffer.data[cursor++] = 'P';
        buffer.data[cursor++] = 'a';
        buffer.data[cursor++] = 'g';
        buffer.data[cursor++] = 'e';
        buffer.data[cursor++] = ' ';
        char number[32];
        u64_to_ascii(page_index, number, sizeof(number));
        usize digits = 0u;
        while (number[digits]) {
            buffer.data[cursor++] = (u8)number[digits++];
        }
        buffer.data[cursor++] = '/';
        u64_to_ascii(page_count, number, sizeof(number));
        digits = 0u;
        while (number[digits]) {
            buffer.data[cursor++] = (u8)number[digits++];
        }
    }
    if (cursor != length) {
        buffer.size = cursor;
        buffer.data[cursor] = 0u;
        return false;
    }
    buffer.data[length] = 0u;
    buffer.size = length;
    return true;
}

static bool compute_page_layout(const ImageMappingConfig& mapping,
                                PageFooterConfig& footer_config,
                                u64 frame_bit_count,
                                u32 width_pixels,
                                u32 height_pixels,
                                FooterLayout& footer_layout,
                                u32& data_height_pixels,
                                u64& bits_per_page,
                                u64& page_count) {
    u8 sample_bits = bits_per_sample(mapping.color_channels);
    u8 samples_per_pixel = color_mode_samples_per_pixel(mapping.color_channels);
    if (sample_bits == 0u || samples_per_pixel == 0u) {
        return false;
    }
    double bits_per_pixel = mapping_bits_per_data_pixel(mapping);
    if (bits_per_pixel <= 0.0) {
        return false;
    }
    data_height_pixels = height_pixels;
    bits_per_page = 0u;
    page_count = 1u;
    const u32 MAX_FOOTER_LAYOUT_PASSES = 16u;
    bool layout_converged = false;
    for (u32 pass = 0u; pass < MAX_FOOTER_LAYOUT_PASSES; ++pass) {
        // Footer barcode removed: disable stripe sizing hints.
        footer_config.stripe_rows_hint = 0u;
        footer_config.stripe_module_count_hint = 0u;
        footer_config.stripe_module_pitch_hint = 0u;
        u64 text_page_count = footer_config.display_page_info ? page_count : 1u;
        footer_config.max_text_length = footer_compute_max_text_length(footer_config, text_page_count);
        if (!compute_footer_layout(width_pixels, height_pixels, footer_config, footer_layout)) {
            return false;
        }
        data_height_pixels = footer_layout.data_height_pixels;
        if (footer_layout.stripe_height_pixels > 0u && data_height_pixels >= height_pixels) {
            console_line(2, "encode: footer layout would drop the barcode footer");
            return false;
        }
        if (data_height_pixels == 0u || data_height_pixels > height_pixels) {
            return false;
        }
        if (!compute_bits_per_page(width_pixels,
                                   height_pixels,
                                   data_height_pixels,
                                   bits_per_pixel,
                                   bits_per_page,
                                   0)) {
            return false;
        }
        if (bits_per_page == 0u) {
            return false;
        }
        u64 new_page_count = (frame_bit_count + bits_per_page - 1u) / bits_per_page;
        if (new_page_count == 0u) {
            new_page_count = 1u;
        }
        if (!footer_config.display_page_info || new_page_count == page_count) {
            page_count = new_page_count;
            layout_converged = true;
            break;
        }
        page_count = new_page_count;
    }
    return layout_converged;
}

static bool compute_frame_statistics(usize payload_bytes,
                                     double redundancy,
                                     u16& block_data,
                                     u16& parity_symbols,
                                     u64& block_count,
                                     u64& payload_bit_count,
                                     u64& frame_bit_count) {
    block_data = 0u;
    parity_symbols = 0u;
    block_count = 0u;
    payload_bit_count = 0u;
    frame_bit_count = 64u;
    if (payload_bytes == 0u) {
        payload_bit_count = 0u;
        frame_bit_count = 64u;
        return true;
    }
    if (redundancy <= 0.0) {
        payload_bit_count = (u64)payload_bytes * 8u;
        if (payload_bit_count > U64_MAX_VALUE - 64u) {
            return false;
        }
        frame_bit_count = payload_bit_count + 64u;
        return true;
    }
        if (!makocode::compute_ecc_layout(payload_bytes, redundancy, block_data, parity_symbols, block_count)) {
            return false;
        }
    if (block_data == 0u || parity_symbols == 0u || block_count == 0u) {
        return false;
    }
    u64 total_symbols = (u64)(block_data + parity_symbols) * block_count;
    if (total_symbols > (U64_MAX_VALUE / 8u)) {
        return false;
    }
    u64 encoded_bits = total_symbols * 8u;
    if (encoded_bits > U64_MAX_VALUE - makocode::ECC_HEADER_TOTAL_BITS) {
        return false;
    }
    payload_bit_count = encoded_bits + makocode::ECC_HEADER_TOTAL_BITS;
    if (payload_bit_count > U64_MAX_VALUE - 64u) {
        return false;
    }
    frame_bit_count = payload_bit_count + 64u;
    return true;
}

struct EccFillCandidate {
    double ratio;
    u16 block_data;
    u16 parity;
    u64 block_count;
    u64 payload_bits;
    u64 frame_bits;
    u64 bits_per_page;
    u64 page_count;
};

static bool evaluate_ecc_fill_candidate(usize payload_bytes,
                                        double redundancy,
                                        const ImageMappingConfig& mapping,
                                        const PageFooterConfig& footer_template,
                                        u32 width_pixels,
                                        u32 height_pixels,
                                        EccFillCandidate& candidate) {
    if (payload_bytes == 0u) {
        return false;
    }
    u64 dummy_payload_bits = 0u;
    if (!compute_frame_statistics(payload_bytes,
                                  redundancy,
                                  candidate.block_data,
                                  candidate.parity,
                                  candidate.block_count,
                                  dummy_payload_bits,
                                  candidate.frame_bits)) {
        return false;
    }
    if (candidate.block_data == 0u || candidate.parity == 0u) {
        return false;
    }
    FooterLayout layout = FooterLayout();
    PageFooterConfig footer_copy = footer_template;
    u32 layout_data_height = height_pixels;
    u64 bits_per_page = 0u;
    u64 page_count = 0u;
    if (!compute_page_layout(mapping,
                             footer_copy,
                             candidate.frame_bits,
                             width_pixels,
                             height_pixels,
                             layout,
                             layout_data_height,
                             bits_per_page,
                             page_count)) {
        return false;
    }
    if (page_count == 0u) {
        page_count = 1u;
    }
    candidate.ratio = (double)candidate.parity / (double)candidate.block_data;
    candidate.bits_per_page = bits_per_page;
    candidate.page_count = page_count;
    return true;
}

static bool find_best_ecc_fill(usize payload_bytes,
                               double min_ratio,
                               double max_ratio,
                               const ImageMappingConfig& mapping,
                               const PageFooterConfig& footer_config,
                               u32 width_pixels,
                               u32 height_pixels,
                               double& best_ratio,
                               u16& best_block_data,
                               u16& best_parity,
                               u64& best_frame_bits,
                               u64& best_bits_needed,
                               u64& best_page_count) {
    best_ratio = -1.0;
    best_block_data = 0u;
    best_parity = 0u;
    best_frame_bits = 0u;
    best_bits_needed = U64_MAX_VALUE;
    best_page_count = 0u;
    if (payload_bytes == 0u) {
        return false;
    }
    double search_low = min_ratio;
    double search_high = max_ratio;
    EccFillCandidate candidate;
    auto try_candidate = [&](double redundancy) -> bool {
        EccFillCandidate local;
        if (!evaluate_ecc_fill_candidate(payload_bytes,
                                          redundancy,
                                          mapping,
                                          footer_config,
                                          width_pixels,
                                          height_pixels,
                                          local)) {
            return false;
        }
        u64 bits_remaining = (local.bits_per_page > local.frame_bits) ? (local.bits_per_page - local.frame_bits) : 0u;
        if (best_ratio < 0.0 ||
            local.page_count < best_page_count ||
            (local.page_count == best_page_count && bits_remaining < best_bits_needed) ||
            (local.page_count == best_page_count && bits_remaining == best_bits_needed && local.ratio < best_ratio)) {
            best_ratio = local.ratio;
            best_block_data = local.block_data;
            best_parity = local.parity;
            best_frame_bits = local.frame_bits;
            best_bits_needed = bits_remaining;
            best_page_count = local.page_count;
        }
        candidate = local;
        return true;
    };
    if (!try_candidate(search_low)) {
        return false;
    }
    for (u32 iteration = 0u; iteration < 64u; ++iteration) {
        double mid = (search_low + search_high) * 0.5;
        if (mid == search_low || mid == search_high) {
            break;
        }
        if (!evaluate_ecc_fill_candidate(payload_bytes,
                                          mid,
                                          mapping,
                                          footer_config,
                                          width_pixels,
                                          height_pixels,
                                          candidate)) {
            search_high = mid;
            continue;
        }
        u64 bits_remaining = (candidate.bits_per_page > candidate.frame_bits) ? (candidate.bits_per_page - candidate.frame_bits) : 0u;
        if (best_ratio < 0.0 ||
            candidate.page_count < best_page_count ||
            (candidate.page_count == best_page_count && bits_remaining < best_bits_needed) ||
            (candidate.page_count == best_page_count && bits_remaining == best_bits_needed && candidate.ratio < best_ratio)) {
            best_ratio = candidate.ratio;
            best_block_data = candidate.block_data;
            best_parity = candidate.parity;
            best_frame_bits = candidate.frame_bits;
            best_bits_needed = bits_remaining;
            best_page_count = candidate.page_count;
        }
        if (candidate.page_count <= 1u) {
            search_low = mid;
        } else {
            search_high = mid;
        }
    }
    return (best_ratio >= 0.0);
}

static int command_encode(int arg_count, char** args) {
    if (arguments_request_help(arg_count, args)) {
        write_encode_help();
        return 0;
    }
    ImageMappingConfig mapping;
    PageFooterConfig footer_config;
    double ecc_redundancy = 0.2;
    static const usize MAX_INPUT_ITEMS = 512u;
    const char* input_paths[MAX_INPUT_ITEMS];
    usize input_count = 0u;
    makocode::ByteBuffer title_buffer;
    makocode::ByteBuffer filename_buffer;
    makocode::ByteBuffer password_buffer;
    makocode::ByteBuffer output_dir_buffer;
    makocode::ByteBuffer prefix_buffer;
    bool have_password = false;
    const char* output_dir = ".";
    bool have_output_dir = false;
    bool have_prefix = false;
    bool ecc_fill_requested = false;
    bool compact_page = false;
    for (int i = 0; i < arg_count; ++i) {
        bool handled = false;
        if (!process_image_mapping_option(arg_count, args, &i, mapping, "encode", &handled)) {
            return 1;
        }
        if (handled) {
            continue;
        }
        handled = false;
        if (!process_fiducial_option(arg_count, args, &i, g_fiducial_defaults, "encode", &handled)) {
            return 1;
        }
        if (handled) {
            continue;
        }
        const char* arg = args[i];
        if (!arg) {
            continue;
        }
        if (consume_debug_flag(arg)) {
            continue;
        }
        const char output_prefix[] = "--output-dir=";
        const char* output_value = 0;
        usize output_length = 0u;
        if (ascii_equals_token(arg, ascii_length(arg), "--output-dir")) {
            if (have_output_dir) {
                console_line(2, "encode: output directory specified multiple times");
                return 1;
            }
            if ((i + 1) >= arg_count) {
                console_line(2, "encode: --output-dir requires a non-empty path");
                return 1;
            }
            output_value = args[i + 1];
            if (!output_value) {
                console_line(2, "encode: --output-dir requires a non-empty path");
                return 1;
            }
            output_length = ascii_length(output_value);
            i += 1;
        } else if (ascii_starts_with(arg, output_prefix)) {
            if (have_output_dir) {
                console_line(2, "encode: output directory specified multiple times");
                return 1;
            }
            output_value = arg + (sizeof(output_prefix) - 1u);
            output_length = ascii_length(output_value);
        }
        if (output_value) {
            if (output_length == 0u) {
                console_line(2, "encode: --output-dir requires a non-empty path");
                return 1;
            }
            if (!output_dir_buffer.ensure(output_length + 1u)) {
                console_line(2, "encode: failed to allocate output directory buffer");
                return 1;
            }
            for (usize j = 0u; j < output_length; ++j) {
                output_dir_buffer.data[j] = (u8)output_value[j];
            }
            output_dir_buffer.data[output_length] = 0u;
            output_dir_buffer.size = output_length;
            output_dir = (const char*)output_dir_buffer.data;
            have_output_dir = true;
            continue;
        }
        const char prefix_prefix[] = "--prefix=";
        const char* prefix_value = 0;
        usize prefix_length = 0u;
        if (ascii_equals_token(arg, ascii_length(arg), "--prefix")) {
            if (have_prefix) {
                console_line(2, "encode: --prefix specified multiple times");
                return 1;
            }
            if ((i + 1) >= arg_count) {
                console_line(2, "encode: --prefix requires a non-empty value");
                return 1;
            }
            prefix_value = args[i + 1];
            if (!prefix_value) {
                console_line(2, "encode: --prefix requires a non-empty value");
                return 1;
            }
            prefix_length = ascii_length(prefix_value);
            i += 1;
        } else if (ascii_starts_with(arg, prefix_prefix)) {
            if (have_prefix) {
                console_line(2, "encode: --prefix specified multiple times");
                return 1;
            }
            prefix_value = arg + (sizeof(prefix_prefix) - 1u);
            prefix_length = ascii_length(prefix_value);
        }
        if (prefix_value) {
            if (prefix_length == 0u) {
                console_line(2, "encode: --prefix requires a non-empty value");
                return 1;
            }
            if (!prefix_buffer.ensure(prefix_length + 1u)) {
                console_line(2, "encode: failed to allocate prefix buffer");
                return 1;
            }
            for (usize j = 0u; j < prefix_length; ++j) {
                char c = prefix_value[j];
                if (c == '/' || c == '\\') {
                    console_line(2, "encode: --prefix must not contain '/' or '\\\\'");
                    return 1;
                }
                prefix_buffer.data[j] = (u8)c;
            }
            prefix_buffer.data[prefix_length] = 0u;
            prefix_buffer.size = prefix_length;
            have_prefix = true;
            continue;
        }
        if (ascii_equals_token(arg, ascii_length(arg), "--no-filename")) {
            footer_config.display_filename = false;
            continue;
        }
        if (ascii_equals_token(arg, ascii_length(arg), "--no-page-count")) {
            footer_config.display_page_info = false;
            continue;
        }
        if (ascii_equals_token(arg, ascii_length(arg), "--compact-page")) {
            compact_page = true;
            continue;
        }
        const char ecc_prefix[] = "--ecc=";
        const char* ecc_value = 0;
        usize ecc_length = 0u;
        if (ascii_equals_token(arg, ascii_length(arg), "--ecc")) {
            if ((i + 1) >= arg_count) {
                console_line(2, "encode: --ecc requires a numeric value");
                return 1;
            }
            ecc_value = args[i + 1];
            if (!ecc_value) {
                console_line(2, "encode: --ecc requires a numeric value");
                return 1;
            }
            ecc_length = ascii_length(ecc_value);
            i += 1;
        } else if (ascii_starts_with(arg, ecc_prefix)) {
            ecc_value = arg + (sizeof(ecc_prefix) - 1u);
            ecc_length = ascii_length(ecc_value);
        }
        if (ecc_value) {
            if (ecc_length == 0u) {
                console_line(2, "encode: --ecc requires a numeric value");
                return 1;
            }
            double redundancy_value = 0.0;
            if (!ascii_to_double(ecc_value, ecc_length, &redundancy_value)) {
                console_line(2, "encode: --ecc value is not a valid decimal number");
                return 1;
            }
            if (redundancy_value < 0.0) {
                console_line(2, "encode: --ecc must be >= 0.0");
                return 1;
            }
            ecc_redundancy = redundancy_value;
            continue;
        }
        if (ascii_equals_token(arg, ascii_length(arg), "--ecc-fill")) {
            ecc_fill_requested = true;
            continue;
        }
        const char input_prefix[] = "--input=";
        const char* input_value = 0;
        if (ascii_equals_token(arg, ascii_length(arg), "--input")) {
            if ((i + 1) >= arg_count) {
                console_line(2, "encode: --input requires a file path");
                return 1;
            }
            input_value = args[i + 1];
            if (!input_value || input_value[0] == '\0') {
                console_line(2, "encode: --input requires a file path");
                return 1;
            }
            i += 1;
        } else if (ascii_starts_with(arg, input_prefix)) {
            input_value = arg + (sizeof(input_prefix) - 1u);
        }
        if (input_value) {
            if (input_value[0] == '\0') {
                console_line(2, "encode: --input requires a file path");
                return 1;
            }
            if (input_count >= MAX_INPUT_ITEMS) {
                console_line(2, "encode: too many input paths specified");
                return 1;
            }
            input_paths[input_count++] = input_value;
            continue;
        }
        const char title_prefix[] = "--title=";
        const char* title_value = 0;
        usize title_length = 0u;
        if (ascii_equals_token(arg, ascii_length(arg), "--title")) {
            if ((i + 1) >= arg_count) {
                console_line(2, "encode: --title requires a non-empty value");
                return 1;
            }
            title_value = args[i + 1];
            if (!title_value) {
                console_line(2, "encode: --title requires a non-empty value");
                return 1;
            }
            title_length = ascii_length(title_value);
            i += 1;
        } else if (ascii_starts_with(arg, title_prefix)) {
            title_value = arg + (sizeof(title_prefix) - 1u);
            title_length = ascii_length(title_value);
        }
        if (title_value) {
            if (title_length == 0u) {
                console_line(2, "encode: --title requires a non-empty value");
                return 1;
            }
            if (!title_buffer.ensure(title_length + 1u)) {
                console_line(2, "encode: failed to allocate title buffer");
                return 1;
            }
            for (usize j = 0u; j < title_length; ++j) {
                char c = title_value[j];
                if (!title_char_is_allowed(c)) {
                    console_line(2, "encode: title supports letters, digits, space, and !@#$%^&*()_+-={}[]:\";'<>?,./`~|\\");
                    return 1;
                }
                title_buffer.data[j] = (u8)c;
            }
            title_buffer.data[title_length] = 0u;
            title_buffer.size = title_length;
            footer_config.has_title = true;
            footer_config.title_length = title_length;
            footer_config.title_text = (const char*)title_buffer.data;
            continue;
        }
        const char font_prefix[] = "--font-size=";
        const char* font_value = 0;
        usize font_length = 0u;
        if (ascii_equals_token(arg, ascii_length(arg), "--font-size")) {
            if ((i + 1) >= arg_count) {
                console_line(2, "encode: --font-size requires a positive integer value");
                return 1;
            }
            font_value = args[i + 1];
            if (!font_value) {
                console_line(2, "encode: --font-size requires a positive integer value");
                return 1;
            }
            font_length = ascii_length(font_value);
            i += 1;
        } else if (ascii_starts_with(arg, font_prefix)) {
            font_value = arg + (sizeof(font_prefix) - 1u);
            font_length = ascii_length(font_value);
        }
        if (font_value) {
            if (font_length == 0u) {
                console_line(2, "encode: --font-size requires a positive integer value");
                return 1;
            }
            u64 value = 0u;
            if (!ascii_to_u64(font_value, font_length, &value) || value == 0u || value > 2048u) {
                console_line(2, "encode: --font-size must be between 1 and 2048");
                return 1;
            }
            footer_config.font_size = (u32)value;
            continue;
        }
        const char password_prefix[] = "--password=";
        const char* password_value = 0;
        usize password_length = 0u;
        if (ascii_equals_token(arg, ascii_length(arg), "--password")) {
            if (have_password) {
                console_line(2, "encode: password specified multiple times");
                return 1;
            }
            if ((i + 1) >= arg_count) {
                console_line(2, "encode: --password requires a non-empty value");
                return 1;
            }
            password_value = args[i + 1];
            if (!password_value) {
                console_line(2, "encode: --password requires a non-empty value");
                return 1;
            }
            password_length = ascii_length(password_value);
            i += 1;
        } else if (ascii_starts_with(arg, password_prefix)) {
            if (have_password) {
                console_line(2, "encode: password specified multiple times");
                return 1;
            }
            password_value = arg + (sizeof(password_prefix) - 1u);
            password_length = ascii_length(password_value);
        }
        if (password_value) {
            if (password_length == 0u) {
                console_line(2, "encode: --password requires a non-empty value");
                return 1;
            }
            if (!password_buffer.ensure(password_length)) {
                console_line(2, "encode: failed to allocate password buffer");
                return 1;
            }
            for (usize j = 0u; j < password_length; ++j) {
                password_buffer.data[j] = (u8)password_value[j];
            }
            password_buffer.size = password_length;
            have_password = true;
            continue;
        }
        console_write(2, "encode: unknown option: ");
        console_line(2, arg);
        return 1;
    }
    if (mapping.palette_set) {
        if (!image_mapping_build_custom_palette(mapping, "encode")) {
            return 1;
        }
        // Downgrade custom palettes that exactly match built-in palettes so we
        // encode using the simpler fixed color modes (avoids palette-digit
        // packing for standard BW/CMYW/RGB pages).
        if (mapping.custom_palette_valid) {
            auto palette_matches = [&](const PaletteColor* builtin, u32 count) -> bool {
                if (!builtin || count == 0u || mapping.custom_palette_count != count) {
                    return false;
                }
                for (u32 i = 0u; i < count; ++i) {
                    const PaletteColor& a = mapping.custom_palette[i];
                    const PaletteColor& b = builtin[i];
                    if (a.r != b.r || a.g != b.g || a.b != b.b) {
                        return false;
                    }
                }
                return true;
            };
            if (palette_matches(PALETTE_GRAY, (u32)(sizeof(PALETTE_GRAY) / sizeof(PALETTE_GRAY[0])))) {
                mapping.color_channels = 1u;
                mapping.custom_palette_valid = false;
            } else if (palette_matches(PALETTE_CMYW, (u32)(sizeof(PALETTE_CMYW) / sizeof(PALETTE_CMYW[0])))) {
                mapping.color_channels = 2u;
                mapping.custom_palette_valid = false;
            } else if (palette_matches(PALETTE_RGB_CMY_WB, (u32)(sizeof(PALETTE_RGB_CMY_WB) / sizeof(PALETTE_RGB_CMY_WB[0])))) {
                mapping.color_channels = 3u;
                mapping.custom_palette_valid = false;
            }
        }
    }
    if (input_count == 0u) {
        console_line(2, "encode: at least one --input PATH is required");
        return 1;
    }
    ArchiveBuildContext archive;
    if (!archive_init(archive)) {
        console_line(2, "encode: failed to initialize archive buffer");
        return 1;
    }
    bool single_input = (input_count == 1u);
    makocode::ByteBuffer single_normalized;
    bool have_single_normalized = false;
    for (usize path_index = 0u; path_index < input_count; ++path_index) {
        const char* input_path = input_paths[path_index];
        struct stat path_info;
        if (stat(input_path, &path_info) != 0) {
            console_write(2, "encode: unable to stat ");
            console_line(2, input_path);
            return 1;
        }
        makocode::ByteBuffer normalized_path;
        if (!normalize_store_path(input_path, normalized_path)) {
            console_write(2, "encode: failed to normalize input path ");
            console_line(2, input_path);
            return 1;
        }
        const char* stored_rel = (const char*)normalized_path.data;
        if (!stored_rel || stored_rel[0] == '\0') {
            console_write(2, "encode: input path resolves to empty relative name ");
            console_line(2, input_path);
            return 1;
        }
        if (S_ISDIR(path_info.st_mode)) {
            if (!archive_collect_directory(input_path, stored_rel, archive)) {
                return 1;
            }
        } else if (S_ISREG(path_info.st_mode)) {
            makocode::ByteBuffer file_data;
            if (!read_entire_file(input_path, file_data)) {
                console_write(2, "encode: failed to read ");
                console_line(2, input_path);
                return 1;
            }
            if (!archive_add_file(archive, stored_rel, file_data.data, file_data.size)) {
                file_data.release();
                return 1;
            }
            file_data.release();
        } else {
            console_write(2, "encode: unsupported input type for ");
            console_line(2, input_path);
            return 1;
        }
        if (single_input && !have_single_normalized) {
            if (!single_normalized.ensure(normalized_path.size + 1u)) {
                console_line(2, "encode: failed to record normalized path");
                return 1;
            }
            for (usize j = 0u; j < normalized_path.size; ++j) {
                single_normalized.data[j] = normalized_path.data[j];
            }
            single_normalized.data[normalized_path.size] = 0u;
            single_normalized.size = normalized_path.size;
            have_single_normalized = true;
        }
    }
    if (archive.entry_count == 0u) {
        console_line(2, "encode: no files or directories to encode");
        return 1;
    }
    if (!archive_finalize(archive)) {
        console_line(2, "encode: failed to finalize archive payload");
        return 1;
    }
    footer_config.filename_text = 0;
    footer_config.filename_length = 0u;
    footer_config.has_filename = false;
    if (footer_config.display_filename) {
        if (single_input && have_single_normalized) {
            const char* base_name = find_last_path_component((const char*)single_normalized.data);
            usize base_length = ascii_length(base_name);
            if (base_length == 0u) {
                console_line(2, "encode: input path yielded empty filename");
                return 1;
            }
            if (!filename_buffer.ensure(base_length + 1u)) {
                console_line(2, "encode: failed to allocate filename buffer");
                return 1;
            }
            for (usize j = 0u; j < base_length; ++j) {
                char c = base_name[j];
                if (!title_char_is_allowed(c)) {
                    console_line(2, "encode: filename contains unsupported characters for footer text");
                    return 1;
                }
                filename_buffer.data[j] = (u8)c;
            }
            filename_buffer.data[base_length] = 0u;
            filename_buffer.size = base_length;
            footer_config.filename_text = (const char*)filename_buffer.data;
            footer_config.filename_length = base_length;
            footer_config.has_filename = true;
        } else {
            const char bundle_label[] = "bundle";
            usize label_length = (usize)(sizeof(bundle_label) - 1u);
            if (!filename_buffer.ensure(label_length + 1u)) {
                console_line(2, "encode: failed to allocate filename buffer");
                return 1;
            }
            for (usize j = 0u; j < label_length; ++j) {
                filename_buffer.data[j] = (u8)bundle_label[j];
            }
            filename_buffer.data[label_length] = 0u;
            filename_buffer.size = label_length;
            footer_config.filename_text = (const char*)filename_buffer.data;
            footer_config.filename_length = label_length;
            footer_config.has_filename = true;
        }
    }
    if (footer_config.has_title && (!footer_config.title_text || footer_config.title_length == 0u)) {
        console_line(2, "encode: title configuration is invalid");
        return 1;
    }
    u32 width_pixels = 0u;
    u32 height_pixels = 0u;
    if (!compute_page_dimensions(mapping, width_pixels, height_pixels)) {
        console_line(2, "encode: invalid page dimensions");
        return 1;
    }
    if (ecc_fill_requested) {
        makocode::ByteBuffer compressed_payload;
        if (!lzma_compress(archive.buffer.data, archive.buffer.size, compressed_payload)) {
            console_line(2, "encode: failed to compress payload for ECC fill calculation");
            return 1;
        }
        usize compressed_size = compressed_payload.size;
        compressed_payload.release();
        usize payload_bytes = compressed_size;
        if (have_password) {
            usize overhead = makocode::ENCRYPTION_HEADER_BYTES + makocode::ENCRYPTION_TAG_BYTES;
            if (payload_bytes > USIZE_MAX_VALUE - overhead) {
                console_line(2, "encode: payload size overflow while estimating ECC fill");
                return 1;
            }
            payload_bytes += overhead;
        }
        if (payload_bytes == 0u) {
            console_line(2, "encode: payload is empty, ECC fill calculation unnecessary");
            return 0;
        }
        u16 frame_block_data = 0u;
        u16 frame_parity = 0u;
        u64 frame_block_count = 0u;
        u64 frame_payload_bits = 0u;
        u64 frame_bits = 0u;
        if (!compute_frame_statistics(payload_bytes,
                                      ecc_redundancy,
                                      frame_block_data,
                                      frame_parity,
                                      frame_block_count,
                                      frame_payload_bits,
                                      frame_bits)) {
            console_line(2, "encode: could not compute frame size for ECC fill calculation");
            return 1;
        }
        double best_ratio = -1.0;
        u16 best_block_data = 0u;
        u16 best_parity = 0u;
        u64 best_frame_bits = 0u;
        u64 best_bits_needed = 0u;
        u64 best_page_count = 0u;
        if (!find_best_ecc_fill(payload_bytes,
                                ecc_redundancy,
                                (double)makocode::RS_FIELD_SIZE,
                                mapping,
                                footer_config,
                                width_pixels,
                                height_pixels,
                                best_ratio,
                                best_block_data,
                                best_parity,
                                best_frame_bits,
                                best_bits_needed,
                                best_page_count)) {
            console_line(2, "encode: failed to derive ECC fill candidate");
            return 1;
        }
        char ratio_buffer[32];
        format_fixed_3(best_ratio, ratio_buffer, sizeof(ratio_buffer));
        char block_buffer[32];
        u64_to_ascii(best_block_data, block_buffer, sizeof(block_buffer));
        char parity_buffer[32];
        u64_to_ascii(best_parity, parity_buffer, sizeof(parity_buffer));
        char bits_buffer[32];
        u64_to_ascii(best_bits_needed, bits_buffer, sizeof(bits_buffer));
        char page_buffer[32];
        u64_to_ascii(best_page_count, page_buffer, sizeof(page_buffer));
        console_write(1, "encode: --ecc-fill -> --ecc=");
        console_write(1, ratio_buffer);
        console_write(1, " (blocks=");
        console_write(1, block_buffer);
        console_write(1, " parity=");
        console_write(1, parity_buffer);
        console_write(1, " pages=");
        console_write(1, page_buffer);
        console_write(1, " bits_needed=");
        console_write(1, bits_buffer);
        console_line(1, ")");
        ecc_redundancy = best_ratio;
    }
    makocode::EncoderContext encoder;
    encoder.config.ecc_redundancy = ecc_redundancy;
    if (have_password) {
        if (!encoder.set_password((const char*)password_buffer.data, password_buffer.size)) {
            console_line(2, "encode: failed to set encryption password");
            return 1;
        }
    }
    if (!encoder.set_payload(archive.buffer.data, archive.buffer.size)) {
        console_line(2, "encode: failed to set payload");
        return 1;
    }
    if (!encoder.build()) {
        console_line(2, "encode: build failed");
        return 1;
    }
    makocode::ByteBuffer frame_bits;
    u64 frame_bit_count = 0u;
    u64 payload_bit_count = 0u;
    if (!build_frame_bits(encoder, mapping, frame_bits, frame_bit_count, payload_bit_count)) {
        console_line(2, "encode: failed to build frame");
        return 1;
    }
    FooterLayout footer_layout;
    u32 layout_data_height = height_pixels;
    u64 bits_per_page = 0u;
    u64 page_count = 0u;
    if (!compute_page_layout(mapping,
                             footer_config,
                             frame_bit_count,
                             width_pixels,
                             height_pixels,
                             footer_layout,
                             layout_data_height,
                             bits_per_page,
                             page_count)) {
        console_line(2, "encode: footer layout did not converge");
        return 1;
    }
    char timestamp_name[32];
    const char* page_name_prefix = 0;
    if (have_prefix) {
        page_name_prefix = (const char*)prefix_buffer.data;
    } else {
        if (!utc_timestamp_string(timestamp_name, sizeof(timestamp_name))) {
            console_line(2, "encode: failed to construct timestamped filename");
            return 1;
        }
        page_name_prefix = timestamp_name;
    }
    makocode::ByteBuffer footer_text_buffer;
    const makocode::EccSummary* ecc_summary = &encoder.ecc_info();
    if (page_count == 1u) {
        u32 output_height_pixels = height_pixels;
        FooterLayout output_footer_layout = footer_layout;
        u32 output_data_height_pixels = layout_data_height;
        u64 output_bits_per_page = bits_per_page;

        if (compact_page && footer_layout.has_text) {
            console_line(2, "encode: --compact-page requires the footer text to be disabled (use --no-filename and --no-page-count, and omit --title)");
            return 1;
        }

        // For single-page outputs with no footer text, allow the footer band to
        // collapse to the minimum height needed for payload data.
        if (compact_page && !footer_layout.has_text && layout_data_height > 0u) {
            double bits_per_pixel = mapping_bits_per_data_pixel(mapping);
            if (bits_per_pixel > 0.0) {
                u32 max_data_height = layout_data_height;
                u32 stripe_height = footer_layout.stripe_height_pixels;
                u32 stripe_limited = (height_pixels > stripe_height) ? (height_pixels - stripe_height) : 0u;
                if (stripe_limited > 0u && stripe_limited < max_data_height) {
                    max_data_height = stripe_limited;
                }
                if (max_data_height > 0u) {
                    u32 low = 1u;
                    u32 high = max_data_height;
                    u32 best = max_data_height;
                    u64 best_bits = 0u;
                    while (low <= high) {
                        u32 mid = low + (high - low) / 2u;
                        u64 candidate_bits = 0u;
                        if (compute_bits_per_page(width_pixels,
                                                  height_pixels,
                                                  mid,
                                                  bits_per_pixel,
                                                  candidate_bits,
                                                  0) &&
                            candidate_bits >= frame_bit_count) {
                            best = mid;
                            best_bits = candidate_bits;
                            if (mid == 1u) {
                                break;
                            }
                            high = mid - 1u;
                        } else {
                            low = mid + 1u;
                        }
                    }
                    // Only apply if it meaningfully reduces the unused band.
                    if (best_bits > 0u && best + 4u < layout_data_height) {
                        u32 minimal_height = best + stripe_height;
                        if (minimal_height >= best && minimal_height <= height_pixels) {
                            output_height_pixels = minimal_height;
                        }
                        output_footer_layout.data_height_pixels = best;
                        output_footer_layout.stripe_top_row = best;
                        output_footer_layout.footer_height_pixels = stripe_height;
                        output_data_height_pixels = best;
                        // Bits-per-page depends on data_height; keep it consistent with
                        // the chosen data height even when we shrink the output image.
                        output_bits_per_page = best_bits;
                    }
                }
            }
        }
        makocode::ByteBuffer page_output;
        if (!footer_build_page_text(footer_config, 1u, page_count, footer_text_buffer)) {
            console_line(2, "encode: failed to build footer text");
            return 1;
        }
        const char* footer_text = output_footer_layout.has_text ? (const char*)footer_text_buffer.data : 0;
        usize footer_length = output_footer_layout.has_text ? footer_text_buffer.size : 0u;
        if (!encode_page_to_ppm(mapping,
                                frame_bits,
                                frame_bit_count,
                                0u,
                                width_pixels,
                                output_height_pixels,
                                1u,
                                1u,
                                output_bits_per_page,
                                payload_bit_count,
                                ecc_summary,
                                footer_text,
                                footer_length,
                                output_footer_layout,
                                page_output)) {
           console_line(2, "encode: failed to format ppm");
           return 1;
       }
        makocode::ByteBuffer fiducial_page;
        // Clip fiducials to the data area so they don't land on the footer stripe.
        if (!apply_default_fiducial_grid(page_output, fiducial_page, output_data_height_pixels)) {
            console_line(2, "encode: failed to embed fiducial grid");
            return 1;
        }
        byte_buffer_move(page_output, fiducial_page);
        makocode::ByteBuffer output_name;
        makocode::ByteBuffer output_path;
        if (!build_page_filename(output_name, page_name_prefix, 1u, 1u)) {
            console_line(2, "encode: failed to build output filename");
            return 1;
        }
        if (!join_output_path(output_dir, (const char*)output_name.data, output_path)) {
            console_line(2, "encode: failed to prepare output path");
            return 1;
        }
        if (!ensure_parent_directories((const char*)output_path.data)) {
            console_line(2, "encode: failed to prepare output directories");
            return 1;
        }
        if (!write_buffer_to_file((const char*)output_path.data, page_output)) {
            console_line(2, "encode: failed to write ppm file");
            return 1;
        }
        console_write(1, "encode: wrote 1 page (");
        console_write(1, (const char*)output_path.data);
        console_line(1, ")");
    } else {
        makocode::ByteBuffer name_buffer;
        makocode::ByteBuffer path_buffer;
        for (u64 page = 0u; page < page_count; ++page) {
            makocode::ByteBuffer page_output;
            u64 bit_offset = page * bits_per_page;
            if (!footer_build_page_text(footer_config, page + 1u, page_count, footer_text_buffer)) {
                console_line(2, "encode: failed to build footer text");
                return 1;
            }
            const char* footer_text = footer_layout.has_text ? (const char*)footer_text_buffer.data : 0;
            usize footer_length = footer_layout.has_text ? footer_text_buffer.size : 0u;
            if (!encode_page_to_ppm(mapping,
                                    frame_bits,
                                    frame_bit_count,
                                    bit_offset,
                                    width_pixels,
                                    height_pixels,
                                    page + 1u,
                                    page_count,
                                    bits_per_page,
                                    payload_bit_count,
                                    ecc_summary,
                                    footer_text,
                                    footer_length,
                                    footer_layout,
                                    page_output)) {
                console_line(2, "encode: failed to format ppm page");
                return 1;
            }
            makocode::ByteBuffer fiducial_page;
            // Clip fiducials to the data area so they don't land on the footer stripe.
            if (!apply_default_fiducial_grid(page_output, fiducial_page, footer_layout.data_height_pixels)) {
                console_line(2, "encode: failed to embed fiducial grid");
                return 1;
            }
            byte_buffer_move(page_output, fiducial_page);
            if (!build_page_filename(name_buffer, page_name_prefix, page + 1u, page_count)) {
                console_line(2, "encode: failed to build filename");
                return 1;
            }
            if (!join_output_path(output_dir, (const char*)name_buffer.data, path_buffer)) {
                console_line(2, "encode: failed to prepare output path");
                return 1;
            }
            if (!ensure_parent_directories((const char*)path_buffer.data)) {
                console_line(2, "encode: failed to prepare output directories");
                return 1;
            }
            if (!write_buffer_to_file((const char*)path_buffer.data, page_output)) {
                console_line(2, "encode: failed to write ppm file");
                return 1;
            }
        }
        makocode::ByteBuffer sample_name;
        if (!build_page_filename(sample_name, page_name_prefix, 1u, page_count)) {
            console_line(2, "encode: failed to summarize filenames");
            return 1;
        }
        makocode::ByteBuffer sample_path;
        const char* summary_name = (const char*)sample_name.data;
        if (join_output_path(output_dir, summary_name, sample_path)) {
            summary_name = (const char*)sample_path.data;
        }
        char digits[32];
        u64_to_ascii(page_count, digits, sizeof(digits));
        console_write(1, "encode: wrote ");
        console_write(1, digits);
        console_write(1, " pages (");
        console_write(1, summary_name);
        console_line(1, " ...)");
    }
    return 0;
}

struct OverlayPage {
    makocode::ByteBuffer original;
    makocode::ByteBuffer pixels;
    PpmParserState      metadata;
    u32                 width;
    u32                 height;
    u32                 data_height;
    u32                 footer_rows;
    u8                  color_mode;

    OverlayPage()
        : original(),
          pixels(),
          metadata(),
          width(0u),
          height(0u),
          data_height(0u),
          footer_rows(0u),
          color_mode(1u) {}

    ~OverlayPage() {
        original.release();
        pixels.release();
        metadata = PpmParserState();
        width = 0u;
        height = 0u;
        data_height = 0u;
        footer_rows = 0u;
        color_mode = 1u;
    }
};

static const usize MAX_OVERLAY_IGNORE_COLORS = 64u;

struct OverlayIgnoreColorList {
    PaletteColor colors[MAX_OVERLAY_IGNORE_COLORS];
    usize count;
};

// The overlay PPM that carries the mask rarely encodes layout metadata such as
// footer rows or fiducial sizing. When that metadata is absent we still need the
// overlay to line up pixel-for-pixel with the base page so that the merged image
// doesn't appear shifted. Synchronize the layout-critical fields from the base
// page onto the overlay before we build masks or gather bits.
static void overlay_apply_base_layout(const OverlayPage& base, OverlayPage& overlay) {
    overlay.footer_rows = base.footer_rows;
    if (overlay.footer_rows > overlay.height) {
        overlay.footer_rows = overlay.height;
    }
    overlay.data_height = (overlay.height >= overlay.footer_rows)
                              ? (overlay.height - overlay.footer_rows)
                              : overlay.height;
    if (base.metadata.has_footer_rows) {
        overlay.metadata.has_footer_rows = true;
        overlay.metadata.footer_rows_value = base.metadata.footer_rows_value;
    }
    if (base.metadata.has_fiducial_size) {
        overlay.metadata.has_fiducial_size = true;
        overlay.metadata.fiducial_size_value = base.metadata.fiducial_size_value;
    }
    if (base.metadata.has_fiducial_margin) {
        overlay.metadata.has_fiducial_margin = true;
        overlay.metadata.fiducial_margin_value = base.metadata.fiducial_margin_value;
    }
    if (base.metadata.has_fiducial_columns) {
        overlay.metadata.has_fiducial_columns = true;
        overlay.metadata.fiducial_columns_value = base.metadata.fiducial_columns_value;
    }
    if (base.metadata.has_fiducial_rows) {
        overlay.metadata.has_fiducial_rows = true;
        overlay.metadata.fiducial_rows_value = base.metadata.fiducial_rows_value;
    }
}

static bool overlay_ignore_char_is_delimiter(char c) {
    switch (c) {
        case ' ':
        case '\t':
        case '\n':
        case '\r':
        case ',':
        case ';':
            return true;
        default:
            return false;
    }
}

static bool overlay_color_matches_ignore(const OverlayIgnoreColorList& list,
                                        u8 r,
                                        u8 g,
                                        u8 b) {
    for (usize i = 0u; i < list.count; ++i) {
        const PaletteColor& candidate = list.colors[i];
        if (candidate.r == r && candidate.g == g && candidate.b == b) {
            return true;
        }
    }
    return false;
}

static bool parse_overlay_ignore_colors(const char* text,
                                        usize length,
                                        OverlayIgnoreColorList& list) {
    list.count = 0u;
    if (!text || length == 0u) {
        return true;
    }
    usize cursor = 0u;
    while (cursor < length) {
        while (cursor < length && overlay_ignore_char_is_delimiter(text[cursor])) {
            ++cursor;
        }
        if (cursor >= length) {
            break;
        }
        usize start = cursor;
        while (cursor < length && !overlay_ignore_char_is_delimiter(text[cursor])) {
            ++cursor;
        }
        usize token_length = cursor - start;
        if (token_length == 0u) {
            continue;
        }
        if (list.count >= MAX_OVERLAY_IGNORE_COLORS) {
            console_line(2, "overlay: --ignore-colors supports at most 64 entries");
            return false;
        }
        PaletteColor color;
        u8 color_id = NAMED_COLOR_INVALID;
        if (!decode_named_palette_color(text + start, token_length, color_id, color)) {
            console_line(2, "overlay: --ignore-colors contains an invalid color");
            return false;
        }
        bool duplicate = false;
        for (usize i = 0u; i < list.count; ++i) {
            if (palette_colors_equal(list.colors[i], color)) {
                duplicate = true;
                break;
            }
        }
        if (duplicate) {
            continue;
        }
        list.colors[list.count++] = color;
    }
    return true;
}

static bool load_overlay_page(const char* path, OverlayPage& page) {
    page.original.release();
    page.pixels.release();
    page.metadata = PpmParserState();
    page.width = 0u;
    page.height = 0u;
    page.data_height = 0u;
    page.footer_rows = 0u;
    page.color_mode = 1u;
    if (!path) {
        console_line(2, "overlay: missing file path");
        return false;
    }
    if (!read_entire_file(path, page.original)) {
        console_write(2, "overlay: failed to read ");
        console_line(2, path);
        return false;
    }
    if (!page.original.data || page.original.size == 0u) {
        console_write(2, "overlay: empty file ");
        console_line(2, path);
        return false;
    }
    PpmParserState state;
    state.data = page.original.data;
    state.size = page.original.size;
    const char* token = 0;
    usize token_length = 0u;
    if (!ppm_next_token(state, &token, &token_length) ||
        !ascii_equals_token(token, token_length, "P3")) {
        console_write(2, "overlay: ");
        console_write(2, path);
        console_line(2, " is not a P3 ASCII PPM");
        return false;
    }
    u64 width_value = 0u;
    if (!ppm_next_token(state, &token, &token_length) ||
        !ascii_to_u64(token, token_length, &width_value) ||
        width_value == 0u ||
        width_value > 0xFFFFFFFFull) {
        console_write(2, "overlay: invalid width in ");
        console_line(2, path);
        return false;
    }
    u64 height_value = 0u;
    if (!ppm_next_token(state, &token, &token_length) ||
        !ascii_to_u64(token, token_length, &height_value) ||
        height_value == 0u ||
        height_value > 0xFFFFFFFFull) {
        console_write(2, "overlay: invalid height in ");
        console_line(2, path);
        return false;
    }
    u64 max_value = 0u;
    if (!ppm_next_token(state, &token, &token_length) ||
        !ascii_to_u64(token, token_length, &max_value) ||
        max_value != 255u) {
        console_write(2, "overlay: unsupported max pixel value in ");
        console_line(2, path);
        return false;
    }
    if (width_value == 0u || height_value == 0u) {
        console_write(2, "overlay: zero dimension in ");
        console_line(2, path);
        return false;
    }
    if (width_value > (u64)USIZE_MAX_VALUE || height_value > (u64)USIZE_MAX_VALUE) {
        console_write(2, "overlay: dimensions overflow in ");
        console_line(2, path);
        return false;
    }
    u64 pixel_count = width_value * height_value;
    if (pixel_count == 0u || pixel_count > ((u64)USIZE_MAX_VALUE / 3u)) {
        console_write(2, "overlay: pixel count overflow in ");
        console_line(2, path);
        return false;
    }
    makocode::ByteBuffer pixel_data;
    if (!ppm_read_rgb_pixels(state, pixel_count, pixel_data)) {
        console_write(2, "overlay: failed to parse pixel data from ");
        console_line(2, path);
        return false;
    }
    page.metadata = state;
    page.metadata.data = 0;
    page.metadata.size = 0u;
    page.metadata.cursor = 0u;

    // Prefer metadata tile (v3) for layout/ecc details now that footer stripes may be absent.
    MetadataTile::Values tile_values = {};
    makocode::ByteBuffer tile_palette_text;
    MetadataTile::Placement placement = MetadataTile::compute_tile_placement((u32)width_value, (u32)height_value);
    if (placement.valid) {
        if (MetadataTile::decode_tile(pixel_data.data,
                                      (u32)width_value,
                                      (u32)height_value,
                                      (u32)height_value,
                                      placement,
                                      tile_values,
                                      tile_palette_text)) {
            apply_metadata_tile_metadata(page.metadata, tile_values, tile_palette_text);
        }
    }

    FooterStripe::Values stripe_values = {};
    bool stripe_available = false;
    if (kFooterStripeEnabled && width_value <= 0xFFFFFFFFull && height_value <= 0xFFFFFFFFull) {
        stripe_available = FooterStripe::decode_v3(pixel_data.data,
                                                   (u32)width_value,
                                                   (u32)height_value,
                                                   stripe_values);
        if (!stripe_available) {
            stripe_available = FooterStripe::decode(FooterStripe::SPEC_V2,
                                                    pixel_data.data,
                                                    (u32)width_value,
                                                    (u32)height_value,
                                                    stripe_values);
        }
        if (!stripe_available) {
            stripe_available = FooterStripe::decode(FooterStripe::SPEC_V1,
                                                    pixel_data.data,
                                                    (u32)width_value,
                                                    (u32)height_value,
                                                    stripe_values);
        }
    }
    if (stripe_available) {
        page.metadata.has_footer_stripe = true;
        page.metadata.footer_stripe_values = stripe_values;
        apply_footer_stripe_metadata(page.metadata, stripe_values);
    }

    byte_buffer_move(page.pixels, pixel_data);
    page.width = (u32)width_value;
    page.height = (u32)height_value;

    u32 footer_rows = 0u;
    if (page.metadata.has_footer_rows) {
        if (page.metadata.footer_rows_value > height_value) {
            console_write(2, "overlay: footer metadata exceeds image height in ");
            console_line(2, path);
            return false;
        }
        footer_rows = (u32)page.metadata.footer_rows_value;
    }
    if (footer_rows > page.height) {
        footer_rows = page.height;
    }
    page.footer_rows = footer_rows;
    page.data_height = page.height - footer_rows;
    if (page.data_height > page.height) {
        page.data_height = page.height;
    }
    page.color_mode = 1u;
    if (page.metadata.has_palette_base) {
        const u64 palette_base = page.metadata.palette_base_value;
        if (palette_base >= 8u) {
            page.color_mode = 3u;
        } else if (palette_base >= 4u) {
            page.color_mode = 2u;
        } else {
            page.color_mode = 1u;
        }
    } else if (page.pixels.data && page.pixels.size >= (usize)page.width * (usize)page.height * 3u) {
        // When palette metadata is unavailable (e.g., synthetic overlay masks),
        // infer whether the image uses chroma at all. Overlay behavior only
        // needs a coarse "grayscale vs. color" distinction to decide between
    // raw-pixel overlay and data-bit overlay. Avoid depending on container metadata
        // comments, which are not preserved across print/scan workflows.
        usize total_pixels = (usize)page.width * (usize)page.height;
        bool has_color = false;
        for (usize i = 0u; i < total_pixels; ++i) {
            const u8* rgb = page.pixels.data + i * 3u;
            if (rgb[0] != rgb[1] || rgb[1] != rgb[2]) {
                has_color = true;
                break;
            }
        }
        if (has_color) {
            page.color_mode = 2u;
        }
    }
    return true;
}

static bool build_overlay_mask(const OverlayPage& page,
                               makocode::ByteBuffer& mask_out,
                               u64& reserved_pixels) {
    reserved_pixels = 0u;
    mask_out.release();
    if (page.width == 0u || page.height == 0u) {
        return false;
    }
    u64 total_pixels = (u64)page.width * (u64)page.height;
    if (!mask_out.ensure((usize)total_pixels)) {
        return false;
    }
    mask_out.size = (usize)total_pixels;
    for (usize i = 0u; i < mask_out.size; ++i) {
        mask_out.data[i] = 0u;
    }
    if (page.data_height == 0u) {
        return true;
    }
    u32 marker_size = g_fiducial_defaults.marker_size_pixels;
    if (page.metadata.has_fiducial_size && page.metadata.fiducial_size_value > 0u && page.metadata.fiducial_size_value <= 0xFFFFFFFFull) {
        marker_size = (u32)page.metadata.fiducial_size_value;
    }
    if (marker_size == 0u) {
        return true;
    }
    u32 draw_height = page.height;
    if (page.data_height > 0u && page.data_height < page.height) {
        draw_height = page.data_height;
    }
    u32 margin = g_fiducial_defaults.margin_pixels;
    if (page.metadata.has_fiducial_margin && page.metadata.fiducial_margin_value <= 0xFFFFFFFFull) {
        margin = (u32)page.metadata.fiducial_margin_value;
    }
    double min_x = (margin < page.width) ? (double)margin : 0.0;
    double max_x = (page.width > margin)
                       ? (double)(page.width - 1u - margin)
                       : (page.width ? (double)(page.width - 1u) : 0.0);
    if (max_x < min_x) {
        max_x = min_x;
    }
    double min_y = (margin < draw_height) ? (double)margin : 0.0;
    double max_y = (draw_height > margin)
                       ? (double)(draw_height - 1u - margin)
                       : (draw_height ? (double)(draw_height - 1u) : 0.0);
    if (max_y < min_y) {
        max_y = min_y;
    }
    double available_width = (max_x >= min_x) ? (max_x - min_x) : 0.0;
    double available_height = (max_y >= min_y) ? (max_y - min_y) : 0.0;
    u32 columns = (page.metadata.has_fiducial_columns && page.metadata.fiducial_columns_value > 0u)
                      ? (u32)page.metadata.fiducial_columns_value
                      : 0u;
    u32 rows = (page.metadata.has_fiducial_rows && page.metadata.fiducial_rows_value > 0u)
                   ? (u32)page.metadata.fiducial_rows_value
                   : 0u;
    if (columns == 0u || rows == 0u) {
        u32 spacing = g_fiducial_defaults.spacing_pixels;
        if (spacing == 0u) {
            spacing = marker_size ? marker_size : 1u;
        }
        if (columns == 0u) {
            columns = 1u;
            if (spacing > 0u && available_width > 0.0) {
                double span = available_width / (double)spacing;
                if (span < 0.0) {
                    span = 0.0;
                }
                u64 additional = (u64)span;
                if (additional > 0xFFFFFFFFull - 1ull) {
                    additional = 0xFFFFFFFFull - 1ull;
                }
                columns = (u32)(additional + 1ull);
            }
        }
        if (rows == 0u) {
            rows = 1u;
            if (spacing > 0u && available_height > 0.0) {
                double span = available_height / (double)spacing;
                if (span < 0.0) {
                    span = 0.0;
                }
                u64 additional = (u64)span;
                if (additional > 0xFFFFFFFFull - 1ull) {
                    additional = 0xFFFFFFFFull - 1ull;
                }
                rows = (u32)(additional + 1ull);
            }
        }
        if (columns == 0u) {
            columns = 1u;
        }
        if (rows == 0u) {
            rows = 1u;
        }
    }
    for (u32 grid_row = 0u; grid_row < rows; ++grid_row) {
        double t_y = (rows == 1u) ? 0.5 : ((double)grid_row / (double)(rows - 1u));
        double center_y = min_y + (max_y - min_y) * t_y;
        int start_y = (int)(center_y - ((double)marker_size - 1.0) * 0.5);
        for (u32 grid_col = 0u; grid_col < columns; ++grid_col) {
            double t_x = (columns == 1u) ? 0.5 : ((double)grid_col / (double)(columns - 1u));
            double center_x = min_x + (max_x - min_x) * t_x;
            int start_x = (int)(center_x - ((double)marker_size - 1.0) * 0.5);
            for (u32 dy = 0u; dy < marker_size; ++dy) {
                int pixel_y = start_y + (int)dy;
                if (pixel_y < 0 || pixel_y >= (int)draw_height) {
                    continue;
                }
                bool within_data = ((u32)pixel_y < page.data_height);
                for (u32 dx = 0u; dx < marker_size; ++dx) {
                    int pixel_x = start_x + (int)dx;
                    if (pixel_x < 0 || pixel_x >= (int)page.width) {
                        continue;
                    }
                    usize index = ((usize)pixel_y * (usize)page.width) + (usize)pixel_x;
                    if (mask_out.data[index]) {
                        continue;
                    }
                    mask_out.data[index] = 1u;
                    if (within_data) {
                        ++reserved_pixels;
                    }
                }
            }
        }
    }

    // Protect the metadata tile region from overlays so pixel-carried metadata survives.
    const char* disable_tile_env = getenv("MAKO_DISABLE_METADATA_TILE");
    if (!(disable_tile_env && disable_tile_env[0]) &&
        page.data_height >= MetadataTile::TILE_SIDE && page.width >= MetadataTile::TILE_SIDE) {
        MetadataTile::Placement placement = MetadataTile::compute_tile_placement(page.width, page.data_height);
        if (placement.valid) {
            for (u32 dy = 0u; dy < MetadataTile::TILE_SIDE; ++dy) {
                u32 y = placement.y0 + dy;
                if (y >= page.data_height) continue;
                for (u32 dx = 0u; dx < MetadataTile::TILE_SIDE; ++dx) {
                    u32 x = placement.x0 + dx;
                    if (x >= page.width) continue;
                    usize index = (usize)y * (usize)page.width + (usize)x;
                    if (mask_out.data[index]) {
                        continue;
                    }
                    mask_out.data[index] = 1u;
                    ++reserved_pixels;
                }
            }
        }
    }
    return true;
}

static bool gather_overlay_bits(const OverlayPage& page,
                                const makocode::ByteBuffer& mask,
                                makocode::ByteBuffer& bits_out,
                                u64& bit_count) {
    bit_count = 0u;
    bits_out.release();
    if (!page.pixels.data || page.pixels.size == 0u) {
        return false;
    }
    if (page.width == 0u || page.height == 0u) {
        return false;
    }
    if (mask.size && mask.size != (usize)page.width * (usize)page.height) {
        return false;
    }
    u8 sample_bits = bits_per_sample(page.color_mode);
    u8 samples_per_pixel = color_mode_samples_per_pixel(page.color_mode);
    if (sample_bits == 0u || samples_per_pixel == 0u) {
        return false;
    }
    makocode::BitWriter writer;
    for (u32 row = 0u; row < page.data_height; ++row) {
        for (u32 column = 0u; column < page.width; ++column) {
            bool reserved = false;
            if (mask.data && mask.size) {
                usize index = ((usize)row * (usize)page.width) + (usize)column;
                reserved = (mask.data[index] != 0u);
            }
            if (reserved) {
                continue;
            }
            usize pixel_index = (((usize)row * (usize)page.width) + (usize)column) * 3u;
            if ((pixel_index + 2u) >= page.pixels.size) {
                return false;
            }
            u32 samples[3] = {0u, 0u, 0u};
            if (!map_rgb_to_samples(page.color_mode, page.pixels.data + pixel_index, samples)) {
                return false;
            }
            for (u8 sample_idx = 0u; sample_idx < samples_per_pixel; ++sample_idx) {
                if (!writer.write_bits(samples[sample_idx], sample_bits)) {
                    return false;
                }
            }
        }
    }
    if (!writer.align_to_byte()) {
        return false;
    }
    if (page.color_mode == 3u) {
        usize total_bytes = writer.byte_size();
        if (total_bytes && writer.buffer.data) {
            for (usize i = 0u; i < total_bytes; ++i) {
                u8 rotate = (u8)((i % 3u) + 1u);
                writer.buffer.data[i] = rotate_right_u8(writer.buffer.data[i], rotate);
            }
        }
    }
    bit_count = writer.bit_size();
    byte_buffer_move(bits_out, writer.buffer);
    return true;
}

static bool apply_overlay_bits(const makocode::ByteBuffer& bits,
                               u64 bit_count,
                               const makocode::ByteBuffer& mask,
                               OverlayPage& page,
                               const OverlayPage* overlay_page,
                               const OverlayIgnoreColorList* ignore_list) {
    if (!page.pixels.data || page.pixels.size == 0u) {
        return false;
    }
    if (page.width == 0u || page.height == 0u) {
        return false;
    }
    if (mask.size && mask.size != (usize)page.width * (usize)page.height) {
        return false;
    }
    u8 sample_bits = bits_per_sample(page.color_mode);
    u8 samples_per_pixel = color_mode_samples_per_pixel(page.color_mode);
    if (sample_bits == 0u || samples_per_pixel == 0u) {
        return false;
    }
    const u8* bit_data = bits.data;
    usize bit_data_size = bits.size;
    makocode::ByteBuffer rotated;
    if (page.color_mode == 3u && bits.size) {
        if (!rotated.ensure(bits.size)) {
            return false;
        }
        rotated.size = bits.size;
        for (usize i = 0u; i < bits.size; ++i) {
            u8 rotate = (u8)((i % 3u) + 1u);
            rotated.data[i] = rotate_left_u8(bits.data[i], rotate);
        }
        bit_data = rotated.data;
        bit_data_size = rotated.size;
    }
    const bool filter_overlay_colors = (ignore_list && overlay_page && overlay_page->pixels.data);
    if (filter_overlay_colors) {
        if (overlay_page->width != page.width || overlay_page->height != page.height) {
            return false;
        }
    }
    u64 cursor = 0u;
    for (u32 row = 0u; row < page.data_height; ++row) {
        for (u32 column = 0u; column < page.width; ++column) {
            bool reserved = false;
            if (mask.data && mask.size) {
                usize index = ((usize)row * (usize)page.width) + (usize)column;
                reserved = (mask.data[index] != 0u);
            }
            if (reserved) {
                continue;
            }

            bool skip_overlay_pixel = false;
            if (filter_overlay_colors) {
                usize overlay_index = (((usize)row * (usize)overlay_page->width) + (usize)column) * 3u;
                if ((overlay_index + 2u) >= overlay_page->pixels.size) {
                    return false;
                }
                u8 overlay_r = overlay_page->pixels.data[overlay_index + 0u];
                u8 overlay_g = overlay_page->pixels.data[overlay_index + 1u];
                u8 overlay_b = overlay_page->pixels.data[overlay_index + 2u];
                if (overlay_color_matches_ignore(*ignore_list, overlay_r, overlay_g, overlay_b)) {
                    skip_overlay_pixel = true;
                }
            }
            u32 samples[3] = {0u, 0u, 0u};
            for (u8 sample_idx = 0u; sample_idx < samples_per_pixel; ++sample_idx) {
                u32 value = 0u;
                for (u8 bit = 0u; bit < sample_bits; ++bit) {
                    u8 bit_value = 0u;
                    if (cursor < bit_count && bit_data) {
                        usize byte_index = (usize)(cursor >> 3u);
                        if (byte_index < bit_data_size) {
                            u8 mask_bit = (u8)(1u << (cursor & 7u));
                            bit_value = (bit_data[byte_index] & mask_bit) ? 1u : 0u;
                        }
                    }
                    value |= ((u32)bit_value) << bit;
                    ++cursor;
                }
                samples[sample_idx] = value;
            }
            u8 rgb[3];
            if (!map_samples_to_rgb(page.color_mode, samples, rgb)) {
                return false;
            }
            usize pixel_index = (((usize)row * (usize)page.width) + (usize)column) * 3u;
            if ((pixel_index + 2u) >= page.pixels.size) {
                return false;
            }
            if (skip_overlay_pixel) {
                continue;
            }
            page.pixels.data[pixel_index + 0u] = rgb[0];
            page.pixels.data[pixel_index + 1u] = rgb[1];
            page.pixels.data[pixel_index + 2u] = rgb[2];
        }
    }
    return true;
}

struct RawOverlayBlockTracker {
    bool enabled;
    bool limits_known;
    bool hit_limit;
    bool log_enabled;
    u64 parity_symbols;
    u64 block_total_symbols;
    u64 block_count;
    u64 block_limit_per_block;
    u64 rs_region_start;
    u64 rs_region_end;
    u64 encoded_block_bytes;
    u64 total_symbol_changes;
    u64 max_block_errors;
    u64 max_block_index;
    u64 first_limit_block;
    u64 first_limit_errors;
    u64 rejected_changes;
    makocode::ByteBuffer counts;
    makocode::ByteBuffer shuffle_map;
    makocode::ByteBuffer symbol_marks;
    makocode::ByteBuffer pending_symbols;
    makocode::ByteBuffer pending_blocks;

    RawOverlayBlockTracker()
        : enabled(false),
          limits_known(false),
          hit_limit(false),
          log_enabled(false),
          parity_symbols(0u),
          block_total_symbols(0u),
          block_count(0u),
          block_limit_per_block(0u),
          rs_region_start(0u),
          rs_region_end(0u),
          encoded_block_bytes(0u),
          total_symbol_changes(0u),
          max_block_errors(0u),
          max_block_index(0u),
          first_limit_block(0u),
          first_limit_errors(0u),
          rejected_changes(0u),
          counts(),
          shuffle_map(),
          symbol_marks(),
          pending_symbols(),
          pending_blocks() {}

    ~RawOverlayBlockTracker() {
        counts.release();
        shuffle_map.release();
        symbol_marks.release();
        pending_symbols.release();
        pending_blocks.release();
    }
};

static void raw_overlay_tracker_init(const OverlayPage& base_page,
                                     RawOverlayBlockTracker& tracker) {
    tracker.enabled = false;
    tracker.limits_known = false;
    tracker.hit_limit = false;
    tracker.log_enabled = false;
    tracker.parity_symbols = 0u;
    tracker.block_total_symbols = 0u;
    tracker.block_count = 0u;
    tracker.block_limit_per_block = 0u;
    tracker.rs_region_start = 0u;
    tracker.rs_region_end = 0u;
    tracker.encoded_block_bytes = 0u;
    tracker.total_symbol_changes = 0u;
    tracker.max_block_errors = 0u;
    tracker.max_block_index = 0u;
    tracker.first_limit_block = 0u;
    tracker.first_limit_errors = 0u;
    tracker.rejected_changes = 0u;
    tracker.counts.release();
    tracker.shuffle_map.release();
    tracker.symbol_marks.release();
    tracker.pending_symbols.release();
    tracker.pending_blocks.release();
    const char* debug_env = getenv("MAKO_OVERLAY_DEBUG_RAW");
    if (debug_env && debug_env[0]) {
        tracker.log_enabled = true;
    }
    if (!base_page.metadata.has_ecc_block_data ||
        !base_page.metadata.has_ecc_parity ||
        !base_page.metadata.has_ecc_block_count) {
        return;
    }
    u64 block_data_symbols = base_page.metadata.ecc_block_data_value;
    u64 parity_symbols = base_page.metadata.ecc_parity_value;
    u64 block_count = base_page.metadata.ecc_block_count_value;
    if (block_data_symbols == 0u || parity_symbols == 0u || block_count == 0u) {
        return;
    }
    if (block_data_symbols > (U64_MAX_VALUE - parity_symbols)) {
        return;
    }
    u64 block_total_symbols = block_data_symbols + parity_symbols;
    if (block_total_symbols == 0u) {
        return;
    }
    u64 encoded_block_bytes = 0u;
    if (block_total_symbols > (U64_MAX_VALUE / block_count)) {
        return;
    }
    encoded_block_bytes = block_total_symbols * block_count;
    const u64 payload_prefix_bytes = 8u;
    const u64 header_span_bytes = (u64)makocode::ECC_HEADER_TOTAL_BYTES;
    u64 rs_region_start = payload_prefix_bytes + header_span_bytes;
    u64 rs_region_end = rs_region_start;
    if (encoded_block_bytes > (U64_MAX_VALUE - rs_region_start)) {
        rs_region_end = U64_MAX_VALUE;
    } else {
        rs_region_end = rs_region_start + encoded_block_bytes;
    }
    u64 base_bits = 0u;
    if (base_page.metadata.has_bits) {
        base_bits = base_page.metadata.bits_value;
    }
    u64 base_bytes = (base_bits + 7u) >> 3u;
    if (!base_bytes) {
        // Fall back to the stored MAKOCODE_BYTES metadata if available.
        if (base_page.metadata.has_bytes) {
            base_bytes = base_page.metadata.bytes_value;
        }
    }
    if (!base_bytes) {
        // Without a reliable byte count we cannot safely map symbols.
        return;
    }
    if (rs_region_start >= base_bytes) {
        return;
    }
    if (rs_region_end > base_bytes) {
        rs_region_end = base_bytes;
    }
    usize counter_bytes = 0u;
    if (block_count > (U64_MAX_VALUE / (u64)sizeof(u32))) {
        return;
    }
    counter_bytes = (usize)(block_count * (u64)sizeof(u32));
    if (counter_bytes == 0u) {
        return;
    }
    if (!tracker.counts.ensure(counter_bytes)) {
        return;
    }
    tracker.counts.size = counter_bytes;
    for (usize i = 0u; i < counter_bytes; ++i) {
        tracker.counts.data[i] = 0u;
    }
    if (encoded_block_bytes == 0u) {
        return;
    }
    if (encoded_block_bytes > (U64_MAX_VALUE / (u64)sizeof(usize))) {
        return;
    }
    usize shuffle_bytes = (usize)(encoded_block_bytes * (u64)sizeof(usize));
    if (shuffle_bytes == 0u) {
        return;
    }
    if (!tracker.shuffle_map.ensure(shuffle_bytes)) {
        return;
    }
    tracker.shuffle_map.size = shuffle_bytes;
    usize* shuffle_ptr = (usize*)tracker.shuffle_map.data;
    for (u64 entry = 0u; entry < encoded_block_bytes; ++entry) {
        shuffle_ptr[entry] = (usize)entry;
    }
    makocode::Pcg64Generator rng;
    rng.seed(0u);
    for (u64 remaining = encoded_block_bytes; remaining > 1u; --remaining) {
        usize i_map = (usize)(remaining - 1u);
        u64 value = rng.next();
        usize j_map = (usize)(value % (u64)(i_map + 1u));
        usize temp = shuffle_ptr[i_map];
        shuffle_ptr[i_map] = shuffle_ptr[j_map];
        shuffle_ptr[j_map] = temp;
    }
    if (!tracker.symbol_marks.ensure((usize)encoded_block_bytes)) {
        return;
    }
    tracker.symbol_marks.size = (usize)encoded_block_bytes;
    for (u64 entry = 0u; entry < encoded_block_bytes; ++entry) {
        tracker.symbol_marks.data[entry] = 0u;
    }
    tracker.enabled = true;
    tracker.limits_known = true;
    tracker.parity_symbols = parity_symbols;
    tracker.block_total_symbols = block_total_symbols;
    tracker.block_count = block_count;
    tracker.block_limit_per_block = parity_symbols / 2u;
    if (tracker.block_limit_per_block > 1u) {
        tracker.block_limit_per_block = (tracker.block_limit_per_block * 2u) / 3u;
    }
    if (tracker.block_limit_per_block == 0u) {
        tracker.block_limit_per_block = 1u;
    }
    tracker.rs_region_start = rs_region_start;
    tracker.rs_region_end = rs_region_end;
    tracker.encoded_block_bytes = encoded_block_bytes;
}

static bool raw_overlay_tracker_try_reserve_bytes(RawOverlayBlockTracker& tracker,
                                                  u64 byte_start,
                                                  u64 byte_end) {
    if (!tracker.enabled || !tracker.limits_known) {
        return true;
    }
    if (byte_start >= byte_end) {
        return true;
    }
    if (byte_end <= tracker.rs_region_start || byte_start >= tracker.rs_region_end) {
        return true;
    }
    if (byte_start < tracker.rs_region_start) {
        byte_start = tracker.rs_region_start;
    }
    if (byte_end > tracker.rs_region_end) {
        byte_end = tracker.rs_region_end;
    }
    if (byte_start >= byte_end) {
        return true;
    }
    u32* counts = (u32*)tracker.counts.data;
    const usize* shuffle_ptr = tracker.shuffle_map.data
                                   ? (const usize*)tracker.shuffle_map.data
                                   : 0;
    u8* mark_ptr = tracker.symbol_marks.data ? tracker.symbol_marks.data : 0;
    struct RawOverlayPendingSymbol {
        u64 relative;
        usize counter_index;
        u64 block_index;
    };
    struct RawOverlayPendingBlock {
        u64 block_index;
        usize counter_index;
        u32 pending;
    };
    usize span = (usize)(byte_end - byte_start);
    if (span == 0u) {
        return true;
    }
    if (span > (SIZE_MAX / sizeof(RawOverlayPendingSymbol))) {
        return false;
    }
    usize pending_symbol_bytes = span * sizeof(RawOverlayPendingSymbol);
    if (!tracker.pending_symbols.ensure(pending_symbol_bytes)) {
        return false;
    }
    RawOverlayPendingSymbol* pending_symbols =
        (RawOverlayPendingSymbol*)tracker.pending_symbols.data;
    usize pending_symbol_count = 0u;
    if (span > (SIZE_MAX / sizeof(RawOverlayPendingBlock))) {
        return false;
    }
    usize block_bytes = span * sizeof(RawOverlayPendingBlock);
    if (!tracker.pending_blocks.ensure(block_bytes)) {
        return false;
    }
    RawOverlayPendingBlock* block_accums =
        (RawOverlayPendingBlock*)tracker.pending_blocks.data;
    usize block_accum_count = 0u;
    for (u64 byte_index = byte_start; byte_index < byte_end; ++byte_index) {
        u64 relative = byte_index - tracker.rs_region_start;
        if (relative >= tracker.encoded_block_bytes) {
            continue;
        }
        if (mark_ptr && mark_ptr[relative]) {
            continue;
        }
        u64 original_index = shuffle_ptr ? (u64)shuffle_ptr[(usize)relative] : relative;
        u64 block_index = original_index / tracker.block_total_symbols;
        if (block_index >= tracker.block_count) {
            continue;
        }
        usize counter_index = (usize)block_index;
        if (counter_index >= (tracker.counts.size / sizeof(u32))) {
            continue;
        }
        RawOverlayPendingBlock* block_entry = 0;
        for (usize i = 0u; i < block_accum_count; ++i) {
            if (block_accums[i].block_index == block_index) {
                block_entry = &block_accums[i];
                break;
            }
        }
        if (!block_entry) {
            if (block_accum_count >= span) {
                return false;
            }
            block_entry = &block_accums[block_accum_count++];
            block_entry->block_index = block_index;
            block_entry->counter_index = counter_index;
            block_entry->pending = 0u;
        }
        u32 current_value = counts[counter_index];
        u64 prospective = (u64)current_value + (u64)block_entry->pending + 1u;
        if (prospective > tracker.block_limit_per_block) {
            tracker.rejected_changes += 1u;
            if (!tracker.hit_limit) {
                tracker.hit_limit = true;
                tracker.first_limit_block = block_index;
                tracker.first_limit_errors = prospective;
            }
            return false;
        }
        RawOverlayPendingSymbol* symbol_entry = &pending_symbols[pending_symbol_count++];
        symbol_entry->relative = relative;
        symbol_entry->counter_index = counter_index;
        symbol_entry->block_index = block_index;
        block_entry->pending += 1u;
    }
    if (pending_symbol_count == 0u) {
        return true;
    }
    for (usize i = 0u; i < pending_symbol_count; ++i) {
        if (mark_ptr) {
            mark_ptr[pending_symbols[i].relative] = 1u;
        }
    }
    for (usize i = 0u; i < block_accum_count; ++i) {
        RawOverlayPendingBlock& block_entry = block_accums[i];
        u32* counter_ptr = counts + block_entry.counter_index;
        u64 new_value = (u64)(*counter_ptr) + (u64)block_entry.pending;
        if (new_value > 0xFFFFFFFFu) {
            new_value = 0xFFFFFFFFu;
        }
        *counter_ptr = (u32)new_value;
        tracker.total_symbol_changes += (u64)block_entry.pending;
        if (new_value > tracker.max_block_errors) {
            tracker.max_block_errors = new_value;
            tracker.max_block_index = block_entry.block_index;
        }
    }
    return true;
}

static bool raw_overlay_tracker_try_reserve_bits(RawOverlayBlockTracker& tracker,
                                                 u64 bit_start,
                                                 u64 bit_length) {
    if (!tracker.enabled || bit_length == 0u) {
        return true;
    }
    u64 bit_end = bit_start + bit_length;
    if (bit_end < bit_start) {
        return false;
    }
    u64 byte_start = bit_start >> 3u;
    u64 byte_end = (bit_end + 7u) >> 3u;
    return raw_overlay_tracker_try_reserve_bytes(tracker, byte_start, byte_end);
}

static bool count_overlay_pixel_candidates(const OverlayPage& base_page,
                                          const OverlayPage& overlay_page,
                                          const makocode::ByteBuffer& base_mask,
                                          const makocode::ByteBuffer& overlay_mask,
                                          const OverlayIgnoreColorList* ignore_list,
                                          usize& out_count) {
    out_count = 0u;
    if (!base_page.pixels.data || !overlay_page.pixels.data) {
        return false;
    }
    if (base_page.width != overlay_page.width ||
        base_page.height != overlay_page.height) {
        return false;
    }
    usize total_pixels = (usize)base_page.width * (usize)base_page.height;
    if (base_page.pixels.size < total_pixels * 3u ||
        overlay_page.pixels.size < total_pixels * 3u) {
        return false;
    }
    if ((base_mask.size && base_mask.size != total_pixels) ||
        (overlay_mask.size && overlay_mask.size != total_pixels)) {
        return false;
    }
    u32 apply_height = base_page.data_height;
    if (overlay_page.data_height < apply_height) {
        apply_height = overlay_page.data_height;
    }
    if (apply_height > base_page.height) {
        apply_height = base_page.height;
    }
    if (apply_height == 0u) {
        return true;
    }
    const bool have_base_mask = (base_mask.data && base_mask.size);
    const bool have_overlay_mask = (overlay_mask.data && overlay_mask.size);
    for (u32 row = 0u; row < (u32)apply_height; ++row) {
        for (u32 column = 0u; column < base_page.width; ++column) {
            usize pixel_index = ((usize)row * (usize)base_page.width) + (usize)column;
            bool reserved = false;
            if (have_base_mask && base_mask.data[pixel_index]) {
                reserved = true;
            }
            if (!reserved && have_overlay_mask && overlay_mask.data[pixel_index]) {
                reserved = true;
            }
            if (reserved) {
                continue;
            }
            usize byte_index = pixel_index * 3u;
            if (byte_index + 2u >= base_page.pixels.size ||
                byte_index + 2u >= overlay_page.pixels.size) {
                return false;
            }
            if (ignore_list) {
                u8 overlay_r = overlay_page.pixels.data[byte_index + 0u];
                u8 overlay_g = overlay_page.pixels.data[byte_index + 1u];
                u8 overlay_b = overlay_page.pixels.data[byte_index + 2u];
                if (overlay_color_matches_ignore(*ignore_list, overlay_r, overlay_g, overlay_b)) {
                    continue;
                }
            }
            out_count += 1u;
        }
    }
    return true;
}

static bool count_overlay_byte_candidates(const OverlayPage& base_page,
                                          const OverlayPage& overlay_page,
                                          const makocode::ByteBuffer& base_mask,
                                          const makocode::ByteBuffer& overlay_mask,
                                          const OverlayIgnoreColorList* ignore_list,
                                          u64& out_bytes) {
    out_bytes = 0u;
    if (!base_page.pixels.data || !overlay_page.pixels.data) {
        return false;
    }
    if (base_page.width != overlay_page.width ||
        base_page.height != overlay_page.height) {
        return false;
    }
    usize total_pixels = (usize)base_page.width * (usize)base_page.height;
    if (base_page.pixels.size < total_pixels * 3u ||
        overlay_page.pixels.size < total_pixels * 3u) {
        return false;
    }
    if ((base_mask.size && base_mask.size != total_pixels) ||
        (overlay_mask.size && overlay_mask.size != total_pixels)) {
        return false;
    }
    u32 apply_height = base_page.data_height;
    if (overlay_page.data_height < apply_height) {
        apply_height = overlay_page.data_height;
    }
    if (apply_height > base_page.height) {
        apply_height = base_page.height;
    }
    if (apply_height == 0u) {
        return true;
    }
    const bool have_base_mask = (base_mask.data && base_mask.size);
    const bool have_overlay_mask = (overlay_mask.data && overlay_mask.size);
    u8 sample_bits = bits_per_sample(base_page.color_mode);
    u8 samples_per_pixel = color_mode_samples_per_pixel(base_page.color_mode);
    if (sample_bits == 0u || samples_per_pixel == 0u) {
        return false;
    }
    u64 bits_per_pixel = (u64)sample_bits * (u64)samples_per_pixel;
    if (bits_per_pixel == 0u) {
        return false;
    }
    u64 bit_count = 0u;
    for (u32 row = 0u; row < (u32)apply_height; ++row) {
        for (u32 column = 0u; column < base_page.width; ++column) {
            usize pixel_index = ((usize)row * (usize)base_page.width) + (usize)column;
            bool reserved = false;
            if (have_base_mask && base_mask.data[pixel_index]) {
                reserved = true;
            }
            if (!reserved && have_overlay_mask && overlay_mask.data[pixel_index]) {
                reserved = true;
            }
            if (reserved) {
                continue;
            }
            usize byte_index = pixel_index * 3u;
            if (byte_index + 2u >= base_page.pixels.size ||
                byte_index + 2u >= overlay_page.pixels.size) {
                return false;
            }
            if (ignore_list) {
                u8 overlay_r = overlay_page.pixels.data[byte_index + 0u];
                u8 overlay_g = overlay_page.pixels.data[byte_index + 1u];
                u8 overlay_b = overlay_page.pixels.data[byte_index + 2u];
                if (overlay_color_matches_ignore(*ignore_list, overlay_r, overlay_g, overlay_b)) {
                    continue;
                }
            }
            if (bit_count > (U64_MAX_VALUE - bits_per_pixel)) {
                bit_count = U64_MAX_VALUE;
            } else {
                bit_count += bits_per_pixel;
            }
        }
    }
    if (bit_count == 0u) {
        return true;
    }
    u64 byte_count = bit_count >> 3u;
    if (bit_count & 7u) {
        ++byte_count;
    }
    out_bytes = byte_count;
    return true;
}

static void raw_overlay_tracker_finish(const RawOverlayBlockTracker& tracker) {
    if (!tracker.enabled || !tracker.log_enabled) {
        return;
    }
    console_write(2, "overlay raw debug: blocks=");
    char buffer[32];
    u64_to_ascii(tracker.block_count, buffer, sizeof(buffer));
    console_write(2, buffer);
    console_write(2, " symbols_per_block=");
    u64_to_ascii(tracker.block_total_symbols, buffer, sizeof(buffer));
    console_write(2, buffer);
    console_write(2, " parity=");
    u64_to_ascii(tracker.parity_symbols, buffer, sizeof(buffer));
    console_write(2, buffer);
    console_write(2, " limit_per_block=");
    u64_to_ascii(tracker.block_limit_per_block, buffer, sizeof(buffer));
    console_write(2, buffer);
    console_write(2, " total_symbol_changes=");
    u64_to_ascii(tracker.total_symbol_changes, buffer, sizeof(buffer));
    console_write(2, buffer);
    console_write(2, " peak_block=");
    u64_to_ascii(tracker.max_block_index, buffer, sizeof(buffer));
    console_write(2, buffer);
    console_write(2, " peak_errors=");
    u64_to_ascii(tracker.max_block_errors, buffer, sizeof(buffer));
    console_write(2, buffer);
    console_write(2, " rejected_changes=");
    u64_to_ascii(tracker.rejected_changes, buffer, sizeof(buffer));
    console_write(2, buffer);
    if (tracker.hit_limit) {
        console_write(2, " first_limit_block=");
        u64_to_ascii(tracker.first_limit_block, buffer, sizeof(buffer));
        console_write(2, buffer);
        console_write(2, " first_limit_errors=");
        u64_to_ascii(tracker.first_limit_errors, buffer, sizeof(buffer));
        console_write(2, buffer);
    }
    console_line(2, "");
}

static bool apply_overlay_pixels_raw(const OverlayPage& overlay_page,
                                     const makocode::ByteBuffer& base_mask,
                                     const makocode::ByteBuffer& overlay_mask,
                                     u64 numerator,
                                     u64 denominator,
                                     const OverlayIgnoreColorList* ignore_list,
                                     OverlayPage& base_page) {
    RawOverlayBlockTracker tracker;
    raw_overlay_tracker_init(base_page, tracker);
    if (!base_page.pixels.data || !overlay_page.pixels.data) {
        return false;
    }
    if (base_page.width != overlay_page.width ||
        base_page.height != overlay_page.height) {
        return false;
    }
    if (denominator == 0u) {
        return false;
    }
    usize total_pixels = (usize)base_page.width * (usize)base_page.height;
    if (base_page.pixels.size < total_pixels * 3u ||
        overlay_page.pixels.size < total_pixels * 3u) {
        return false;
    }
    if ((base_mask.size && base_mask.size != total_pixels) ||
        (overlay_mask.size && overlay_mask.size != total_pixels)) {
        return false;
    }
    u32 apply_height = base_page.data_height;
    if (overlay_page.data_height < apply_height) {
        apply_height = overlay_page.data_height;
    }
    if (apply_height > base_page.height) {
        apply_height = base_page.height;
    }
    if (apply_height == 0u) {
        return true;
    }
    const bool have_base_mask = (base_mask.data && base_mask.size);
    const bool have_overlay_mask = (overlay_mask.data && overlay_mask.size);
    u8 sample_bits = bits_per_sample(base_page.color_mode);
    u8 samples_per_pixel = color_mode_samples_per_pixel(base_page.color_mode);
    if (sample_bits == 0u || samples_per_pixel == 0u) {
        return false;
    }
    u64 bits_per_pixel = (u64)sample_bits * (u64)samples_per_pixel;
    struct RawOverlayPixelCandidate {
        u64 bit_start;
        usize pixel_index;
    };
    if (total_pixels > (SIZE_MAX / sizeof(RawOverlayPixelCandidate))) {
        return false;
    }
    usize candidate_capacity_bytes = total_pixels * sizeof(RawOverlayPixelCandidate);
    makocode::ByteBuffer candidate_buffer;
    if (!candidate_buffer.ensure(candidate_capacity_bytes)) {
        return false;
    }
    RawOverlayPixelCandidate* candidates =
        (RawOverlayPixelCandidate*)candidate_buffer.data;
    usize candidate_count = 0u;
    u64 candidate_rank = 0u;
    for (u32 row = 0u; row < apply_height; ++row) {
        for (u32 column = 0u; column < base_page.width; ++column) {
            usize pixel_index = ((usize)row * (usize)base_page.width) + (usize)column;
            bool reserved = false;
            if (have_base_mask && base_mask.data[pixel_index]) {
                reserved = true;
            }
            if (!reserved && have_overlay_mask && overlay_mask.data[pixel_index]) {
                reserved = true;
            }
            if (reserved) {
                continue;
            }
            usize byte_index = pixel_index * 3u;
            if (byte_index + 2u >= base_page.pixels.size ||
                byte_index + 2u >= overlay_page.pixels.size) {
                return false;
            }
            if (ignore_list) {
                u8 overlay_r = overlay_page.pixels.data[byte_index + 0u];
                u8 overlay_g = overlay_page.pixels.data[byte_index + 1u];
                u8 overlay_b = overlay_page.pixels.data[byte_index + 2u];
                if (overlay_color_matches_ignore(*ignore_list, overlay_r, overlay_g, overlay_b)) {
                    continue;
                }
            }
            RawOverlayPixelCandidate* entry = &candidates[candidate_count++];
            entry->pixel_index = pixel_index;
            entry->bit_start = candidate_rank * bits_per_pixel;
            candidate_rank += 1u;
        }
    }
    if (candidate_count > 1u) {
        makocode::Pcg64Generator shuffle_rng;
        shuffle_rng.seed(0u);
        for (usize remaining = candidate_count; remaining > 1u; --remaining) {
            usize i = remaining - 1u;
            u64 value = shuffle_rng.next();
            usize j = (usize)(value % (u64)remaining);
            RawOverlayPixelCandidate temp = candidates[i];
            candidates[i] = candidates[j];
            candidates[j] = temp;
        }
    }
    if (!tracker.enabled && candidate_count > 0u) {
        u64 requested = (u64)candidate_count;
        requested *= numerator;
        requested /= denominator;
        u64 cap = (u64)candidate_count / 50u; // ~2% of candidates when ECC metadata is unknown.
        if (cap == 0u) {
            cap = 1u;
        }
        if (requested > cap) {
            numerator = cap;
            denominator = (u64)candidate_count;
            if (numerator == 0u) {
                numerator = 1u;
            }
        }
    }
    u64 accumulator = 0u;
    for (usize idx = 0u; idx < candidate_count; ++idx) {
        const RawOverlayPixelCandidate& candidate = candidates[idx];
        accumulator += numerator;
        if (accumulator < denominator) {
            continue;
        }
        accumulator -= denominator;
        usize pixel_index = candidate.pixel_index;
        usize byte_index = pixel_index * 3u;
        if (byte_index + 2u >= base_page.pixels.size ||
            byte_index + 2u >= overlay_page.pixels.size) {
            return false;
        }
        bool changed = false;
        if (base_page.pixels.data[byte_index + 0u] != overlay_page.pixels.data[byte_index + 0u] ||
            base_page.pixels.data[byte_index + 1u] != overlay_page.pixels.data[byte_index + 1u] ||
            base_page.pixels.data[byte_index + 2u] != overlay_page.pixels.data[byte_index + 2u]) {
            changed = true;
        }
        if (changed) {
            if (!raw_overlay_tracker_try_reserve_bits(tracker, candidate.bit_start, bits_per_pixel)) {
                continue;
            }
        }
        memcpy(base_page.pixels.data + byte_index,
               overlay_page.pixels.data + byte_index,
               3u);
    }
    raw_overlay_tracker_finish(tracker);
    return true;
}

static bool serialize_overlay_page(const OverlayPage& page,
                                   makocode::ByteBuffer& output) {
    output.release();
    if (!ppm_write_metadata_header(page.metadata, output)) {
        return false;
    }
    if (!ppm_append_extended_metadata(page.metadata, output)) {
        return false;
    }
    if (!ppm_append_fiducial_metadata(page.metadata, output)) {
        return false;
    }
    if (!ppm_write_dimensions((u64)page.width, (u64)page.height, output)) {
        return false;
    }
    if (!page.pixels.data) {
        return false;
    }
    usize total_pixels = (usize)page.width * (usize)page.height;
    if (page.pixels.size < total_pixels * 3u) {
        return false;
    }
    for (usize index = 0u; index < total_pixels; ++index) {
        const u8* rgb = page.pixels.data + index * 3u;
        for (u8 channel = 0u; channel < 3u; ++channel) {
            if (channel) {
                if (!output.append_char(' ')) {
                    return false;
                }
            }
            if (!buffer_append_number(output, (u64)rgb[channel])) {
                return false;
            }
        }
        if (!output.append_char('\n')) {
            return false;
        }
    }
    return true;
}

static bool write_buffer_to_fd(int fd, const makocode::ByteBuffer& buffer) {
    if (!buffer.data || buffer.size == 0u) {
        return true;
    }
    usize offset = 0u;
    while (offset < buffer.size) {
        unsigned long chunk = (unsigned long)(buffer.size - offset);
        if (chunk > 65536ul) {
            chunk = 65536ul;
        }
        int wrote = write(fd, buffer.data + offset, chunk);
        if (wrote <= 0) {
            return false;
        }
        offset += (usize)wrote;
    }
    return true;
}

static int command_overlay(int arg_count, char** args) {
    if (arguments_request_help(arg_count, args)) {
        write_overlay_help();
        return 0;
    }
    OverlayIgnoreColorList ignore_colors;
    ignore_colors.count = 0u;
    const char* ignore_text = 0;
    usize ignore_length = 0u;
    bool ignore_specified = false;
    bool ecc_target_specified = false;
    u64 ecc_target_numerator = 0u;
    u64 ecc_target_denominator = 1u;
    int option_index = 0;
    const char ignore_option[] = "--ignore-colors";
    const char ignore_prefix[] = "--ignore-colors=";
    const char ecc_target_option[] = "--overlay-ecc-target";
    const char ecc_target_prefix[] = "--overlay-ecc-target=";
    while (option_index < arg_count) {
        const char* arg = args[option_index];
        if (!arg) {
            ++option_index;
            continue;
        }
        if (consume_debug_flag(arg)) {
            ++option_index;
            continue;
        }
        usize length = ascii_length(arg);
        if (ascii_equals_token(arg, length, ignore_option)) {
            if (ignore_specified) {
                console_line(2, "overlay: --ignore-colors specified multiple times");
                return 1;
            }
            if ((option_index + 1) >= arg_count) {
                console_line(2, "overlay: --ignore-colors requires a value");
                return 1;
            }
            const char* value = args[option_index + 1];
            if (!value) {
                console_line(2, "overlay: --ignore-colors requires a value");
                return 1;
            }
            usize value_length = ascii_length(value);
            if (value_length == 0u) {
                console_line(2, "overlay: --ignore-colors requires a non-empty value");
                return 1;
            }
            ignore_text = value;
            ignore_length = value_length;
            ignore_specified = true;
            option_index += 2;
            continue;
        }
        if (ascii_starts_with(arg, ignore_prefix)) {
            if (ignore_specified) {
                console_line(2, "overlay: --ignore-colors specified multiple times");
                return 1;
            }
            const char* value = arg + (sizeof(ignore_prefix) - 1u);
            if (!value || *value == '\0') {
                console_line(2, "overlay: --ignore-colors requires a non-empty value");
                return 1;
            }
            ignore_text = value;
            ignore_length = ascii_length(value);
            ignore_specified = true;
            ++option_index;
            continue;
        }
        if (ascii_equals_token(arg, length, ecc_target_option)) {
            if (ecc_target_specified) {
                console_line(2, "overlay: --overlay-ecc-target specified multiple times");
                return 1;
            }
            if ((option_index + 1) >= arg_count) {
                console_line(2, "overlay: --overlay-ecc-target requires a value");
                return 1;
            }
            const char* value = args[option_index + 1];
            if (!value) {
                console_line(2, "overlay: --overlay-ecc-target requires a value");
                return 1;
            }
            usize value_length = ascii_length(value);
            if (value_length == 0u) {
                console_line(2, "overlay: --overlay-ecc-target requires a non-empty value");
                return 1;
            }
            if (!ascii_to_fraction(value, value_length, ecc_target_numerator, ecc_target_denominator)) {
                console_line(2, "overlay: --overlay-ecc-target requires a decimal value such as 0.5");
                return 1;
            }
            if (ecc_target_denominator == 0u) {
                console_line(2, "overlay: --overlay-ecc-target requires a non-zero denominator");
                return 1;
            }
            ecc_target_specified = true;
            option_index += 2;
            continue;
        }
        if (ascii_starts_with(arg, ecc_target_prefix)) {
            if (ecc_target_specified) {
                console_line(2, "overlay: --overlay-ecc-target specified multiple times");
                return 1;
            }
            const char* value = arg + (sizeof(ecc_target_prefix) - 1u);
            if (!value || *value == '\0') {
                console_line(2, "overlay: --overlay-ecc-target requires a non-empty value");
                return 1;
            }
            if (!ascii_to_fraction(value, ascii_length(value), ecc_target_numerator, ecc_target_denominator)) {
                console_line(2, "overlay: --overlay-ecc-target requires a decimal value such as 0.5");
                return 1;
            }
            if (ecc_target_denominator == 0u) {
                console_line(2, "overlay: --overlay-ecc-target requires a non-zero denominator");
                return 1;
            }
            ecc_target_specified = true;
            ++option_index;
            continue;
        }
        break;
    }
    int positional_count = arg_count - option_index;
    if (positional_count != 3) {
        console_line(2, "overlay: usage: makocode overlay [--ignore-colors COLORS] [--overlay-ecc-target TARGET] BASE.ppm OVERLAY.ppm FRACTION");
        return 1;
    }
    const char* base_path = args[option_index];
    const char* overlay_path = args[option_index + 1];
    const char* fraction_text = args[option_index + 2];
    if (ignore_specified) {
        if (!parse_overlay_ignore_colors(ignore_text, ignore_length, ignore_colors)) {
            return 1;
        }
    }
    const OverlayIgnoreColorList* overlay_ignore = (ignore_colors.count > 0u) ? &ignore_colors : 0;
    if (!base_path || !overlay_path || !fraction_text) {
        console_line(2, "overlay: arguments may not be empty");
        return 1;
    }
    usize fraction_length = ascii_length(fraction_text);
    u64 numerator = 0u;
    u64 denominator = 1u;
    if (fraction_length == 0u ||
        !ascii_to_fraction(fraction_text, fraction_length, numerator, denominator)) {
        console_line(2, "overlay: fraction must be a decimal value such as 0.25");
        return 1;
    }
    if (denominator == 0u) {
        console_line(2, "overlay: invalid fraction");
        return 1;
    }
    if (numerator >= denominator) {
        numerator = denominator;
    }
    OverlayPage base_page;
    OverlayPage overlay_page;
    if (!load_overlay_page(base_path, base_page)) {
        return 1;
    }
    if (!load_overlay_page(overlay_path, overlay_page)) {
        return 1;
    }
    if (base_page.width != overlay_page.width ||
        base_page.height != overlay_page.height) {
        console_line(2, "overlay: ppm images must have identical dimensions");
        return 1;
    }
    // Align overlay layout to the base so fiducial/data regions match pixel-for-pixel.
    overlay_apply_base_layout(base_page, overlay_page);
    makocode::ByteBuffer base_mask;
    makocode::ByteBuffer overlay_mask;
    u64 base_reserved = 0u;
    u64 overlay_reserved = 0u;
    if (!build_overlay_mask(base_page, base_mask, base_reserved)) {
        console_line(2, "overlay: failed to prepare fiducial mask for base image");
        return 1;
    }
    if (!build_overlay_mask(overlay_page, overlay_mask, overlay_reserved)) {
        console_line(2, "overlay: failed to prepare fiducial mask for overlay image");
        return 1;
    }
    if (base_mask.size != overlay_mask.size) {
        console_line(2, "overlay: fiducial mask size mismatch");
        return 1;
    }
    if (ecc_target_specified) {
        RawOverlayBlockTracker ecc_tracker;
        raw_overlay_tracker_init(base_page, ecc_tracker);
        if (!ecc_tracker.enabled) {
            console_line(2, "overlay: --overlay-ecc-target requires ECC metadata");
            return 1;
        }
        u64 candidate_limit = 0u;
        if (base_page.color_mode != overlay_page.color_mode) {
            usize candidate_count = 0u;
            if (!count_overlay_pixel_candidates(base_page,
                                                overlay_page,
                                                base_mask,
                                                overlay_mask,
                                                overlay_ignore,
                                                candidate_count)) {
                console_line(2, "overlay: failed to evaluate overlay candidates");
                return 1;
            }
            candidate_limit = (candidate_count > (usize)U64_MAX_VALUE)
                                ? U64_MAX_VALUE
                                : (u64)candidate_count;
        } else {
            u64 candidate_bytes = 0u;
            if (!count_overlay_byte_candidates(base_page,
                                               overlay_page,
                                               base_mask,
                                               overlay_mask,
                                               overlay_ignore,
                                               candidate_bytes)) {
                console_line(2, "overlay: failed to evaluate overlay candidates");
                return 1;
            }
            candidate_limit = candidate_bytes;
        }
        long double target_fraction = (long double)ecc_target_numerator /
                                       (long double)ecc_target_denominator;
        if (target_fraction < 0.0L) {
            target_fraction = 0.0L;
        } else if (target_fraction > 1.0L) {
            target_fraction = 1.0L;
        }
        u64 total_limit = ecc_tracker.block_count * ecc_tracker.block_limit_per_block;
        if (total_limit == 0u) {
            console_line(2, "overlay: ECC metadata reports zero capacity");
            return 1;
        }
        long double desired_changes = target_fraction * (long double)total_limit;
        u64 target_changes = (u64)(desired_changes + 0.5L);
        if (target_changes == 0u && target_fraction > 0.0L && candidate_limit > 0u) {
            target_changes = 1u;
        }
        if (target_changes > candidate_limit) {
            target_changes = candidate_limit;
        }
        if (candidate_limit == 0u) {
            if (target_changes > 0u) {
                console_line(2, "overlay: no overlay candidates remain after masks/ignore");
                return 1;
            }
            numerator = 0u;
            denominator = 1u;
        } else {
            numerator = target_changes;
            denominator = candidate_limit;
            if (numerator > denominator) {
                numerator = denominator;
            }
        }
    }
    if (numerator == 0u) {
        if (!write_buffer_to_fd(1, base_page.original)) {
            console_line(2, "overlay: failed to write original base image");
            return 1;
        }
        return 0;
    }
    if (base_page.color_mode != overlay_page.color_mode) {
        if (!apply_overlay_pixels_raw(overlay_page, base_mask, overlay_mask, numerator, denominator, overlay_ignore, base_page)) {
            console_line(2, "overlay: failed to copy raw pixel data between color modes");
            return 1;
        }
    } else {
        makocode::ByteBuffer base_bits;
        makocode::ByteBuffer overlay_bits;
        u64 base_bit_count = 0u;
        u64 overlay_bit_count = 0u;
        if (!gather_overlay_bits(base_page, base_mask, base_bits, base_bit_count)) {
            console_line(2, "overlay: failed to extract data bytes from base image");
            return 1;
        }
        if (!gather_overlay_bits(overlay_page, overlay_mask, overlay_bits, overlay_bit_count)) {
            console_line(2, "overlay: failed to extract data bytes from overlay image");
            return 1;
        }
        if (base_bit_count == 0u || base_bits.size == 0u) {
            console_line(2, "overlay: base image does not contain data bytes to modify");
            return 1;
        }
        if (overlay_bits.size == 0u) {
            console_line(2, "overlay: overlay image does not provide data bytes");
            return 1;
        }
        u64 base_bytes = (base_bit_count + 7u) >> 3u;
        u64 overlay_bytes = (overlay_bit_count + 7u) >> 3u;
        u64 copy_bytes = (base_bytes < overlay_bytes) ? base_bytes : overlay_bytes;
        if (copy_bytes == 0u) {
            console_line(2, "overlay: no whole bytes available for overlay");
            return 1;
        }
        u8* base_ptr = base_bits.data;
        const u8* overlay_ptr = overlay_bits.data;
        if (!base_ptr || !overlay_ptr) {
            console_line(2, "overlay: internal byte buffer unavailable");
            return 1;
        }
        u64 accumulator = 0u;
        makocode::ByteBuffer block_counters;
        makocode::ByteBuffer block_shuffle_map;
        u16* block_counters_ptr = 0;
        usize* block_shuffle_map_ptr = 0;
        bool block_limit_active = false;
        u64 block_limit_start = 0u;
        u64 block_limit_end = 0u;
        u64 block_limit_hits = 0u;
        u64 block_total_symbols = 0u;
        u64 block_total_count = 0u;
        u64 block_limit_per_block = 0u;
        u64 shuffle_entry_count = 0u;
        const u64 payload_prefix_bytes = 8u;
        const u64 header_span_bytes = (u64)makocode::ECC_HEADER_TOTAL_BYTES;
        if (base_bytes >= payload_prefix_bytes + header_span_bytes) {
            u64 payload_bytes = base_bytes - payload_prefix_bytes;
            usize payload_byte_count = (payload_bytes > (u64)USIZE_MAX_VALUE)
                                          ? USIZE_MAX_VALUE
                                          : (usize)payload_bytes;
            if (payload_byte_count >= makocode::ECC_HEADER_TOTAL_BYTES) {
                const u8* payload_ptr = base_ptr + payload_prefix_bytes;
                makocode::EccHeaderInfo ecc_header;
                if (makocode::parse_ecc_header(payload_ptr, payload_byte_count, ecc_header) &&
                    ecc_header.valid && ecc_header.enabled) {
                    u64 block_data = (u64)ecc_header.block_data;
                    u64 parity = (u64)ecc_header.parity;
                    u64 block_total = block_data + parity;
                    u64 block_count_value = ecc_header.block_count;
                    if (block_data && parity && block_total && block_count_value &&
                        block_total <= (U64_MAX_VALUE / block_count_value)) {
                        u64 encoded_block_bytes = block_total * block_count_value;
                        u64 available_rs_bytes = (payload_bytes >= header_span_bytes)
                                                    ? (payload_bytes - header_span_bytes)
                                                    : 0u;
                        if (encoded_block_bytes > available_rs_bytes) {
                            encoded_block_bytes = available_rs_bytes;
                        }
                        if (encoded_block_bytes > 0u &&
                            block_count_value <= (u64)(USIZE_MAX_VALUE / sizeof(u16))) {
                            usize counter_bytes = (usize)(block_count_value * (u64)sizeof(u16));
                            if (counter_bytes != 0u && block_counters.ensure(counter_bytes)) {
                                block_counters.size = counter_bytes;
                                for (usize counter_index = 0u; counter_index < counter_bytes; ++counter_index) {
                                    block_counters.data[counter_index] = 0u;
                                }
                                block_total_symbols = block_total;
                                block_total_count = block_count_value;
                                // RS can correct up to t = floor(parity/2) symbol errors per block.
                                // Stay slightly under that theoretical maximum to avoid edge-case
                                // failures when additional corruption exists (e.g. header/prefix).
                                block_limit_per_block = parity / 2u;
                                if (block_limit_per_block > 1u) {
                                    block_limit_per_block -= 1u;
                                } else {
                                    block_limit_per_block = 1u;
                                }
                                if (encoded_block_bytes <= (u64)USIZE_MAX_VALUE) {
                                    usize entries = (usize)encoded_block_bytes;
                                    if (entries != 0u &&
                                        entries <= (USIZE_MAX_VALUE / sizeof(usize))) {
                                        usize map_bytes = entries * sizeof(usize);
                                        if (map_bytes != 0u && block_shuffle_map.ensure(map_bytes)) {
                                            block_shuffle_map.size = map_bytes;
                                            block_shuffle_map_ptr = (usize*)block_shuffle_map.data;
                                            for (usize map_index = 0u; map_index < entries; ++map_index) {
                                                block_shuffle_map_ptr[map_index] = map_index;
                                            }
                                            makocode::Pcg64Generator rng;
                                            rng.seed(0u);
                                            for (usize map_index = entries; map_index > 1u; --map_index) {
                                                usize i_map = map_index - 1u;
                                                u64 value = rng.next();
                                                usize j_map = (usize)(value % (u64)(i_map + 1u));
                                                usize temp = block_shuffle_map_ptr[i_map];
                                                block_shuffle_map_ptr[i_map] = block_shuffle_map_ptr[j_map];
                                                block_shuffle_map_ptr[j_map] = temp;
                                            }
                                            block_counters_ptr = (u16*)block_counters.data;
                                            shuffle_entry_count = (u64)entries;
                                            block_limit_start = payload_prefix_bytes + header_span_bytes;
                                            block_limit_end = block_limit_start + shuffle_entry_count;
                                            if (block_limit_end > base_bytes) {
                                                block_limit_end = base_bytes;
                                            }
                                            block_limit_active = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // If ECC metadata is available and the caller did not specify an explicit ECC target,
        // clamp the requested overlay fraction to a conservative bound based on correctable
        // symbols. The raw fraction argument is in terms of bytes to replace and can easily
        // exceed ECC capabilities when used with heavy overlays.
        if (!ecc_target_specified &&
            block_limit_active &&
            block_total_symbols > 0u &&
            block_total_count > 0u &&
            block_limit_per_block > 0u &&
            copy_bytes > 0u &&
            denominator > 0u) {
            // Keep generous headroom beyond the theoretical RS limit to survive
            // additional damage (e.g., scanning noise) on top of the overlay.
            u64 safe_per_block = block_limit_per_block;
            if (safe_per_block > 1u) {
                safe_per_block = (safe_per_block * 2u) / 3u; // ~67% of the nominal limit
                if (safe_per_block == 0u) {
                    safe_per_block = 1u;
                }
            }
            __uint128_t safe_total = (__uint128_t)safe_per_block * (__uint128_t)block_total_count;
            __uint128_t max_num128 = safe_total * (__uint128_t)denominator;
            max_num128 /= (__uint128_t)copy_bytes;
            u64 max_numerator = (max_num128 > (__uint128_t)U64_MAX_VALUE) ? U64_MAX_VALUE : (u64)max_num128;
            if (max_numerator == 0u && safe_total > 0u) {
                max_numerator = 1u;
            }
            if (numerator > max_numerator) {
                numerator = max_numerator;
            }
        }
        for (u64 i = 0u; i < copy_bytes; ++i) {
            accumulator += numerator;
            if (accumulator < denominator) {
                continue;
            }
            bool replaced = false;
            bool skipped_for_limit = false;
            if (block_limit_active &&
                block_shuffle_map_ptr &&
                block_counters_ptr &&
                block_total_symbols > 0u &&
                block_total_count > 0u &&
                i >= block_limit_start &&
                i < block_limit_end) {
                u64 relative = i - block_limit_start;
                if (relative < shuffle_entry_count) {
                    u64 original_index = (u64)block_shuffle_map_ptr[(usize)relative];
                    u64 block_index = original_index / block_total_symbols;
                    if (block_index < block_total_count) {
                        usize counter_index = (usize)block_index;
                        u16 current_count = block_counters_ptr[counter_index];
                        if ((u64)current_count < block_limit_per_block) {
                            base_ptr[i] = overlay_ptr[i];
                            block_counters_ptr[counter_index] = (u16)(current_count + 1u);
                            replaced = true;
                        } else {
                            skipped_for_limit = true;
                            ++block_limit_hits;
                        }
                    }
                }
            }
            if (!replaced && !skipped_for_limit) {
                base_ptr[i] = overlay_ptr[i];
                replaced = true;
            }
            if (replaced) {
                accumulator -= denominator;
            }
        }
        if (block_limit_active && debug_logging_enabled()) {
            char limit_buf[32];
            char hits_buf[32];
            console_write(2, "debug overlay: block limit=");
            u64_to_ascii(block_limit_per_block, limit_buf, sizeof(limit_buf));
            console_write(2, limit_buf);
            console_write(2, " blocks=");
            u64_to_ascii(block_total_count, limit_buf, sizeof(limit_buf));
            console_write(2, limit_buf);
            console_write(2, " hits=");
            u64_to_ascii(block_limit_hits, hits_buf, sizeof(hits_buf));
            console_line(2, hits_buf);
        }
        if (!apply_overlay_bits(base_bits, base_bit_count, base_mask, base_page, &overlay_page, overlay_ignore)) {
            console_line(2, "overlay: failed to map merged bytes back to base image");
            return 1;
        }
    }
    makocode::ByteBuffer output;
    if (!serialize_overlay_page(base_page, output)) {
        console_line(2, "overlay: failed to serialize merged ppm");
        return 1;
    }
    if (!write_buffer_to_fd(1, output)) {
        console_line(2, "overlay: failed to emit merged ppm");
        return 1;
    }
    return 0;
}

static int command_decode(int arg_count, char** args) {
    if (arguments_request_help(arg_count, args)) {
        write_decode_help();
        return 0;
    }
    ImageMappingConfig mapping;
    static const usize MAX_INPUT_FILES = 256u;
    const char* input_files[MAX_INPUT_FILES];
    usize file_count = 0u;
    makocode::ByteBuffer password_buffer;
    bool have_password = false;
    makocode::ByteBuffer output_dir_buffer;
    const char* output_dir = ".";
    bool have_output_dir = false;
    u32 corrupt_header_copies = 0u;
   for (int i = 0; i < arg_count; ++i) {
       bool handled = false;
        if (!process_image_mapping_option(arg_count, args, &i, mapping, "decode", &handled)) {
            return 1;
        }
        if (handled) {
            continue;
        }
        const char* arg = args[i];
        if (!arg) {
            continue;
        }
        if (consume_debug_flag(arg)) {
            continue;
        }
        const char output_prefix[] = "--output-dir=";
        const char* output_value = 0;
        usize output_length = 0u;
        if (ascii_equals_token(arg, ascii_length(arg), "--output-dir")) {
            if (have_output_dir) {
                console_line(2, "decode: output directory specified multiple times");
                return 1;
            }
            if ((i + 1) >= arg_count) {
                console_line(2, "decode: --output-dir requires a non-empty path");
                return 1;
            }
            output_value = args[i + 1];
            if (!output_value) {
                console_line(2, "decode: --output-dir requires a non-empty path");
                return 1;
            }
            output_length = ascii_length(output_value);
            i += 1;
        } else if (ascii_starts_with(arg, output_prefix)) {
            if (have_output_dir) {
                console_line(2, "decode: output directory specified multiple times");
                return 1;
            }
            output_value = arg + (sizeof(output_prefix) - 1u);
            output_length = ascii_length(output_value);
        }
        if (output_value) {
            if (output_length == 0u) {
                console_line(2, "decode: --output-dir requires a non-empty path");
                return 1;
            }
    if (!output_dir_buffer.ensure(output_length + 1u)) {
        console_line(2, "decode: failed to allocate output directory buffer");
        return 1;
    }
            for (usize j = 0u; j < output_length; ++j) {
                output_dir_buffer.data[j] = (u8)output_value[j];
            }
            output_dir_buffer.data[output_length] = 0u;
            output_dir_buffer.size = output_length;
            output_dir = (const char*)output_dir_buffer.data;
            have_output_dir = true;
            continue;
        }
        const char password_prefix[] = "--password=";
        const char* password_value = 0;
        usize password_length = 0u;
        if (ascii_equals_token(arg, ascii_length(arg), "--password")) {
            if (have_password) {
                console_line(2, "decode: password specified multiple times");
                return 1;
            }
            if ((i + 1) >= arg_count) {
                console_line(2, "decode: --password requires a non-empty value");
                return 1;
            }
            password_value = args[i + 1];
            if (!password_value) {
                console_line(2, "decode: --password requires a non-empty value");
                return 1;
            }
            password_length = ascii_length(password_value);
            i += 1;
        } else if (ascii_starts_with(arg, password_prefix)) {
            if (have_password) {
                console_line(2, "decode: password specified multiple times");
                return 1;
            }
            password_value = arg + (sizeof(password_prefix) - 1u);
            password_length = ascii_length(password_value);
        }
        if (password_value) {
            if (password_length == 0u) {
                console_line(2, "decode: --password requires a non-empty value");
                return 1;
            }
            if (!password_buffer.ensure(password_length)) {
                console_line(2, "decode: failed to allocate password buffer");
                return 1;
            }
            for (usize j = 0u; j < password_length; ++j) {
                password_buffer.data[j] = (u8)password_value[j];
            }
            password_buffer.size = password_length;
            have_password = true;
            continue;
        }
        const char corrupt_prefix[] = "--corrupt-header-copies=";
        if (ascii_starts_with(arg, corrupt_prefix)) {
            const char* value = arg + (sizeof(corrupt_prefix) - 1u);
            usize value_length = ascii_length(value);
            if (value_length == 0u) {
                console_line(2, "decode: --corrupt-header-copies requires a value");
                return 1;
            }
            u64 parsed = 0u;
            if (!ascii_to_u64(value, value_length, &parsed)) {
                console_line(2, "decode: invalid value for --corrupt-header-copies");
                return 1;
            }
            if (parsed > (u64)makocode::ECC_HEADER_COPY_COUNT) {
                parsed = (u64)makocode::ECC_HEADER_COPY_COUNT;
            }
            corrupt_header_copies = (u32)parsed;
            continue;
        }
        if (file_count >= MAX_INPUT_FILES) {
            console_line(2, "decode: too many input files");
            return 1;
        }
    input_files[file_count++] = arg;
}
    if (mapping.palette_set) {
        if (!image_mapping_build_custom_palette(mapping, "decode")) {
            return 1;
        }
    }
    makocode::ByteBuffer bitstream;
    u64 bit_count = 0u;
    PpmParserState aggregate_state;
    bool have_metadata = false;
    bool force_disable_subgrid = false;
    bool retried_subgrid = false;

retry_decode:
    bitstream.release();
    bit_count = 0u;
    aggregate_state = PpmParserState();
    have_metadata = false;
    if (file_count == 0u) {
        makocode::ByteBuffer ppm_stream;
        if (!read_entire_stdin(ppm_stream)) {
            console_line(2, "decode: failed to read stdin");
            return 1;
        }
        makocode::ByteBuffer frame_bits;
        u64 frame_bit_count = 0u;
        PpmParserState single_state;
        if (!ppm_extract_frame_bits(ppm_stream, mapping, frame_bits, frame_bit_count, single_state, force_disable_subgrid)) {
            if (!force_disable_subgrid && !retried_subgrid) {
                console_line(2, "decode: retrying without fiducial subgrid (frame extraction failed)");
                force_disable_subgrid = true;
                retried_subgrid = true;
                goto retry_decode;
            }
            console_line(2, "decode: invalid ppm input");
            return 1;
        }
        if (!frame_bits_to_payload(frame_bits.data, frame_bit_count, single_state, bitstream, bit_count)) {
            if (!force_disable_subgrid && !retried_subgrid) {
                console_line(2, "decode: retrying without fiducial subgrid (payload header unreadable)");
                force_disable_subgrid = true;
                retried_subgrid = true;
                goto retry_decode;
            }
            console_line(2, "decode: failed to extract payload bits");
            return 1;
        }
        aggregate_state = single_state;
        have_metadata = true;
    } else {
        makocode::BitWriter frame_aggregator;
        frame_aggregator.reset();
        bool aggregate_initialized = false;
        bool enforce_page_index = true;
        u64 expected_page_index = 1u;
        for (usize file_index = 0u; file_index < file_count; ++file_index) {
            makocode::ByteBuffer ppm_stream;
            if (debug_logging_enabled()) {
                console_write(2, "debug reading file: ");
                console_line(2, input_files[file_index]);
            }
            if (!read_entire_file(input_files[file_index], ppm_stream)) {
                console_write(2, "decode: failed to read ");
                console_line(2, input_files[file_index]);
                return 1;
            }
            if (debug_logging_enabled() && ppm_stream.size >= 8u && ppm_stream.data) {
                console_write(2, "debug read bytes: ");
                for (usize debug_i = 0u; debug_i < 8u && debug_i < ppm_stream.size; ++debug_i) {
                    char value_buffer[32];
                    u64_to_ascii((u64)(unsigned char)ppm_stream.data[debug_i], value_buffer, sizeof(value_buffer));
                    console_write(2, value_buffer);
                    if ((debug_i + 1u) < ppm_stream.size && debug_i < 7u) {
                        console_write(2, " ");
                    }
                }
                console_line(2, "");
            }
            makocode::ByteBuffer page_bits;
            u64 page_bit_count = 0u;
            PpmParserState page_state;
            if (!ppm_extract_frame_bits(ppm_stream, mapping, page_bits, page_bit_count, page_state, force_disable_subgrid)) {
                if (!force_disable_subgrid && !retried_subgrid) {
                    console_line(2, "decode: retrying without fiducial subgrid (frame extraction failed)");
                    force_disable_subgrid = true;
                    retried_subgrid = true;
                    goto retry_decode;
                }
                console_write(2, "decode: invalid ppm in ");
                console_line(2, input_files[file_index]);
                return 1;
            }
            if (!aggregate_initialized) {
                if (!merge_parser_state(aggregate_state, page_state)) {
                    console_line(2, "decode: inconsistent metadata");
                    return 1;
                }
                aggregate_initialized = true;
            } else {
                if (!merge_parser_state(aggregate_state, page_state)) {
                    console_line(2, "decode: conflicting metadata between pages");
                    return 1;
                }
            }
            if (!page_state.has_page_index || page_state.page_index_value == 0u) {
                page_state.has_page_index = true;
                page_state.page_index_value = expected_page_index;
            }
            if (enforce_page_index) {
                if (page_state.has_page_index) {
                    if (page_state.page_index_value != expected_page_index) {
                        char expected_buffer[32];
                        char actual_buffer[32];
                        u64_to_ascii(expected_page_index, expected_buffer, sizeof(expected_buffer));
                        u64_to_ascii(page_state.page_index_value, actual_buffer, sizeof(actual_buffer));
                        console_write(2, "decode: unexpected page order (expected: ");
                        console_write(2, expected_buffer);
                        console_write(2, ", actual: ");
                        console_write(2, actual_buffer);
                        console_line(2, ")");
                        return 1;
                    }
                } else {
                    enforce_page_index = false;
                }
            }
            u64 effective_bits = page_bit_count;
            if (page_state.has_page_bits && page_state.page_bits_value <= effective_bits) {
                effective_bits = page_state.page_bits_value;
            }
            if (!append_bits_from_buffer(frame_aggregator, page_bits.data, effective_bits)) {
                console_line(2, "decode: failed to assemble bitstream");
                return 1;
            }
            ++expected_page_index;
        }
        if (!aggregate_state.has_page_count ||
            aggregate_state.page_count_value == 0u ||
            aggregate_state.page_count_value < file_count) {
            aggregate_state.has_page_count = false;
        }
        if (aggregate_state.has_page_count) {
            u64 advertised_pages = aggregate_state.page_count_value;
            if (file_count > advertised_pages) {
                console_line(2, "decode: page count metadata mismatch");
                return 1;
            }
            if (file_count != advertised_pages && debug_logging_enabled()) {
                console_line(2, "debug: decoding subset of pages; skipping page count check");
            }
        }
        const u8* frame_data = frame_aggregator.data();
        u64 frame_bit_total = frame_aggregator.bit_size();
        if (!frame_bits_to_payload(frame_data, frame_bit_total, aggregate_state, bitstream, bit_count)) {
            if (!force_disable_subgrid && !retried_subgrid) {
                console_line(2, "decode: retrying without fiducial subgrid (payload header unreadable)");
                force_disable_subgrid = true;
                retried_subgrid = true;
                goto retry_decode;
            }
            console_line(2, "decode: failed to extract payload bits");
            return 1;
        }
        have_metadata = true;
    }
    if (have_metadata &&
        aggregate_state.has_palette_text &&
        aggregate_state.palette_text_length &&
        !mapping.palette_set) {
        if (!image_mapping_set_palette_text(mapping,
                                            aggregate_state.palette_text,
                                            aggregate_state.palette_text_length,
                                            "decode")) {
            return 1;
        }
        if (!image_mapping_build_custom_palette(mapping, "decode")) {
            return 1;
        }
    }
    bool ecc_header_repaired = false;
    makocode::EccHeaderInfo bitstream_header;
    bool bitstream_header_present = false;
    bool bitstream_header_valid = false;
    if (bitstream.data && bitstream.size >= makocode::ECC_HEADER_TOTAL_BYTES) {
        bitstream_header_present = makocode::parse_ecc_header(bitstream.data, bitstream.size, bitstream_header);
        bitstream_header_valid = bitstream_header_present && bitstream_header.valid && bitstream_header.enabled;
    }
    bool ecc_metadata_available = have_metadata &&
                                  aggregate_state.has_ecc_flag &&
                                  aggregate_state.ecc_flag_value;
    bool ecc_metadata_complete = ecc_metadata_available &&
                                 aggregate_state.has_ecc_block_data &&
                                 aggregate_state.has_ecc_parity &&
                                 aggregate_state.has_ecc_block_count &&
                                 aggregate_state.has_ecc_original_bytes;
    // Only surface the absence of ECC when the user explicitly requests debug
    // logging; tests intentionally encode payloads without ECC and should not
    // emit warnings during normal operation.
    if (have_metadata &&
        aggregate_state.has_ecc_flag &&
        !aggregate_state.ecc_flag_value &&
        debug_logging_enabled()) {
        console_line(1, "decode: note: payload was encoded without ECC protection");
    }
    if (!bitstream_header_valid) {
        if (ecc_metadata_complete &&
            bitstream.data &&
            bitstream.size >= makocode::ECC_HEADER_TOTAL_BYTES &&
            bit_count >= (u64)makocode::ECC_HEADER_TOTAL_BITS) {
            u64 block_data_value = aggregate_state.ecc_block_data_value;
            u64 parity_value = aggregate_state.ecc_parity_value;
            if (block_data_value <= 0xFFFFu && parity_value <= 0xFFFFu) {
                u8 header_bytes[makocode::ECC_HEADER_TOTAL_BYTES];
                if (makocode::build_ecc_header_bytes(header_bytes,
                                                     makocode::ECC_HEADER_TOTAL_BYTES,
                                                     (u16)block_data_value,
                                                     (u16)parity_value,
                                                     aggregate_state.ecc_block_count_value,
                                                     aggregate_state.ecc_original_bytes_value)) {
                    bool differs = false;
                    for (usize i = 0u; i < makocode::ECC_HEADER_TOTAL_BYTES; ++i) {
                        if (bitstream.data[i] != header_bytes[i]) {
                            differs = true;
                            break;
                        }
                    }
                    if (differs) {
                        for (usize i = 0u; i < makocode::ECC_HEADER_TOTAL_BYTES; ++i) {
                            bitstream.data[i] = header_bytes[i];
                        }
                        ecc_header_repaired = true;
                    }
                }
            }
        } else if (ecc_metadata_available) {
            console_line(2, "decode: warning: ECC metadata incomplete; header reconstruction skipped");
        }
    }
    if (ecc_header_repaired) {
        console_line(2, "decode: repaired ECC header from metadata");
    }
    if (corrupt_header_copies > 0u &&
        bitstream.data &&
        bitstream.size >= ((usize)makocode::ECC_HEADER_COPY_TOTAL_BYTES)) {
        u32 count = corrupt_header_copies;
        if (count > (u32)makocode::ECC_HEADER_COPY_COUNT) {
            count = (u32)makocode::ECC_HEADER_COPY_COUNT;
        }
        for (u32 copy_index = 0u; copy_index < count; ++copy_index) {
            usize base = (usize)copy_index * makocode::ECC_HEADER_COPY_TOTAL_BYTES + makocode::ECC_HEADER_COPY_DATA_BYTES;
            usize limit = base + ((usize)makocode::ECC_HEADER_COPY_PARITY_SYMBOLS + 1u);
            usize copy_end = ((usize)copy_index + 1u) * makocode::ECC_HEADER_COPY_TOTAL_BYTES;
            if (limit > copy_end) {
                limit = copy_end;
            }
            if (limit > bitstream.size) {
                limit = bitstream.size;
            }
            for (usize i = base; i < limit; ++i) {
                bitstream.data[i] ^= 0xFFu;
            }
        }
        if (debug_logging_enabled()) {
            char count_buffer[32];
            u64_to_ascii((u64)count, count_buffer, sizeof(count_buffer));
            console_write(2, "debug decode: corrupted ");
            console_write(2, count_buffer);
            console_line(2, " header copies");
        }
    }
    const char* debug_bitstream_path = getenv("MAKOCODE_DEBUG_BITSTREAM");
    if (debug_bitstream_path && *debug_bitstream_path && bitstream.data && bitstream.size > 0u) {
        int dump_fd = open(debug_bitstream_path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
        if (dump_fd >= 0) {
            const u8* dump_ptr = bitstream.data;
            usize dump_remaining = bitstream.size;
            while (dump_remaining > 0u) {
                usize chunk = dump_remaining;
                if (chunk > 1u << 20) {
                    chunk = 1u << 20;
                }
                ssize_t write_result = write(dump_fd, dump_ptr, chunk);
                if (write_result < 0) {
                    if (debug_logging_enabled()) {
                        console_line(2, "debug decode: bitstream dump write failed");
                    }
                    break;
                }
                if (write_result == 0) {
                    break;
                }
                dump_ptr += (usize)write_result;
                dump_remaining -= (usize)write_result;
            }
            close(dump_fd);
        } else if (debug_logging_enabled()) {
            console_write(2, "debug decode: failed to open bitstream dump ");
            console_line(2, debug_bitstream_path);
        }
    }

    makocode::DecoderContext decoder;
    const char* password_ptr = have_password ? (const char*)password_buffer.data : (const char*)0;
    usize password_length = have_password ? password_buffer.size : 0u;
    if (!decoder.parse(bitstream.data, bit_count, password_ptr, password_length)) {
        if (decoder.password_auth_failed()) {
            console_line(2, "decode: decryption failed (password mismatch or corrupted data)");
            return 1;
        }
        if (!decoder.ecc_correction_failed() && !force_disable_subgrid && !retried_subgrid) {
            console_line(2, "decode: parse failure; retrying without fiducial subgrid");
            force_disable_subgrid = true;
            retried_subgrid = true;
            goto retry_decode;
        }
        if (decoder.ecc_correction_failed() && !force_disable_subgrid && !retried_subgrid) {
            console_line(2, "decode: ECC could not repair the payload; retrying without fiducial subgrid");
            force_disable_subgrid = true;
            retried_subgrid = true;
            goto retry_decode;
        }
        if (decoder.ecc_correction_failed()) {
            console_line(2, "decode: ECC could not repair the payload");
        } else {
            console_line(2, "decode: parse failure");
        }
        return 1;
    }
    if (decoder.password_attempt_made() && decoder.password_was_ignored()) {
        console_line(2, "decode: warning: payload was not encrypted; password ignored");
    }
    if (decoder.ecc_correction_failed()) {
        console_line(2, "decode: warning: payload may contain uncorrected errors");
    }
    const makocode::EccDecodeStats& ecc_stats = decoder.ecc_statistics();
    if (ecc_stats.total_parity_symbols > 0u) {
        u64 corrected_bits = ecc_stats.corrected_symbols * 8u;
        u64 available_bits = ecc_stats.total_parity_symbols * 8u;
        double usage = 0.0;
        if (available_bits > 0u) {
            usage = ((double)corrected_bits * 100.0) / (double)available_bits;
        }
        char count_buffer[32];
        char bits_buffer[32];
        char percent_buffer[32];
        u64_to_ascii(ecc_stats.corrected_symbols, count_buffer, sizeof(count_buffer));
        u64_to_ascii(corrected_bits, bits_buffer, sizeof(bits_buffer));
        format_fixed_3(usage, percent_buffer, sizeof(percent_buffer));
        console_write(1, "decode: ECC detected ");
        console_write(1, count_buffer);
        console_write(1, (ecc_stats.corrected_symbols == 1u) ? " symbol error (" : " symbol errors (");
        console_write(1, bits_buffer);
        console_write(1, (corrected_bits == 1u) ? " bit corrected, " : " bits corrected, ");
        console_write(1, percent_buffer);
        console_line(1, "% of available correction bits)");
    }
    if (!decoder.has_payload) {
        console_line(2, "decode: no payload recovered");
        return 1;
    }
    if (!unpack_archive_to_directory(decoder.payload, output_dir)) {
        const char* raw_fallback = getenv("MAKOCODE_DECODE_RAW_FALLBACK");
        bool allow_raw_fallback = (raw_fallback && *raw_fallback && raw_fallback[0] != '0');
        if (allow_raw_fallback && output_dir) {
            // Fall back to emitting the raw payload (even if empty) only when explicitly enabled.
            char path_buffer[4096];
            usize dir_len = ascii_length(output_dir);
            const char* filename = "payload.bin";
            usize file_len = (usize)sizeof("payload.bin") - 1u;
            bool need_sep = (dir_len > 0u) && (output_dir[dir_len - 1u] != '/' && output_dir[dir_len - 1u] != '\\');
            usize total_len = dir_len + (need_sep ? 1u : 0u) + file_len;
            if (total_len < sizeof(path_buffer)) {
                usize cursor = 0u;
                for (usize i = 0u; i < dir_len; ++i) {
                    char c = output_dir[i];
                    if (c == '\\') {
                        c = '/';
                    }
                    path_buffer[cursor++] = c;
                }
                if (need_sep) {
                    path_buffer[cursor++] = '/';
                }
                for (usize i = 0u; i < file_len; ++i) {
                    path_buffer[cursor++] = filename[i];
                }
                path_buffer[cursor] = '\0';
                write_buffer_to_file(path_buffer, decoder.payload);
            }
            console_line(1, "decode: wrote raw payload.bin (MAKOCODE_DECODE_RAW_FALLBACK enabled)");
            return 0;
        }
        return 1;
    }
    console_write(1, "decode: wrote files to ");
    console_line(1, output_dir);
    return 0;
}

static bool read_file_into_buffer(const char* path, makocode::ByteBuffer& buffer) {
    if (!path) {
        return false;
    }
    buffer.release();
    int fd = open(path, O_RDONLY);
    if (fd < 0) {
        return false;
    }
    u8 chunk[4096];
    while (1) {
        int read_result = read(fd, chunk, sizeof(chunk));
        if (read_result < 0) {
            close(fd);
            buffer.release();
            return false;
        }
        if (read_result == 0) {
            break;
        }
        if (!buffer.append_bytes(chunk, (usize)read_result)) {
            close(fd);
            buffer.release();
            return false;
        }
    }
    close(fd);
    return true;
}

static bool strip_cpp_comments(const makocode::ByteBuffer& input,
                               makocode::ByteBuffer& output) {
    output.release();
    if (!input.data || input.size == 0u) {
        return true;
    }
    bool in_line_comment = false;
    bool in_block_comment = false;
    bool in_string = false;
    bool in_char = false;
    const u8* data = input.data;
    usize size = input.size;
    usize index = 0u;
    while (index < size) {
        u8 ch = data[index];
        if (in_line_comment) {
            if (ch == '\n' || ch == '\r') {
                if (!output.push(ch)) {
                    return false;
                }
                in_line_comment = false;
            }
            index += 1u;
            continue;
        }
        if (in_block_comment) {
            if (ch == '*' && (index + 1u) < size && data[index + 1u] == '/') {
                in_block_comment = false;
                index += 2u;
                continue;
            }
            if (ch == '\n' || ch == '\r') {
                if (!output.push(ch)) {
                    return false;
                }
            }
            index += 1u;
            continue;
        }
        if (in_string) {
            if (!output.push(ch)) {
                return false;
            }
            if (ch == '\\') {
                if ((index + 1u) < size) {
                    u8 next = data[index + 1u];
                    if (!output.push(next)) {
                        return false;
                    }
                    index += 2u;
                    continue;
                }
            } else if (ch == '"') {
                in_string = false;
            }
            index += 1u;
            continue;
        }
        if (in_char) {
            if (!output.push(ch)) {
                return false;
            }
            if (ch == '\\') {
                if ((index + 1u) < size) {
                    u8 next = data[index + 1u];
                    if (!output.push(next)) {
                        return false;
                    }
                    index += 2u;
                    continue;
                }
            } else if (ch == '\'') {
                in_char = false;
            }
            index += 1u;
            continue;
        }
        if (ch == '/' && (index + 1u) < size) {
            u8 next = data[index + 1u];
            if (next == '/') {
                in_line_comment = true;
                index += 2u;
                continue;
            }
            if (next == '*') {
                in_block_comment = true;
                index += 2u;
                continue;
            }
        }
        if (ch == '"') {
            in_string = true;
            if (!output.push(ch)) {
                return false;
            }
            index += 1u;
            continue;
        }
        if (ch == '\'') {
            in_char = true;
            if (!output.push(ch)) {
                return false;
            }
            index += 1u;
            continue;
        }
        if (!output.push(ch)) {
            return false;
        }
        index += 1u;
    }
    return true;
}

static int command_minify(int arg_count, char** args) {
    if (arguments_request_help(arg_count, args)) {
        write_minify_help();
        return 0;
    }
    (void)args;
    if (arg_count > 0) {
        console_line(2, "minify: this command does not accept arguments");
        return 1;
    }
    makocode::ByteBuffer source;
    if (!read_file_into_buffer("makocode.cpp", source)) {
        console_line(2, "minify: failed to read makocode.cpp");
        return 1;
    }
    makocode::ByteBuffer stripped;
    if (!strip_cpp_comments(source, stripped)) {
        console_line(2, "minify: failed to strip comments");
        return 1;
    }
    makocode::ByteBuffer minified;
    bool last_was_space = true;
    bool line_start = true;
    bool in_preprocessor = false;
    for (usize i = 0u; i < stripped.size; ++i) {
        u8 ch = stripped.data[i];
        if (ch == '\r') {
            ch = '\n';
        }
        if (ch == '\n') {
            if (in_preprocessor) {
                if (!minified.push('\n')) {
                    minified.release();
                    console_line(2, "minify: failed to compact whitespace");
                    return 1;
                }
                last_was_space = true;
            } else if (!last_was_space) {
                if (!minified.push(' ')) {
                    minified.release();
                    console_line(2, "minify: failed to compact whitespace");
                    return 1;
                }
                last_was_space = true;
            }
            line_start = true;
            in_preprocessor = false;
            continue;
        }
        bool is_space = (ch == ' ') || (ch == '\t') || (ch == '\f') || (ch == '\v');
        if (is_space) {
            if (line_start) {
                continue;
            }
            if (!last_was_space) {
                if (!minified.push(' ')) {
                    minified.release();
                    console_line(2, "minify: failed to compact whitespace");
                    return 1;
                }
                last_was_space = true;
            }
            continue;
        }
        if (line_start && ch == '#') {
            if (minified.size > 0u) {
                u8& previous = minified.data[minified.size - 1u];
                if (previous == ' ') {
                    previous = '\n';
                } else if (previous != '\n') {
                    if (!minified.push('\n')) {
                        minified.release();
                        console_line(2, "minify: failed to compact whitespace");
                        return 1;
                    }
                }
            }
            if (!minified.push('#')) {
                minified.release();
                console_line(2, "minify: failed to compact whitespace");
                return 1;
            }
            last_was_space = false;
            line_start = false;
            in_preprocessor = true;
            continue;
        }
        if (!minified.push(ch)) {
            minified.release();
            console_line(2, "minify: failed to compact whitespace");
            return 1;
        }
        last_was_space = false;
        line_start = false;
    }
    stripped.release();
    stripped.data = minified.data;
    stripped.size = minified.size;
    stripped.capacity = minified.capacity;
    minified.data = 0;
    minified.size = 0;
    minified.capacity = 0;
    usize start_index = 0u;
    while (start_index < stripped.size &&
           (stripped.data[start_index] == ' ' || stripped.data[start_index] == '\n')) {
        start_index += 1u;
    }
    usize end_index = stripped.size;
    while (end_index > start_index &&
           (stripped.data[end_index - 1u] == ' ' || stripped.data[end_index - 1u] == '\n')) {
        end_index -= 1u;
    }
    if (start_index > 0u && end_index > start_index) {
        for (usize i = start_index; i < end_index; ++i) {
            stripped.data[i - start_index] = stripped.data[i];
        }
    }
    stripped.size = (end_index > start_index) ? (end_index - start_index) : 0u;
    if (!write_bytes_to_file("makocode_minified.cpp", stripped.data, stripped.size)) {
        console_line(2, "minify: failed to write makocode_minified.cpp");
        return 1;
    }
    console_line(1, "minify: wrote makocode_minified.cpp");
    return 0;
}

static void run_coverage_probes() {
    const char* probes = getenv("MAKOCODE_COVERAGE_PROBES");
    if (!probes || probes[0] == '\0') {
        return;
    }

    makocode::ByteBuffer pad_target;
    if (pad_target.ensure(1u)) {
        pad_target.size = 1u;
        pad_target.data[0] = 0xAAu;
        normalize_bits_output_size(pad_target, 3u);
    }

    makocode::ByteBuffer trim_target;
    if (trim_target.ensure(4u)) {
        trim_target.size = 4u;
        for (usize i = 0u; i < trim_target.size; ++i) {
            trim_target.data[i] = 0u;
        }
        normalize_bits_output_size(trim_target, 2u);
    }

    makocode::ByteBuffer scratch_bits;
    makocode::ByteBuffer digit_buffer;
    if (scratch_bits.ensure(2u)) {
        scratch_bits.size = 2u;
        scratch_bits.data[0] = 0xA5u;
        scratch_bits.data[1] = 0x5Au;
        u64 digits_used = 0u;
        bits_to_base_digits(scratch_bits, 12u, 5u, digit_buffer, digits_used);
        (void)digits_used;
    }
}

int main(int argc, char** argv) {
    run_coverage_probes();
    if (argc < 2) {
        write_usage();
        return 0;
    }
    int arg_index = 1;
    while (arg_index < argc) {
        char* arg = argv[arg_index];
        if (!arg) {
            ++arg_index;
            continue;
        }
        if (consume_debug_flag(arg)) {
            ++arg_index;
            continue;
        }
        usize length = ascii_length(arg);
        if (ascii_equals_token(arg, length, "--help") ||
            ascii_equals_token(arg, length, "-h")) {
            write_usage();
            return 0;
        }
        break;
    }
    if (arg_index >= argc) {
        write_usage();
        return 0;
    }
    const char* command = argv[arg_index];
    int command_argc = argc - arg_index - 1;
    char** command_argv = argv + arg_index + 1;
    if (ascii_compare(command, "encode") == 0) {
        return command_encode(command_argc, command_argv);
    }
    if (ascii_compare(command, "decode") == 0) {
        return command_decode(command_argc, command_argv);
    }
    if (ascii_compare(command, "overlay") == 0) {
        return command_overlay(command_argc, command_argv);
    }
    if (ascii_compare(command, "minify") == 0) {
        return command_minify(command_argc, command_argv);
    }
    write_usage();
    return 0;
}
