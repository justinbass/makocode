- Fix test:
• Recap of What’s Broken

  - The failing artifact is the transformed page from 0001_palette_white_black_blot_black. Block 24 (0‑based) of the ECC payload differs between clean and transformed
    decodes only in data byte index 5: clean value 0xE5, transformed 0xE7 (test/tmp_clean_decode/stderr.log:14-41 vs test/tmp_transformed_decode/stderr.log:14-41). That byte
    maps to absolute payload offset 24*28 + 5 = 677, so the ink blot flipped a single bit inside the payload region—not in the parity gutter.
  - Despite logging corrected_symbols=1 for that block (test/tmp_transformed_decode/stderr.log:518), the decoder writes two wrong bytes into the recovered stream. cmp -l
    test/tmp_clean_decode/compressed.bin test/tmp_transformed_decode/compressed.bin shows differences at payload byte 678 (0xE5→0xE7, the genuine flip) and at byte 681
    (0x20→0x22), which is a decoder‑induced error.
  - Debug logs confirm the extra corruption: symbol #8 is changed from 0x20 pre‑decode to 0x22 post‑decode (test/tmp_transformed_decode/stderr.log:19 vs :271-274), even
    though the physical capture had no damage in that position.
  - Manual Reed‑Solomon verification with reedsolo.RSCodec(nsym=224, fcr=1) succeeds when we prepend three zero symbols (shortening offset 255−252). The library reports a
    single errata position and fixes byte #5 without touching #8, proving the data is fully correctable and that Makocode’s own locator math is at fault.
  - Syndromes computed on the distorted block are non-zero across all 224 parity symbols, so the “no syndrome” idea is false; Makocode simply misidentifies the error
    location.
  - Root cause: rs_find_error_locations (makocode.cpp:8684-8703) evaluates the locator polynomial over α^i for i=0…codeword_length-1, assuming a full‑length 255-symbol
    code. For shortened codewords, the exponent sweep must be offset by (RS_FIELD_SIZE - codeword_length) to model the leading erased symbols. Because the offset is missing,
    the search reports a location three symbols to the right of reality (offset=3 here), “corrects” the wrong byte, and leaves the real error uncorrected—hence the double
    corruption and LZMA failure.

  Data You Asked For

  - Payload bytes, clean vs transformed (block 24):
    clean  : 00 C6 57 65 10 E5 AA 51 20 04 08 B8 DE 23 C8 1B 6E 74 D6 1D 82 97 17 CD C7 4E B8 E7
    corrupt: 00 C6 57 65 10 E7 AA 51 20 04 08 B8 DE 23 C8 1B 6E 74 D6 1D 82 97 17 CD C7 4E B8 E7
  - Parity bytes (identical before/after): start with 72 BF 2B 5A 96 90 38 C3 61 81 C7 60 … and run 224 bytes total (full list in test/tmp_clean_decode/stderr.log:42-265).

  Plan to Fix Later

  1. Chien Search Offset
      - Update rs_find_error_locations so that it evaluates at gf_pow_alpha(i + shortening_offset) where shortening_offset = RS_FIELD_SIZE - codeword_length. That alone
        should align located indices with the real symbols when the codeword is shorter than 255.
      - Add regression assertions (in debug mode or unit test) to ensure positions[position_count++] never exceeds codeword_length-1 and that a single flipped data byte gets
        corrected without touching neighbors.
  2. Unit / Integration Test
      - Craft a deterministic fixture: encode a small payload with ECC ratio ≥8 (e.g., 28 data / 224 parity), flip one known byte in the encoded stream, run makocode decode,
        and assert the reconstructed compressed.bin matches the clean payload.
      - Reuse or script the existing captured artifacts (test/tmp_clean_decode, test/tmp_transformed_decode) to reproduce the blot scenario automatically.
  3. Tooling Support (optional but handy)
      - Leave the temporary debug hooks (MAKOCODE_DEBUG_ECC_BLOCK and MAKOCODE_DUMP_COMPRESSED) in a testing branch or behind #ifdef DEBUG guards so future ECC regressions
        can dump raw blocks without modifying the main decoder.
  4. Documentation / Notes
      - Document in README.md or developer notes that shortened RS codes need the exponent offset, to prevent future regressions if block sizing changes.

  Once the offset math is patched and the regression test passes, rerun make test to confirm the ink‑blot roundtrip succeeds.

- Features
 - Confirm overlay avoids header or sensitive data
 - Overlay needs explicit palette arg, threshold the overlay image first.
 - Overay needs --ignore-color arg
 - Overlay won't work well on final page
 - Color channels non-base-2, works but slow
 - 15 column ppm (from convert) in overlay, ignore newlines

- Decoding
 - Fix all commented out tests in scripts/run_test_suite.sh
 - Remove entire page test, with high ECC
 - Remove all headers from encoding, one by one and fix decoding for each one.
  - # MAKOCODE_BITS
  - # MAKOCODE_PAGE_BITS
  - # MAKOCODE_PAGE_WIDTH_PX
  - # MAKOCODE_PAGE_HEIGHT_PX
  - # MAKOCODE_ECC
  - # MAKOCODE_ECC_BLOCK_DATA
  - # MAKOCODE_ECC_PARITY
  - # MAKOCODE_ECC_BLOCK_COUNT
  - # MAKOCODE_ECC_ORIGINAL_BYTES
  - # MAKOCODE_COLOR_CHANNELS
   - Detect colors automatically in decoding, optionally write out color channel information in footer
  - # MAKOCODE_PAGE_COUNT
  - # MAKOCODE_PAGE_INDEX
   - Document user can provide blank pages for their gaps. Argument could be supplied for which pages are missing. Makocode could also encode page number on each page - or else guess/try missing pages.
  - # MAKOCODE_FOOTER_ROWS
  - # MAKOCODE_FONT_SIZE
  - # MAKOCODE_FIDUCIAL_SIZE
  - # MAKOCODE_FIDUCIAL_COLUMNS
  - # MAKOCODE_FIDUCIAL_ROWS
  - # MAKOCODE_FIDUCIAL_MARGIN
  - # MAKOCODE_SUBGRID_COL_OFFSETS
  - # MAKOCODE_SUBGRID_ROW_OFFSETS
 - Wavy distortion test
 - All distortions test (scale 2.5x, border/dirt, stretch, wavy) in one large image per color
 - Discolored paper (off-white) test
 - One last ask to surmise any way to improve detection of a scanned image, use optar/paperbak as reference
 - Encode ECC header or any basic data in footer in larger dots in first/last color (2-3x the regular dots). This makes it localized but less sensitive to certain kinds of damage. Footer could be optional if normal dots are kepts, it could be a backup. Or remove regular header and make footer mandatory.
    - Also triple ECC header redundancy is probably not shuffled based on whitespace at beginning of block before/after the triple commit.
 - Print calibration page, has mutliple settings, possibly binary search - scanned back in and the best settings are printed to the user. Data is randomly generated seed-0.

- Finalize
 - Mode for no filesystem, and no includes e.g. stdin/stdout data. Use preprocessor directive around all includes: #if INCLUDES \n #include ... \n #endif . Mention in docs as part of futureproofing / self-contained solution.
 - Run physical tests, check different printer/scanner/computer combinations and paper/film mediums. Leave data for a while, artificially age, folder paper, different storage conditions, etc. Post findings.
 - Determine proper defaults
 - Attempt to optimize/shrink/minify/dedupe/fix-warnings/remove-unused/constants-everywhere code, it still should be readable
 - Dependencies section (C++, G++, Shell/Linux, Python for testing)
 - Much better documentation, or a spec
 - Suggestions and specs for archival file formats (Text: txt, images: PPM, Video: YUV4MPEG2)
 - Full test coverage, remove python dependency (scripts/ppm_transform.py)
